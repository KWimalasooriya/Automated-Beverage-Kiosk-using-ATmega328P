   1               		.file	"led.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	i2c_init
  12               	i2c_init:
  13               	.LFB6:
  14               		.file 1 "LCD.h"
   1:LCD.h         **** #ifndef LCD_H
   2:LCD.h         **** #define LCD_H
   3:LCD.h         **** 
   4:LCD.h         **** #include <avr/io.h>
   5:LCD.h         **** #include <util/delay.h>
   6:LCD.h         **** #include <compat/twi.h>
   7:LCD.h         **** 
   8:LCD.h         **** // LCD I2C address (usually 0x27 or 0x3F depending on your module)
   9:LCD.h         **** #define LCD_I2C_ADDRESS 0x27
  10:LCD.h         **** 
  11:LCD.h         **** // LCD Control bits
  12:LCD.h         **** #define LCD_BACKLIGHT 0x08  // On
  13:LCD.h         **** #define LCD_ENABLE    0x04  // Enable bit
  14:LCD.h         **** #define LCD_RW        0x02  // Read/Write bit
  15:LCD.h         **** #define LCD_RS        0x01  // Register select bit
  16:LCD.h         **** 
  17:LCD.h         **** // I2C initialization
  18:LCD.h         **** void i2c_init(void) {
  15               		.loc 1 18 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  19:LCD.h         ****     TWSR = 0x00; // Set prescaler bits to 0
  21               		.loc 1 19 0
  22 0000 1092 B900 		sts 185,__zero_reg__
  20:LCD.h         ****     TWBR = 0x0C; // SCL frequency is 400kHz with 16MHz clock
  23               		.loc 1 20 0
  24 0004 8CE0      		ldi r24,lo8(12)
  25 0006 8093 B800 		sts 184,r24
  21:LCD.h         ****     TWCR = (1 << TWEN); // Enable TWI (I2C)
  26               		.loc 1 21 0
  27 000a 84E0      		ldi r24,lo8(4)
  28 000c 8093 BC00 		sts 188,r24
  29 0010 0895      		ret
  30               		.cfi_endproc
  31               	.LFE6:
  33               	.global	i2c_start
  35               	i2c_start:
  36               	.LFB7:
  22:LCD.h         **** }
  23:LCD.h         **** 
  24:LCD.h         **** // Send START condition on I2C
  25:LCD.h         **** void i2c_start(void) {
  37               		.loc 1 25 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
  26:LCD.h         ****     TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT); // Send START condition
  43               		.loc 1 26 0
  44 0012 84EA      		ldi r24,lo8(-92)
  45 0014 8093 BC00 		sts 188,r24
  46               	.L3:
  27:LCD.h         ****     while (!(TWCR & (1 << TWINT))); // Wait for START to be transmitted
  47               		.loc 1 27 0 discriminator 1
  48 0018 8091 BC00 		lds r24,188
  49 001c 87FF      		sbrs r24,7
  50 001e 00C0      		rjmp .L3
  51               	/* epilogue start */
  28:LCD.h         **** }
  52               		.loc 1 28 0
  53 0020 0895      		ret
  54               		.cfi_endproc
  55               	.LFE7:
  57               	.global	i2c_stop
  59               	i2c_stop:
  60               	.LFB8:
  29:LCD.h         **** 
  30:LCD.h         **** // Send STOP condition on I2C
  31:LCD.h         **** void i2c_stop(void) {
  61               		.loc 1 31 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
  32:LCD.h         ****     TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT); // Send STOP condition
  67               		.loc 1 32 0
  68 0022 84E9      		ldi r24,lo8(-108)
  69 0024 8093 BC00 		sts 188,r24
  70 0028 0895      		ret
  71               		.cfi_endproc
  72               	.LFE8:
  74               	.global	i2c_write
  76               	i2c_write:
  77               	.LFB9:
  33:LCD.h         **** }
  34:LCD.h         **** 
  35:LCD.h         **** // Write data to I2C
  36:LCD.h         **** void i2c_write(uint8_t data) {
  78               		.loc 1 36 0
  79               		.cfi_startproc
  80               	.LVL0:
  81               	/* prologue: function */
  82               	/* frame size = 0 */
  83               	/* stack size = 0 */
  84               	.L__stack_usage = 0
  37:LCD.h         ****     TWDR = data; // Load data to data register
  85               		.loc 1 37 0
  86 002a 8093 BB00 		sts 187,r24
  38:LCD.h         ****     TWCR = (1 << TWEN) | (1 << TWINT); // Start transmission of data
  87               		.loc 1 38 0
  88 002e 84E8      		ldi r24,lo8(-124)
  89               	.LVL1:
  90 0030 8093 BC00 		sts 188,r24
  91               	.LVL2:
  92               	.L8:
  39:LCD.h         ****     while (!(TWCR & (1 << TWINT))); // Wait for data to be transmitted
  93               		.loc 1 39 0 discriminator 1
  94 0034 8091 BC00 		lds r24,188
  95 0038 87FF      		sbrs r24,7
  96 003a 00C0      		rjmp .L8
  97               	/* epilogue start */
  40:LCD.h         **** }
  98               		.loc 1 40 0
  99 003c 0895      		ret
 100               		.cfi_endproc
 101               	.LFE9:
 103               	.global	lcd_enable
 105               	lcd_enable:
 106               	.LFB10:
  41:LCD.h         **** 
  42:LCD.h         **** // Enable data transmission to LCD
  43:LCD.h         **** void lcd_enable(uint8_t data) {
 107               		.loc 1 43 0
 108               		.cfi_startproc
 109               	.LVL3:
 110 003e CF93      		push r28
 111               	.LCFI0:
 112               		.cfi_def_cfa_offset 3
 113               		.cfi_offset 28, -2
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 1 */
 117               	.L__stack_usage = 1
 118 0040 C82F      		mov r28,r24
  44:LCD.h         ****     i2c_start();
 119               		.loc 1 44 0
 120 0042 0E94 0000 		call i2c_start
 121               	.LVL4:
  45:LCD.h         ****     i2c_write(LCD_I2C_ADDRESS << 1); // Send address with write bit
 122               		.loc 1 45 0
 123 0046 8EE4      		ldi r24,lo8(78)
 124 0048 0E94 0000 		call i2c_write
 125               	.LVL5:
  46:LCD.h         ****     i2c_write(data | LCD_ENABLE);    // Send data with enable bit set
 126               		.loc 1 46 0
 127 004c 8C2F      		mov r24,r28
 128 004e 8460      		ori r24,lo8(4)
 129 0050 0E94 0000 		call i2c_write
 130               	.LVL6:
 131               	.LBB47:
 132               	.LBB48:
 133               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 134               		.loc 2 276 0
 135 0054 0000      		nop
 136               	.LVL7:
 137               	.LBE48:
 138               	.LBE47:
  47:LCD.h         ****     _delay_us(1);
  48:LCD.h         ****     i2c_write(data & ~LCD_ENABLE);   // Clear enable bit
 139               		.loc 1 48 0
 140 0056 8C2F      		mov r24,r28
 141 0058 8B7F      		andi r24,lo8(-5)
 142 005a 0E94 0000 		call i2c_write
 143               	.LVL8:
 144               	.LBB49:
 145               	.LBB50:
 146               		.loc 2 276 0
 147 005e 80E1      		ldi r24,lo8(16)
 148 0060 8A95      	1:	dec r24
 149 0062 01F4      		brne 1b
 150 0064 00C0      		rjmp .
 151               	.LVL9:
 152               	.LBE50:
 153               	.LBE49:
 154               	.LBB51:
 155               	.LBB52:
  32:LCD.h         **** }
 156               		.loc 1 32 0
 157 0066 84E9      		ldi r24,lo8(-108)
 158 0068 8093 BC00 		sts 188,r24
 159               	/* epilogue start */
 160               	.LBE52:
 161               	.LBE51:
  49:LCD.h         ****     _delay_us(50);
  50:LCD.h         ****     i2c_stop();
  51:LCD.h         **** }
 162               		.loc 1 51 0
 163 006c CF91      		pop r28
 164               	.LVL10:
 165 006e 0895      		ret
 166               		.cfi_endproc
 167               	.LFE10:
 169               	.global	lcd_send
 171               	lcd_send:
 172               	.LFB11:
  52:LCD.h         **** 
  53:LCD.h         **** // Send data/command to the LCD
  54:LCD.h         **** void lcd_send(uint8_t data, uint8_t mode) {
 173               		.loc 1 54 0
 174               		.cfi_startproc
 175               	.LVL11:
 176 0070 CF93      		push r28
 177               	.LCFI1:
 178               		.cfi_def_cfa_offset 3
 179               		.cfi_offset 28, -2
 180 0072 DF93      		push r29
 181               	.LCFI2:
 182               		.cfi_def_cfa_offset 4
 183               		.cfi_offset 29, -3
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 2 */
 187               	.L__stack_usage = 2
 188 0074 C82F      		mov r28,r24
 189 0076 D62F      		mov r29,r22
 190 0078 D860      		ori r29,lo8(8)
 191               	.LVL12:
  55:LCD.h         ****     uint8_t highNibble = (data & 0xF0) | mode | LCD_BACKLIGHT;
  56:LCD.h         ****     uint8_t lowNibble = ((data << 4) & 0xF0) | mode | LCD_BACKLIGHT;
  57:LCD.h         ****     
  58:LCD.h         ****     lcd_enable(highNibble);
 192               		.loc 1 58 0
 193 007a 807F      		andi r24,lo8(-16)
 194               	.LVL13:
 195 007c 8D2B      		or r24,r29
 196               	.LVL14:
 197 007e 0E94 0000 		call lcd_enable
 198               	.LVL15:
  59:LCD.h         ****     lcd_enable(lowNibble);
 199               		.loc 1 59 0
 200 0082 20E1      		ldi r18,lo8(16)
 201 0084 C29F      		mul r28,r18
 202 0086 C001      		movw r24,r0
 203 0088 1124      		clr __zero_reg__
 204 008a 8D2B      		or r24,r29
 205               	/* epilogue start */
  60:LCD.h         **** }
 206               		.loc 1 60 0
 207 008c DF91      		pop r29
 208               	.LVL16:
 209 008e CF91      		pop r28
 210               	.LVL17:
  59:LCD.h         ****     lcd_enable(lowNibble);
 211               		.loc 1 59 0
 212 0090 0C94 0000 		jmp lcd_enable
 213               	.LVL18:
 214               		.cfi_endproc
 215               	.LFE11:
 217               	.global	lcd_command
 219               	lcd_command:
 220               	.LFB12:
  61:LCD.h         **** 
  62:LCD.h         **** // Send command to the LCD
  63:LCD.h         **** void lcd_command(uint8_t cmd) {
 221               		.loc 1 63 0
 222               		.cfi_startproc
 223               	.LVL19:
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
  64:LCD.h         ****     lcd_send(cmd, 0);
 228               		.loc 1 64 0
 229 0094 60E0      		ldi r22,0
 230 0096 0C94 0000 		jmp lcd_send
 231               	.LVL20:
 232               		.cfi_endproc
 233               	.LFE12:
 235               	.global	lcd_print
 237               	lcd_print:
 238               	.LFB13:
  65:LCD.h         **** }
  66:LCD.h         **** 	
  67:LCD.h         **** // Print string on the LCD
  68:LCD.h         **** void lcd_print(char *str) {
 239               		.loc 1 68 0
 240               		.cfi_startproc
 241               	.LVL21:
 242 009a CF93      		push r28
 243               	.LCFI3:
 244               		.cfi_def_cfa_offset 3
 245               		.cfi_offset 28, -2
 246 009c DF93      		push r29
 247               	.LCFI4:
 248               		.cfi_def_cfa_offset 4
 249               		.cfi_offset 29, -3
 250               	/* prologue: function */
 251               	/* frame size = 0 */
 252               	/* stack size = 2 */
 253               	.L__stack_usage = 2
 254 009e EC01      		movw r28,r24
 255               	.LVL22:
 256               	.L14:
  69:LCD.h         ****     while (*str) {
 257               		.loc 1 69 0
 258 00a0 8991      		ld r24,Y+
 259               	.LVL23:
 260 00a2 8823      		tst r24
 261 00a4 01F0      		breq .L16
  70:LCD.h         ****         lcd_send(*str, LCD_RS);
 262               		.loc 1 70 0
 263 00a6 61E0      		ldi r22,lo8(1)
 264 00a8 0E94 0000 		call lcd_send
 265               	.LVL24:
 266 00ac 00C0      		rjmp .L14
 267               	.LVL25:
 268               	.L16:
 269               	/* epilogue start */
  71:LCD.h         ****         str++;
  72:LCD.h         ****     }
  73:LCD.h         **** }
 270               		.loc 1 73 0
 271 00ae DF91      		pop r29
 272 00b0 CF91      		pop r28
 273               	.LVL26:
 274 00b2 0895      		ret
 275               		.cfi_endproc
 276               	.LFE13:
 278               	.global	lcd_clear
 280               	lcd_clear:
 281               	.LFB14:
  74:LCD.h         **** 
  75:LCD.h         **** // Clear the LCD screen
  76:LCD.h         **** void lcd_clear(void) {
 282               		.loc 1 76 0
 283               		.cfi_startproc
 284               	/* prologue: function */
 285               	/* frame size = 0 */
 286               	/* stack size = 0 */
 287               	.L__stack_usage = 0
  77:LCD.h         ****     lcd_command(0x01); // Clear display command
 288               		.loc 1 77 0
 289 00b4 81E0      		ldi r24,lo8(1)
 290 00b6 0E94 0000 		call lcd_command
 291               	.LVL27:
 292               	.LBB53:
 293               	.LBB54:
 187:/usr/lib/avr/include/util/delay.h **** 
 294               		.loc 2 187 0
 295 00ba 83EF      		ldi r24,lo8(499)
 296 00bc 91E0      		ldi r25,hi8(499)
 297 00be 0197      	1:	sbiw r24,1
 298 00c0 01F4      		brne 1b
 299 00c2 00C0      		rjmp .
 300 00c4 0000      		nop
 301               	.LVL28:
 302 00c6 0895      		ret
 303               	.LBE54:
 304               	.LBE53:
 305               		.cfi_endproc
 306               	.LFE14:
 308               		.section	.rodata
 309               	.LC0:
 310 0000 00        		.byte	0
 311 0001 40        		.byte	64
 312 0002 14        		.byte	20
 313 0003 54        		.byte	84
 314               		.text
 315               	.global	lcd_setCursor
 317               	lcd_setCursor:
 318               	.LFB15:
  78:LCD.h         ****     _delay_ms(2);      // Wait for the command to execute
  79:LCD.h         **** }
  80:LCD.h         **** 
  81:LCD.h         **** // Set cursor position on the LCD
  82:LCD.h         **** void lcd_setCursor(uint8_t col, uint8_t row) {
 319               		.loc 1 82 0
 320               		.cfi_startproc
 321               	.LVL29:
 322 00c8 0F93      		push r16
 323               	.LCFI5:
 324               		.cfi_def_cfa_offset 3
 325               		.cfi_offset 16, -2
 326 00ca 1F93      		push r17
 327               	.LCFI6:
 328               		.cfi_def_cfa_offset 4
 329               		.cfi_offset 17, -3
 330 00cc CF93      		push r28
 331               	.LCFI7:
 332               		.cfi_def_cfa_offset 5
 333               		.cfi_offset 28, -4
 334 00ce DF93      		push r29
 335               	.LCFI8:
 336               		.cfi_def_cfa_offset 6
 337               		.cfi_offset 29, -5
 338 00d0 00D0      		rcall .
 339 00d2 00D0      		rcall .
 340               	.LCFI9:
 341               		.cfi_def_cfa_offset 10
 342 00d4 CDB7      		in r28,__SP_L__
 343 00d6 DEB7      		in r29,__SP_H__
 344               	.LCFI10:
 345               		.cfi_def_cfa_register 28
 346               	/* prologue: function */
 347               	/* frame size = 4 */
 348               	/* stack size = 8 */
 349               	.L__stack_usage = 8
  83:LCD.h         ****     uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
 350               		.loc 1 83 0
 351 00d8 0091 0000 		lds r16,.LC0
 352 00dc 1091 0000 		lds r17,.LC0+1
 353 00e0 2091 0000 		lds r18,.LC0+2
 354 00e4 3091 0000 		lds r19,.LC0+3
 355 00e8 0983      		std Y+1,r16
 356 00ea 1A83      		std Y+2,r17
 357 00ec 2B83      		std Y+3,r18
 358 00ee 3C83      		std Y+4,r19
  84:LCD.h         ****     lcd_command(0x80 | (col + row_offsets[row]));  // Set DDRAM address
 359               		.loc 1 84 0
 360 00f0 FE01      		movw r30,r28
 361 00f2 E60F      		add r30,r22
 362 00f4 F11D      		adc r31,__zero_reg__
 363 00f6 9181      		ldd r25,Z+1
 364 00f8 890F      		add r24,r25
 365               	.LVL30:
 366 00fa 8068      		ori r24,lo8(-128)
 367               	/* epilogue start */
  85:LCD.h         **** }
 368               		.loc 1 85 0
 369 00fc 0F90      		pop __tmp_reg__
 370 00fe 0F90      		pop __tmp_reg__
 371 0100 0F90      		pop __tmp_reg__
 372 0102 0F90      		pop __tmp_reg__
 373 0104 DF91      		pop r29
 374 0106 CF91      		pop r28
 375 0108 1F91      		pop r17
 376 010a 0F91      		pop r16
  84:LCD.h         ****     lcd_command(0x80 | (col + row_offsets[row]));  // Set DDRAM address
 377               		.loc 1 84 0
 378 010c 0C94 0000 		jmp lcd_command
 379               	.LVL31:
 380               		.cfi_endproc
 381               	.LFE15:
 383               	.global	initialize
 385               	initialize:
 386               	.LFB16:
  86:LCD.h         **** 
  87:LCD.h         **** // Initialize the LCD
  88:LCD.h         **** void initialize(void) {
 387               		.loc 1 88 0
 388               		.cfi_startproc
 389               	/* prologue: function */
 390               	/* frame size = 0 */
 391               	/* stack size = 0 */
 392               	.L__stack_usage = 0
 393               	.LVL32:
 394               	.LBB55:
 395               	.LBB56:
 187:/usr/lib/avr/include/util/delay.h **** 
 396               		.loc 2 187 0
 397 0110 83ED      		ldi r24,lo8(12499)
 398 0112 90E3      		ldi r25,hi8(12499)
 399 0114 0197      	1:	sbiw r24,1
 400 0116 01F4      		brne 1b
 401 0118 00C0      		rjmp .
 402 011a 0000      		nop
 403               	.LVL33:
 404               	.LBE56:
 405               	.LBE55:
  89:LCD.h         ****     _delay_ms(50);        // Wait for LCD to power up
  90:LCD.h         ****     lcd_command(0x02);    // Initialize in 4-bit mode
 406               		.loc 1 90 0
 407 011c 82E0      		ldi r24,lo8(2)
 408 011e 0E94 0000 		call lcd_command
 409               	.LVL34:
  91:LCD.h         ****     lcd_command(0x28);    // 2 line, 5x7 matrix
 410               		.loc 1 91 0
 411 0122 88E2      		ldi r24,lo8(40)
 412 0124 0E94 0000 		call lcd_command
 413               	.LVL35:
  92:LCD.h         ****     lcd_command(0x0C);    // Display on, cursor off
 414               		.loc 1 92 0
 415 0128 8CE0      		ldi r24,lo8(12)
 416 012a 0E94 0000 		call lcd_command
 417               	.LVL36:
  93:LCD.h         ****     lcd_command(0x06);    // Increment cursor
 418               		.loc 1 93 0
 419 012e 86E0      		ldi r24,lo8(6)
 420 0130 0E94 0000 		call lcd_command
 421               	.LVL37:
  94:LCD.h         ****     lcd_clear();          // Clear display
 422               		.loc 1 94 0
 423 0134 0C94 0000 		jmp lcd_clear
 424               	.LVL38:
 425               		.cfi_endproc
 426               	.LFE16:
 428               	.global	isSwitch1Pressed
 430               	isSwitch1Pressed:
 431               	.LFB19:
 432               		.file 3 "led.c"
   1:led.c         **** #define F_CPU 1000000
   2:led.c         **** #include <avr/io.h>
   3:led.c         **** #include <util/delay.h>
   4:led.c         **** #include "LCD.h"
   5:led.c         **** 
   6:led.c         **** // Function prototypes
   7:led.c         **** void setup();
   8:led.c         **** uint8_t isSwitch1Pressed();
   9:led.c         **** uint8_t isSwitch2Pressed();
  10:led.c         **** uint8_t isEncoderPressed();
  11:led.c         **** void displayModes();
  12:led.c         **** void displayProcessing();
  13:led.c         **** void displayChoosePercentages();
  14:led.c         **** void displayExceed100();
  15:led.c         **** void displayFruit(char *fruit, uint8_t percentage);
  16:led.c         **** void displayOrderComplete();
  17:led.c         **** void displayEnjoyDrink();
  18:led.c         **** void turnOnMotor(uint8_t motor, uint8_t percentage);
  19:led.c         **** void turnOffMotors();
  20:led.c         **** int8_t readEncoder();
  21:led.c         **** void checkPercentageSum();
  22:led.c         **** uint16_t getDelayForPercentage(uint8_t percentage);
  23:led.c         **** void manualMode();  // Function prototype for manual mode
  24:led.c         **** 
  25:led.c         **** // Variables
  26:led.c         **** char *fruits[] = {"PINEAPPLE", "MANGO", "APPLE", "ORANGE"};
  27:led.c         **** uint8_t fruitIndex = 0;
  28:led.c         **** uint8_t percentages[4] = {0, 0, 0, 0};  // Array to store percentages for each fruit
  29:led.c         **** uint8_t percentage = 0;
  30:led.c         **** uint8_t selectingPercentage = 0;
  31:led.c         **** uint8_t switch1Pressed = 0;
  32:led.c         **** 
  33:led.c         **** int main(void) {
  34:led.c         ****     setup();  // Initialize pins
  35:led.c         ****     initialize();  // Initialize LCD
  36:led.c         **** 
  37:led.c         ****     while (1) {
  38:led.c         ****         displayModes();  // Display mode selection at the start
  39:led.c         **** 
  40:led.c         ****         // Wait for Switch 1 (PC0) press
  41:led.c         ****         while (!isSwitch1Pressed()) {
  42:led.c         ****             // Check if Switch 2 (PC1) is pressed for Manual Mode
  43:led.c         ****             if (isSwitch2Pressed()) {
  44:led.c         ****                 // Disable Switches for Manual Mode
  45:led.c         ****                 switch1Pressed = 1;  // Disable Switch 1
  46:led.c         ****                 manualMode();        // Go to Manual Mode
  47:led.c         ****             }
  48:led.c         ****         }
  49:led.c         **** 
  50:led.c         ****         // Disable Switch 1 after the first press
  51:led.c         ****         switch1Pressed = 1;
  52:led.c         **** 
  53:led.c         ****         // Display "Processing.." and other startup messages
  54:led.c         ****         displayProcessing();
  55:led.c         ****         _delay_ms(4000);
  56:led.c         **** 
  57:led.c         ****         displayChoosePercentages();
  58:led.c         ****         _delay_ms(4000);
  59:led.c         **** 
  60:led.c         ****         lcd_clear();
  61:led.c         ****         lcd_setCursor(0, 0);
  62:led.c         ****         lcd_print("Total should not");
  63:led.c         ****         lcd_setCursor(0, 1);
  64:led.c         ****         lcd_print("exceed 100%");
  65:led.c         ****         _delay_ms(4000);
  66:led.c         **** 
  67:led.c         ****         // Begin the fruit and percentage selection process
  68:led.c         ****         displayFruit(fruits[fruitIndex], percentage);
  69:led.c         ****         selectingPercentage = 1;  // Enable percentage selection
  70:led.c         **** 
  71:led.c         ****         while (1) {
  72:led.c         ****             if (selectingPercentage) {
  73:led.c         ****                 // Read the rotary encoder to adjust the percentage
  74:led.c         ****                 int8_t rotation = readEncoder();
  75:led.c         ****                 if (rotation > 0 && percentage < 100) {
  76:led.c         ****                     percentage += 20;
  77:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percenta
  78:led.c         ****                 } else if (rotation < 0 && percentage > 0) {
  79:led.c         ****                     percentage -= 20;
  80:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percenta
  81:led.c         ****                 }
  82:led.c         **** 
  83:led.c         ****                 // Check if the rotary encoder switch is pressed to confirm the percentage and move
  84:led.c         ****                 if (isEncoderPressed()) {
  85:led.c         ****                     _delay_ms(50); // Debounce delay
  86:led.c         ****                     if (isEncoderPressed()) { // Confirm switch press after delay
  87:led.c         ****                         percentages[fruitIndex] = percentage;  // Store the selected percentage
  88:led.c         ****                         fruitIndex++;  // Move to the next fruit
  89:led.c         **** 
  90:led.c         ****                         if (fruitIndex < 4) {
  91:led.c         ****                             percentage = 0;  // Reset percentage for the next fruit
  92:led.c         ****                             displayFruit(fruits[fruitIndex], percentage);  // Display next fruit
  93:led.c         ****                         } else {
  94:led.c         ****                             selectingPercentage = 0;  // Disable encoder
  95:led.c         ****                             checkPercentageSum();  // Check if total exceeds 100
  96:led.c         ****                             break;  // Exit the inner loop
  97:led.c         ****                         }
  98:led.c         ****                     }
  99:led.c         ****                 }
 100:led.c         ****             }
 101:led.c         ****             _delay_ms(50);  // Small delay for debouncing
 102:led.c         ****         }
 103:led.c         ****     }
 104:led.c         **** 
 105:led.c         ****     return 0;
 106:led.c         **** }
 107:led.c         **** 
 108:led.c         **** // Function to set up the button and encoder pins
 109:led.c         **** void setup() {
 110:led.c         ****     DDRC &= ~(1 << PC0);  // Set PC0 (Switch 1) as input
 111:led.c         ****     PORTC |= (1 << PC0);  // Enable pull-up resistor on PC0
 112:led.c         **** 
 113:led.c         ****     DDRC &= ~(1 << PC1);  // Set PC1 (Switch 2) as input
 114:led.c         ****     PORTC |= (1 << PC1);  // Enable pull-up resistor on PC1
 115:led.c         **** 
 116:led.c         ****     DDRB &= ~(1 << PB1);  // Set PB1 (CLK) as input
 117:led.c         ****     DDRB &= ~(1 << PB2);  // Set PB2 (DT) as input
 118:led.c         ****     DDRB &= ~(1 << PB3);  // Set PB3 (SW) as input
 119:led.c         ****     PORTB |= (1 << PB1) | (1 << PB2) | (1 << PB3);  // Enable pull-up resistors for encoder
 120:led.c         **** 
 121:led.c         ****     // Set relay control pins as output (assuming PORTD)
 122:led.c         ****     DDRD |= (1 << PD0) | (1 << PD1) | (1 << PD2) | (1 << PD3);  // Example pins for motors
 123:led.c         ****     turnOffMotors();  // Ensure motors are off initially
 124:led.c         **** }
 125:led.c         **** 
 126:led.c         **** // Function to check if Switch 1 (PC0) is pressed
 127:led.c         **** uint8_t isSwitch1Pressed() {
 433               		.loc 3 127 0
 434               		.cfi_startproc
 435               	/* prologue: function */
 436               	/* frame size = 0 */
 437               	/* stack size = 0 */
 438               	.L__stack_usage = 0
 128:led.c         ****     return !(PINC & (1 << PC0));
 439               		.loc 3 128 0
 440 0138 86B1      		in r24,0x6
 441 013a 8095      		com r24
 129:led.c         **** }
 442               		.loc 3 129 0
 443 013c 8170      		andi r24,lo8(1)
 444 013e 0895      		ret
 445               		.cfi_endproc
 446               	.LFE19:
 448               	.global	isSwitch2Pressed
 450               	isSwitch2Pressed:
 451               	.LFB20:
 130:led.c         **** 
 131:led.c         **** // Function to check if Switch 2 (PC1) is pressed
 132:led.c         **** uint8_t isSwitch2Pressed() {
 452               		.loc 3 132 0
 453               		.cfi_startproc
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 0 */
 457               	.L__stack_usage = 0
 133:led.c         ****     return !(PINC & (1 << PC1));
 458               		.loc 3 133 0
 459 0140 86B1      		in r24,0x6
 460 0142 8695      		lsr r24
 461 0144 8170      		andi r24,1
 134:led.c         **** }
 462               		.loc 3 134 0
 463 0146 91E0      		ldi r25,lo8(1)
 464 0148 8927      		eor r24,r25
 465 014a 0895      		ret
 466               		.cfi_endproc
 467               	.LFE20:
 469               	.global	isEncoderPressed
 471               	isEncoderPressed:
 472               	.LFB21:
 135:led.c         **** 
 136:led.c         **** // Function to check if rotary encoder switch is pressed
 137:led.c         **** uint8_t isEncoderPressed() {
 473               		.loc 3 137 0
 474               		.cfi_startproc
 475               	/* prologue: function */
 476               	/* frame size = 0 */
 477               	/* stack size = 0 */
 478               	.L__stack_usage = 0
 138:led.c         ****     return !(PINB & (1 << PB3));
 479               		.loc 3 138 0
 480 014c 83B1      		in r24,0x3
 481 014e 83FB      		bst r24,3
 482 0150 8827      		clr r24
 483 0152 80F9      		bld r24,0
 139:led.c         **** }
 484               		.loc 3 139 0
 485 0154 91E0      		ldi r25,lo8(1)
 486 0156 8927      		eor r24,r25
 487 0158 0895      		ret
 488               		.cfi_endproc
 489               	.LFE21:
 491               		.section	.rodata.str1.1,"aMS",@progbits,1
 492               	.LC1:
 493 0000 312E 2041 		.string	"1. Auto Mode"
 493      7574 6F20 
 493      4D6F 6465 
 493      00
 494               	.LC2:
 495 000d 322E 204D 		.string	"2. Manual Mode"
 495      616E 7561 
 495      6C20 4D6F 
 495      6465 00
 496               		.text
 497               	.global	displayModes
 499               	displayModes:
 500               	.LFB22:
 140:led.c         **** 
 141:led.c         **** // Function to display mode selection
 142:led.c         **** void displayModes() {
 501               		.loc 3 142 0
 502               		.cfi_startproc
 503               	/* prologue: function */
 504               	/* frame size = 0 */
 505               	/* stack size = 0 */
 506               	.L__stack_usage = 0
 143:led.c         ****     lcd_clear();
 507               		.loc 3 143 0
 508 015a 0E94 0000 		call lcd_clear
 509               	.LVL39:
 144:led.c         ****     lcd_setCursor(0, 0);  // Display "Welcome" in the middle
 510               		.loc 3 144 0
 511 015e 60E0      		ldi r22,0
 512 0160 80E0      		ldi r24,0
 513 0162 0E94 0000 		call lcd_setCursor
 514               	.LVL40:
 145:led.c         ****     lcd_print("1. Auto Mode");
 515               		.loc 3 145 0
 516 0166 80E0      		ldi r24,lo8(.LC1)
 517 0168 90E0      		ldi r25,hi8(.LC1)
 518 016a 0E94 0000 		call lcd_print
 519               	.LVL41:
 146:led.c         ****     lcd_setCursor(0, 1);
 520               		.loc 3 146 0
 521 016e 61E0      		ldi r22,lo8(1)
 522 0170 80E0      		ldi r24,0
 523 0172 0E94 0000 		call lcd_setCursor
 524               	.LVL42:
 147:led.c         ****     lcd_print("2. Manual Mode");
 525               		.loc 3 147 0
 526 0176 80E0      		ldi r24,lo8(.LC2)
 527 0178 90E0      		ldi r25,hi8(.LC2)
 528 017a 0C94 0000 		jmp lcd_print
 529               	.LVL43:
 530               		.cfi_endproc
 531               	.LFE22:
 533               		.section	.rodata.str1.1
 534               	.LC3:
 535 001c 5072 6F63 		.string	"Processing"
 535      6573 7369 
 535      6E67 00
 536               	.LC4:
 537 0027 4175 746F 		.string	"Auto Mode..."
 537      204D 6F64 
 537      652E 2E2E 
 537      00
 538               		.text
 539               	.global	displayProcessing
 541               	displayProcessing:
 542               	.LFB23:
 148:led.c         **** }
 149:led.c         **** 
 150:led.c         **** // Function to display "Processing.." message for 4 seconds
 151:led.c         **** void displayProcessing() {
 543               		.loc 3 151 0
 544               		.cfi_startproc
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               	/* stack size = 0 */
 548               	.L__stack_usage = 0
 152:led.c         ****     lcd_clear();
 549               		.loc 3 152 0
 550 017e 0E94 0000 		call lcd_clear
 551               	.LVL44:
 153:led.c         ****     lcd_setCursor(0, 0);
 552               		.loc 3 153 0
 553 0182 60E0      		ldi r22,0
 554 0184 80E0      		ldi r24,0
 555 0186 0E94 0000 		call lcd_setCursor
 556               	.LVL45:
 154:led.c         ****     lcd_print("Processing");
 557               		.loc 3 154 0
 558 018a 80E0      		ldi r24,lo8(.LC3)
 559 018c 90E0      		ldi r25,hi8(.LC3)
 560 018e 0E94 0000 		call lcd_print
 561               	.LVL46:
 155:led.c         ****     lcd_setCursor(0, 1);
 562               		.loc 3 155 0
 563 0192 61E0      		ldi r22,lo8(1)
 564 0194 80E0      		ldi r24,0
 565 0196 0E94 0000 		call lcd_setCursor
 566               	.LVL47:
 156:led.c         ****     lcd_print("Auto Mode...");
 567               		.loc 3 156 0
 568 019a 80E0      		ldi r24,lo8(.LC4)
 569 019c 90E0      		ldi r25,hi8(.LC4)
 570 019e 0C94 0000 		jmp lcd_print
 571               	.LVL48:
 572               		.cfi_endproc
 573               	.LFE23:
 575               		.section	.rodata.str1.1
 576               	.LC5:
 577 0034 5365 6C65 		.string	"Select the"
 577      6374 2074 
 577      6865 00
 578               	.LC6:
 579 003f 5065 7263 		.string	"Percentages.."
 579      656E 7461 
 579      6765 732E 
 579      2E00 
 580               		.text
 581               	.global	displayChoosePercentages
 583               	displayChoosePercentages:
 584               	.LFB24:
 157:led.c         **** }
 158:led.c         **** 
 159:led.c         **** // Function to display "Select the" and "Percentages.." message
 160:led.c         **** void displayChoosePercentages() {
 585               		.loc 3 160 0
 586               		.cfi_startproc
 587               	/* prologue: function */
 588               	/* frame size = 0 */
 589               	/* stack size = 0 */
 590               	.L__stack_usage = 0
 161:led.c         ****     lcd_clear();
 591               		.loc 3 161 0
 592 01a2 0E94 0000 		call lcd_clear
 593               	.LVL49:
 162:led.c         ****     lcd_setCursor(0, 0);
 594               		.loc 3 162 0
 595 01a6 60E0      		ldi r22,0
 596 01a8 80E0      		ldi r24,0
 597 01aa 0E94 0000 		call lcd_setCursor
 598               	.LVL50:
 163:led.c         ****     lcd_print("Select the");
 599               		.loc 3 163 0
 600 01ae 80E0      		ldi r24,lo8(.LC5)
 601 01b0 90E0      		ldi r25,hi8(.LC5)
 602 01b2 0E94 0000 		call lcd_print
 603               	.LVL51:
 164:led.c         ****     lcd_setCursor(0, 1);
 604               		.loc 3 164 0
 605 01b6 61E0      		ldi r22,lo8(1)
 606 01b8 80E0      		ldi r24,0
 607 01ba 0E94 0000 		call lcd_setCursor
 608               	.LVL52:
 165:led.c         ****     lcd_print("Percentages..");
 609               		.loc 3 165 0
 610 01be 80E0      		ldi r24,lo8(.LC6)
 611 01c0 90E0      		ldi r25,hi8(.LC6)
 612 01c2 0C94 0000 		jmp lcd_print
 613               	.LVL53:
 614               		.cfi_endproc
 615               	.LFE24:
 617               		.section	.rodata.str1.1
 618               	.LC7:
 619 004d 4578 6365 		.string	"Exceeded 100%"
 619      6564 6564 
 619      2031 3030 
 619      2500 
 620               	.LC8:
 621 005b 5365 6C65 		.string	"Select again"
 621      6374 2061 
 621      6761 696E 
 621      00
 622               		.text
 623               	.global	displayExceed100
 625               	displayExceed100:
 626               	.LFB25:
 166:led.c         **** }
 167:led.c         **** 
 168:led.c         **** // Function to display exceeded 100% message
 169:led.c         **** void displayExceed100() {
 627               		.loc 3 169 0
 628               		.cfi_startproc
 629               	/* prologue: function */
 630               	/* frame size = 0 */
 631               	/* stack size = 0 */
 632               	.L__stack_usage = 0
 170:led.c         ****     lcd_clear();
 633               		.loc 3 170 0
 634 01c6 0E94 0000 		call lcd_clear
 635               	.LVL54:
 171:led.c         ****     lcd_setCursor(0, 0);
 636               		.loc 3 171 0
 637 01ca 60E0      		ldi r22,0
 638 01cc 80E0      		ldi r24,0
 639 01ce 0E94 0000 		call lcd_setCursor
 640               	.LVL55:
 172:led.c         ****     lcd_print("Exceeded 100%");
 641               		.loc 3 172 0
 642 01d2 80E0      		ldi r24,lo8(.LC7)
 643 01d4 90E0      		ldi r25,hi8(.LC7)
 644 01d6 0E94 0000 		call lcd_print
 645               	.LVL56:
 173:led.c         ****     lcd_setCursor(0, 1);
 646               		.loc 3 173 0
 647 01da 61E0      		ldi r22,lo8(1)
 648 01dc 80E0      		ldi r24,0
 649 01de 0E94 0000 		call lcd_setCursor
 650               	.LVL57:
 174:led.c         ****     lcd_print("Select again");
 651               		.loc 3 174 0
 652 01e2 80E0      		ldi r24,lo8(.LC8)
 653 01e4 90E0      		ldi r25,hi8(.LC8)
 654 01e6 0E94 0000 		call lcd_print
 655               	.LVL58:
 656               	.LBB57:
 657               	.LBB58:
 187:/usr/lib/avr/include/util/delay.h **** 
 658               		.loc 2 187 0
 659 01ea 2FEF      		ldi r18,lo8(799999)
 660 01ec 84E3      		ldi r24,hi8(799999)
 661 01ee 9CE0      		ldi r25,hlo8(799999)
 662 01f0 2150      	1:	subi r18,1
 663 01f2 8040      		sbci r24,0
 664 01f4 9040      		sbci r25,0
 665 01f6 01F4      		brne 1b
 666 01f8 00C0      		rjmp .
 667 01fa 0000      		nop
 668               	.LVL59:
 669 01fc 0895      		ret
 670               	.LBE58:
 671               	.LBE57:
 672               		.cfi_endproc
 673               	.LFE25:
 675               		.section	.rodata.str1.1
 676               	.LC9:
 677 0068 2564 2525 		.string	"%d%%"
 677      00
 678               		.text
 679               	.global	displayFruit
 681               	displayFruit:
 682               	.LFB26:
 175:led.c         ****     _delay_ms(4000);
 176:led.c         **** }
 177:led.c         **** 
 178:led.c         **** // Function to display a fruit and its percentage
 179:led.c         **** void displayFruit(char *fruit, uint8_t percentage) {
 683               		.loc 3 179 0
 684               		.cfi_startproc
 685               	.LVL60:
 686 01fe EF92      		push r14
 687               	.LCFI11:
 688               		.cfi_def_cfa_offset 3
 689               		.cfi_offset 14, -2
 690 0200 FF92      		push r15
 691               	.LCFI12:
 692               		.cfi_def_cfa_offset 4
 693               		.cfi_offset 15, -3
 694 0202 0F93      		push r16
 695               	.LCFI13:
 696               		.cfi_def_cfa_offset 5
 697               		.cfi_offset 16, -4
 698 0204 1F93      		push r17
 699               	.LCFI14:
 700               		.cfi_def_cfa_offset 6
 701               		.cfi_offset 17, -5
 702 0206 CF93      		push r28
 703               	.LCFI15:
 704               		.cfi_def_cfa_offset 7
 705               		.cfi_offset 28, -6
 706 0208 DF93      		push r29
 707               	.LCFI16:
 708               		.cfi_def_cfa_offset 8
 709               		.cfi_offset 29, -7
 710 020a CDB7      		in r28,__SP_L__
 711 020c DEB7      		in r29,__SP_H__
 712               	.LCFI17:
 713               		.cfi_def_cfa_register 28
 714 020e 6097      		sbiw r28,16
 715               	.LCFI18:
 716               		.cfi_def_cfa_offset 24
 717 0210 0FB6      		in __tmp_reg__,__SREG__
 718 0212 F894      		cli
 719 0214 DEBF      		out __SP_H__,r29
 720 0216 0FBE      		out __SREG__,__tmp_reg__
 721 0218 CDBF      		out __SP_L__,r28
 722               	/* prologue: function */
 723               	/* frame size = 16 */
 724               	/* stack size = 22 */
 725               	.L__stack_usage = 22
 726 021a 7C01      		movw r14,r24
 727 021c 162F      		mov r17,r22
 180:led.c         ****     char buffer[16];
 181:led.c         ****     lcd_clear();
 728               		.loc 3 181 0
 729 021e 0E94 0000 		call lcd_clear
 730               	.LVL61:
 182:led.c         ****     lcd_setCursor(0, 0);
 731               		.loc 3 182 0
 732 0222 60E0      		ldi r22,0
 733 0224 80E0      		ldi r24,0
 734 0226 0E94 0000 		call lcd_setCursor
 735               	.LVL62:
 183:led.c         ****     lcd_print(fruit);
 736               		.loc 3 183 0
 737 022a C701      		movw r24,r14
 738 022c 0E94 0000 		call lcd_print
 739               	.LVL63:
 184:led.c         ****     lcd_setCursor(0, 1);
 740               		.loc 3 184 0
 741 0230 61E0      		ldi r22,lo8(1)
 742 0232 80E0      		ldi r24,0
 743 0234 0E94 0000 		call lcd_setCursor
 744               	.LVL64:
 185:led.c         ****     snprintf(buffer, sizeof(buffer), "%d%%", percentage);
 745               		.loc 3 185 0
 746 0238 1F92      		push __zero_reg__
 747 023a 1F93      		push r17
 748 023c 80E0      		ldi r24,lo8(.LC9)
 749 023e 90E0      		ldi r25,hi8(.LC9)
 750 0240 9F93      		push r25
 751 0242 8F93      		push r24
 752 0244 1F92      		push __zero_reg__
 753 0246 80E1      		ldi r24,lo8(16)
 754 0248 8F93      		push r24
 755 024a 8E01      		movw r16,r28
 756 024c 0F5F      		subi r16,-1
 757 024e 1F4F      		sbci r17,-1
 758 0250 1F93      		push r17
 759 0252 0F93      		push r16
 760 0254 0E94 0000 		call snprintf
 761               	.LVL65:
 186:led.c         ****     lcd_print(buffer);
 762               		.loc 3 186 0
 763 0258 C801      		movw r24,r16
 764 025a 0E94 0000 		call lcd_print
 765               	.LVL66:
 187:led.c         **** }
 766               		.loc 3 187 0
 767 025e 0FB6      		in __tmp_reg__,__SREG__
 768 0260 F894      		cli
 769 0262 DEBF      		out __SP_H__,r29
 770 0264 0FBE      		out __SREG__,__tmp_reg__
 771 0266 CDBF      		out __SP_L__,r28
 772               	/* epilogue start */
 773 0268 6096      		adiw r28,16
 774 026a 0FB6      		in __tmp_reg__,__SREG__
 775 026c F894      		cli
 776 026e DEBF      		out __SP_H__,r29
 777 0270 0FBE      		out __SREG__,__tmp_reg__
 778 0272 CDBF      		out __SP_L__,r28
 779 0274 DF91      		pop r29
 780 0276 CF91      		pop r28
 781 0278 1F91      		pop r17
 782               	.LVL67:
 783 027a 0F91      		pop r16
 784 027c FF90      		pop r15
 785 027e EF90      		pop r14
 786               	.LVL68:
 787 0280 0895      		ret
 788               		.cfi_endproc
 789               	.LFE26:
 791               		.section	.rodata.str1.1
 792               	.LC10:
 793 006d 596F 7572 		.string	"Your order is"
 793      206F 7264 
 793      6572 2069 
 793      7300 
 794               	.LC11:
 795 007b 6F6E 2074 		.string	"on the way"
 795      6865 2077 
 795      6179 00
 796               		.text
 797               	.global	displayOrderComplete
 799               	displayOrderComplete:
 800               	.LFB27:
 188:led.c         **** 
 189:led.c         **** // Function to display "Your order is" and "on the way"
 190:led.c         **** void displayOrderComplete() {
 801               		.loc 3 190 0
 802               		.cfi_startproc
 803               	/* prologue: function */
 804               	/* frame size = 0 */
 805               	/* stack size = 0 */
 806               	.L__stack_usage = 0
 191:led.c         ****     lcd_clear();
 807               		.loc 3 191 0
 808 0282 0E94 0000 		call lcd_clear
 809               	.LVL69:
 192:led.c         ****     lcd_setCursor(0, 0);
 810               		.loc 3 192 0
 811 0286 60E0      		ldi r22,0
 812 0288 80E0      		ldi r24,0
 813 028a 0E94 0000 		call lcd_setCursor
 814               	.LVL70:
 193:led.c         ****     lcd_print("Your order is");
 815               		.loc 3 193 0
 816 028e 80E0      		ldi r24,lo8(.LC10)
 817 0290 90E0      		ldi r25,hi8(.LC10)
 818 0292 0E94 0000 		call lcd_print
 819               	.LVL71:
 194:led.c         ****     lcd_setCursor(0, 1);
 820               		.loc 3 194 0
 821 0296 61E0      		ldi r22,lo8(1)
 822 0298 80E0      		ldi r24,0
 823 029a 0E94 0000 		call lcd_setCursor
 824               	.LVL72:
 195:led.c         ****     lcd_print("on the way");
 825               		.loc 3 195 0
 826 029e 80E0      		ldi r24,lo8(.LC11)
 827 02a0 90E0      		ldi r25,hi8(.LC11)
 828 02a2 0C94 0000 		jmp lcd_print
 829               	.LVL73:
 830               		.cfi_endproc
 831               	.LFE27:
 833               		.section	.rodata.str1.1
 834               	.LC12:
 835 0086 456E 6A6F 		.string	"Enjoy"
 835      7900 
 836               	.LC13:
 837 008c 596F 7572 		.string	"Your drink"
 837      2064 7269 
 837      6E6B 00
 838               		.text
 839               	.global	displayEnjoyDrink
 841               	displayEnjoyDrink:
 842               	.LFB28:
 196:led.c         **** }
 197:led.c         **** 
 198:led.c         **** // Function to display "Enjoy" and "Your drink"
 199:led.c         **** void displayEnjoyDrink() {
 843               		.loc 3 199 0
 844               		.cfi_startproc
 845               	/* prologue: function */
 846               	/* frame size = 0 */
 847               	/* stack size = 0 */
 848               	.L__stack_usage = 0
 200:led.c         ****     lcd_clear();
 849               		.loc 3 200 0
 850 02a6 0E94 0000 		call lcd_clear
 851               	.LVL74:
 201:led.c         ****     lcd_setCursor(0, 0);
 852               		.loc 3 201 0
 853 02aa 60E0      		ldi r22,0
 854 02ac 80E0      		ldi r24,0
 855 02ae 0E94 0000 		call lcd_setCursor
 856               	.LVL75:
 202:led.c         ****     lcd_print("Enjoy");
 857               		.loc 3 202 0
 858 02b2 80E0      		ldi r24,lo8(.LC12)
 859 02b4 90E0      		ldi r25,hi8(.LC12)
 860 02b6 0E94 0000 		call lcd_print
 861               	.LVL76:
 203:led.c         ****     lcd_setCursor(0, 1);
 862               		.loc 3 203 0
 863 02ba 61E0      		ldi r22,lo8(1)
 864 02bc 80E0      		ldi r24,0
 865 02be 0E94 0000 		call lcd_setCursor
 866               	.LVL77:
 204:led.c         ****     lcd_print("Your drink");
 867               		.loc 3 204 0
 868 02c2 80E0      		ldi r24,lo8(.LC13)
 869 02c4 90E0      		ldi r25,hi8(.LC13)
 870 02c6 0E94 0000 		call lcd_print
 871               	.LVL78:
 872               	.LBB59:
 873               	.LBB60:
 187:/usr/lib/avr/include/util/delay.h **** 
 874               		.loc 2 187 0
 875 02ca 2FEF      		ldi r18,lo8(799999)
 876 02cc 84E3      		ldi r24,hi8(799999)
 877 02ce 9CE0      		ldi r25,hlo8(799999)
 878 02d0 2150      	1:	subi r18,1
 879 02d2 8040      		sbci r24,0
 880 02d4 9040      		sbci r25,0
 881 02d6 01F4      		brne 1b
 882 02d8 00C0      		rjmp .
 883 02da 0000      		nop
 884               	.LVL79:
 885 02dc 0895      		ret
 886               	.LBE60:
 887               	.LBE59:
 888               		.cfi_endproc
 889               	.LFE28:
 891               	.global	readEncoder
 893               	readEncoder:
 894               	.LFB30:
 205:led.c         ****     _delay_ms(4000);
 206:led.c         **** }
 207:led.c         **** 
 208:led.c         **** // Function to check the total percentage
 209:led.c         **** void checkPercentageSum() {
 210:led.c         ****     uint8_t total = percentages[0] + percentages[1] + percentages[2] + percentages[3];
 211:led.c         ****     if (total > 100) {
 212:led.c         ****         displayExceed100();  // If total exceeds 100%, allow re-selection
 213:led.c         ****         fruitIndex = 0;  // Reset to the first fruit
 214:led.c         ****         percentage = 0;
 215:led.c         ****         displayFruit(fruits[fruitIndex], percentage);
 216:led.c         ****         selectingPercentage = 1;  // Re-enable encoder for selection
 217:led.c         ****     } else {
 218:led.c         ****         displayOrderComplete();  // If total is valid, display order message
 219:led.c         ****         for (uint8_t i = 0; i < 4; i++) {
 220:led.c         ****             turnOnMotor(i, percentages[i]);  // Turn on motors based on percentages
 221:led.c         ****         }
 222:led.c         **** 
 223:led.c         ****         displayEnjoyDrink();  // Display enjoyment message
 224:led.c         ****         fruitIndex = 0;  // Reset fruit index for new selection
 225:led.c         ****         percentages[0] = percentages[1] = percentages[2] = percentages[3] = 0;  // Reset percentage
 226:led.c         ****         displayModes();  // Return to mode selection
 227:led.c         ****     }
 228:led.c         **** }
 229:led.c         **** 
 230:led.c         **** // Function to read rotary encoder rotation
 231:led.c         **** int8_t readEncoder() {
 895               		.loc 3 231 0
 896               		.cfi_startproc
 897               	/* prologue: function */
 898               	/* frame size = 0 */
 899               	/* stack size = 0 */
 900               	.L__stack_usage = 0
 232:led.c         ****     static uint8_t lastStateCLK = 0;
 233:led.c         ****     uint8_t currentStateCLK = PINB & (1 << PB1);
 901               		.loc 3 233 0
 902 02de 83B1      		in r24,0x3
 903 02e0 8270      		andi r24,lo8(2)
 904               	.LVL80:
 234:led.c         **** 
 235:led.c         ****     if (currentStateCLK != lastStateCLK) {
 905               		.loc 3 235 0
 906 02e2 9091 0000 		lds r25,lastStateCLK.1848
 907 02e6 8917      		cp r24,r25
 908 02e8 01F0      		breq .L33
 236:led.c         ****         if (PINB & (1 << PB2)) {
 909               		.loc 3 236 0
 910 02ea 1A9B      		sbis 0x3,2
 911 02ec 00C0      		rjmp .L32
 237:led.c         ****             lastStateCLK = currentStateCLK;
 912               		.loc 3 237 0
 913 02ee 8093 0000 		sts lastStateCLK.1848,r24
 238:led.c         ****             return 1;  // Clockwise rotation
 914               		.loc 3 238 0
 915 02f2 81E0      		ldi r24,lo8(1)
 916               	.LVL81:
 917 02f4 0895      		ret
 918               	.LVL82:
 919               	.L32:
 239:led.c         ****         } else {
 240:led.c         ****             lastStateCLK = currentStateCLK;
 920               		.loc 3 240 0
 921 02f6 8093 0000 		sts lastStateCLK.1848,r24
 241:led.c         ****             return -1;  // Counterclockwise rotation
 922               		.loc 3 241 0
 923 02fa 8FEF      		ldi r24,lo8(-1)
 924               	.LVL83:
 925 02fc 0895      		ret
 926               	.LVL84:
 927               	.L33:
 242:led.c         ****         }
 243:led.c         ****     }
 244:led.c         ****     return 0;  // No rotation
 928               		.loc 3 244 0
 929 02fe 80E0      		ldi r24,0
 930               	.LVL85:
 245:led.c         **** }
 931               		.loc 3 245 0
 932 0300 0895      		ret
 933               		.cfi_endproc
 934               	.LFE30:
 936               	.global	turnOffMotors
 938               	turnOffMotors:
 939               	.LFB32:
 246:led.c         **** 
 247:led.c         **** // Function to turn on the specified motor based on percentage
 248:led.c         **** void turnOnMotor(uint8_t motor, uint8_t percentage) {
 249:led.c         ****     uint16_t delayTime = getDelayForPercentage(percentage);
 250:led.c         ****     PORTD &= ~(1 << motor);  // Turn on the motor
 251:led.c         **** 
 252:led.c         ****     // Use a loop for delay instead of _delay_ms directly
 253:led.c         ****     while (delayTime > 0) {
 254:led.c         ****         _delay_ms(1);  // Delay in 1 ms increments
 255:led.c         ****         delayTime--;  // Decrease delayTime
 256:led.c         ****     }
 257:led.c         **** 
 258:led.c         ****     PORTD |= (1 << motor);  // Turn off the motor after delay
 259:led.c         **** }
 260:led.c         **** 
 261:led.c         **** 
 262:led.c         **** // Function to turn off all motors
 263:led.c         **** void turnOffMotors() {
 940               		.loc 3 263 0
 941               		.cfi_startproc
 942               	/* prologue: function */
 943               	/* frame size = 0 */
 944               	/* stack size = 0 */
 945               	.L__stack_usage = 0
 264:led.c         ****     PORTD |= ((1 << PD0) | (1 << PD1) | (1 << PD2) | (1 << PD3));  // Turn off all motors
 946               		.loc 3 264 0
 947 0302 8BB1      		in r24,0xb
 948 0304 8F60      		ori r24,lo8(15)
 949 0306 8BB9      		out 0xb,r24
 950 0308 0895      		ret
 951               		.cfi_endproc
 952               	.LFE32:
 954               	.global	setup
 956               	setup:
 957               	.LFB18:
 109:led.c         ****     DDRC &= ~(1 << PC0);  // Set PC0 (Switch 1) as input
 958               		.loc 3 109 0
 959               		.cfi_startproc
 960               	/* prologue: function */
 961               	/* frame size = 0 */
 962               	/* stack size = 0 */
 963               	.L__stack_usage = 0
 110:led.c         ****     PORTC |= (1 << PC0);  // Enable pull-up resistor on PC0
 964               		.loc 3 110 0
 965 030a 3898      		cbi 0x7,0
 111:led.c         **** 
 966               		.loc 3 111 0
 967 030c 409A      		sbi 0x8,0
 113:led.c         ****     PORTC |= (1 << PC1);  // Enable pull-up resistor on PC1
 968               		.loc 3 113 0
 969 030e 3998      		cbi 0x7,1
 114:led.c         **** 
 970               		.loc 3 114 0
 971 0310 419A      		sbi 0x8,1
 116:led.c         ****     DDRB &= ~(1 << PB2);  // Set PB2 (DT) as input
 972               		.loc 3 116 0
 973 0312 2198      		cbi 0x4,1
 117:led.c         ****     DDRB &= ~(1 << PB3);  // Set PB3 (SW) as input
 974               		.loc 3 117 0
 975 0314 2298      		cbi 0x4,2
 118:led.c         ****     PORTB |= (1 << PB1) | (1 << PB2) | (1 << PB3);  // Enable pull-up resistors for encoder
 976               		.loc 3 118 0
 977 0316 2398      		cbi 0x4,3
 119:led.c         **** 
 978               		.loc 3 119 0
 979 0318 85B1      		in r24,0x5
 980 031a 8E60      		ori r24,lo8(14)
 981 031c 85B9      		out 0x5,r24
 122:led.c         ****     turnOffMotors();  // Ensure motors are off initially
 982               		.loc 3 122 0
 983 031e 8AB1      		in r24,0xa
 984 0320 8F60      		ori r24,lo8(15)
 985 0322 8AB9      		out 0xa,r24
 123:led.c         **** }
 986               		.loc 3 123 0
 987 0324 0C94 0000 		jmp turnOffMotors
 988               	.LVL86:
 989               		.cfi_endproc
 990               	.LFE18:
 992               	.global	getDelayForPercentage
 994               	getDelayForPercentage:
 995               	.LFB33:
 265:led.c         **** }
 266:led.c         **** 
 267:led.c         **** // Function to get delay for the corresponding percentage
 268:led.c         **** uint16_t getDelayForPercentage(uint8_t percentage) {
 996               		.loc 3 268 0
 997               		.cfi_startproc
 998               	.LVL87:
 999               	/* prologue: function */
 1000               	/* frame size = 0 */
 1001               	/* stack size = 0 */
 1002               	.L__stack_usage = 0
 269:led.c         ****     switch (percentage) {
 1003               		.loc 3 269 0
 1004 0328 8C33      		cpi r24,lo8(60)
 1005 032a 01F0      		breq .L38
 1006 032c 00F4      		brsh .L39
 1007 032e 8431      		cpi r24,lo8(20)
 1008 0330 01F0      		breq .L40
 1009 0332 8832      		cpi r24,lo8(40)
 1010 0334 01F4      		brne .L44
 270:led.c         ****         case 0: return 0;          // 0%
 271:led.c         ****         case 20: return 2180;      // 2.18 seconds
 272:led.c         ****         case 40: return 4110;      // 4.11 seconds
 1011               		.loc 3 272 0
 1012 0336 8EE0      		ldi r24,lo8(14)
 1013 0338 90E1      		ldi r25,lo8(16)
 1014               	.LVL88:
 1015 033a 0895      		ret
 1016               	.LVL89:
 1017               	.L39:
 269:led.c         ****     switch (percentage) {
 1018               		.loc 3 269 0
 1019 033c 8035      		cpi r24,lo8(80)
 1020 033e 01F0      		breq .L42
 1021 0340 8436      		cpi r24,lo8(100)
 1022 0342 01F4      		brne .L44
 273:led.c         ****         case 60: return 5730;      // 5.73 seconds
 274:led.c         ****         case 80: return 6970;      // 6.97 seconds
 275:led.c         ****         case 100: return 8110;     // 8.11 seconds
 1023               		.loc 3 275 0
 1024 0344 8EEA      		ldi r24,lo8(-82)
 1025 0346 9FE1      		ldi r25,lo8(31)
 1026               	.LVL90:
 1027 0348 0895      		ret
 1028               	.LVL91:
 1029               	.L40:
 271:led.c         ****         case 40: return 4110;      // 4.11 seconds
 1030               		.loc 3 271 0
 1031 034a 84E8      		ldi r24,lo8(-124)
 1032 034c 98E0      		ldi r25,lo8(8)
 1033               	.LVL92:
 1034 034e 0895      		ret
 1035               	.LVL93:
 1036               	.L38:
 273:led.c         ****         case 60: return 5730;      // 5.73 seconds
 1037               		.loc 3 273 0
 1038 0350 82E6      		ldi r24,lo8(98)
 1039 0352 96E1      		ldi r25,lo8(22)
 1040               	.LVL94:
 1041 0354 0895      		ret
 1042               	.LVL95:
 1043               	.L42:
 274:led.c         ****         case 100: return 8110;     // 8.11 seconds
 1044               		.loc 3 274 0
 1045 0356 8AE3      		ldi r24,lo8(58)
 1046 0358 9BE1      		ldi r25,lo8(27)
 1047               	.LVL96:
 1048 035a 0895      		ret
 1049               	.LVL97:
 1050               	.L44:
 270:led.c         ****         case 20: return 2180;      // 2.18 seconds
 1051               		.loc 3 270 0
 1052 035c 80E0      		ldi r24,0
 1053 035e 90E0      		ldi r25,0
 1054               	.LVL98:
 276:led.c         ****         default: return 0;         // Invalid percentage
 277:led.c         ****     }
 278:led.c         **** }
 1055               		.loc 3 278 0
 1056 0360 0895      		ret
 1057               		.cfi_endproc
 1058               	.LFE33:
 1060               	.global	turnOnMotor
 1062               	turnOnMotor:
 1063               	.LFB31:
 248:led.c         ****     uint16_t delayTime = getDelayForPercentage(percentage);
 1064               		.loc 3 248 0
 1065               		.cfi_startproc
 1066               	.LVL99:
 1067 0362 CF93      		push r28
 1068               	.LCFI19:
 1069               		.cfi_def_cfa_offset 3
 1070               		.cfi_offset 28, -2
 1071               	/* prologue: function */
 1072               	/* frame size = 0 */
 1073               	/* stack size = 1 */
 1074               	.L__stack_usage = 1
 1075 0364 C82F      		mov r28,r24
 1076 0366 862F      		mov r24,r22
 1077               	.LVL100:
 249:led.c         ****     PORTD &= ~(1 << motor);  // Turn on the motor
 1078               		.loc 3 249 0
 1079 0368 0E94 0000 		call getDelayForPercentage
 1080               	.LVL101:
 250:led.c         **** 
 1081               		.loc 3 250 0
 1082 036c 4BB1      		in r20,0xb
 1083 036e 21E0      		ldi r18,lo8(1)
 1084 0370 30E0      		ldi r19,0
 1085 0372 00C0      		rjmp 2f
 1086               		1:
 1087 0374 220F      		lsl r18
 1088               		2:
 1089 0376 CA95      		dec r28
 1090 0378 02F4      		brpl 1b
 1091 037a 522F      		mov r21,r18
 1092 037c 5095      		com r21
 1093 037e 4523      		and r20,r21
 1094 0380 4BB9      		out 0xb,r20
 1095               	.L46:
 253:led.c         ****         _delay_ms(1);  // Delay in 1 ms increments
 1096               		.loc 3 253 0
 1097 0382 0097      		sbiw r24,0
 1098 0384 01F0      		breq .L48
 1099               	.LVL102:
 1100               	.LBB61:
 1101               	.LBB62:
 187:/usr/lib/avr/include/util/delay.h **** 
 1102               		.loc 2 187 0
 1103 0386 E9EF      		ldi r30,lo8(249)
 1104 0388 F0E0      		ldi r31,hi8(249)
 1105 038a 3197      	1:	sbiw r30,1
 1106 038c 01F4      		brne 1b
 1107 038e 00C0      		rjmp .
 1108 0390 0000      		nop
 1109               	.LVL103:
 1110               	.LBE62:
 1111               	.LBE61:
 255:led.c         ****     }
 1112               		.loc 3 255 0
 1113 0392 0197      		sbiw r24,1
 1114               	.LVL104:
 1115 0394 00C0      		rjmp .L46
 1116               	.L48:
 258:led.c         **** }
 1117               		.loc 3 258 0
 1118 0396 8BB1      		in r24,0xb
 1119               	.LVL105:
 1120 0398 282B      		or r18,r24
 1121 039a 2BB9      		out 0xb,r18
 1122               	/* epilogue start */
 259:led.c         **** 
 1123               		.loc 3 259 0
 1124 039c CF91      		pop r28
 1125               	.LVL106:
 1126 039e 0895      		ret
 1127               		.cfi_endproc
 1128               	.LFE31:
 1130               	.global	checkPercentageSum
 1132               	checkPercentageSum:
 1133               	.LFB29:
 209:led.c         ****     uint8_t total = percentages[0] + percentages[1] + percentages[2] + percentages[3];
 1134               		.loc 3 209 0
 1135               		.cfi_startproc
 1136 03a0 0F93      		push r16
 1137               	.LCFI20:
 1138               		.cfi_def_cfa_offset 3
 1139               		.cfi_offset 16, -2
 1140 03a2 1F93      		push r17
 1141               	.LCFI21:
 1142               		.cfi_def_cfa_offset 4
 1143               		.cfi_offset 17, -3
 1144 03a4 CF93      		push r28
 1145               	.LCFI22:
 1146               		.cfi_def_cfa_offset 5
 1147               		.cfi_offset 28, -4
 1148               	/* prologue: function */
 1149               	/* frame size = 0 */
 1150               	/* stack size = 3 */
 1151               	.L__stack_usage = 3
 1152               	.LVL107:
 211:led.c         ****         displayExceed100();  // If total exceeds 100%, allow re-selection
 1153               		.loc 3 211 0
 1154 03a6 9091 0000 		lds r25,percentages
 1155 03aa 8091 0000 		lds r24,percentages+1
 1156 03ae 890F      		add r24,r25
 1157 03b0 9091 0000 		lds r25,percentages+2
 1158 03b4 890F      		add r24,r25
 1159 03b6 9091 0000 		lds r25,percentages+3
 1160 03ba 890F      		add r24,r25
 1161 03bc 8536      		cpi r24,lo8(101)
 1162 03be 00F0      		brlo .L50
 1163               	.LBB67:
 1164               	.LBB68:
 212:led.c         ****         fruitIndex = 0;  // Reset to the first fruit
 1165               		.loc 3 212 0
 1166 03c0 0E94 0000 		call displayExceed100
 1167               	.LVL108:
 213:led.c         ****         percentage = 0;
 1168               		.loc 3 213 0
 1169 03c4 1092 0000 		sts fruitIndex,__zero_reg__
 214:led.c         ****         displayFruit(fruits[fruitIndex], percentage);
 1170               		.loc 3 214 0
 1171 03c8 1092 0000 		sts percentage,__zero_reg__
 215:led.c         ****         selectingPercentage = 1;  // Re-enable encoder for selection
 1172               		.loc 3 215 0
 1173 03cc 60E0      		ldi r22,0
 1174 03ce 8091 0000 		lds r24,fruits
 1175 03d2 9091 0000 		lds r25,fruits+1
 1176 03d6 0E94 0000 		call displayFruit
 1177               	.LVL109:
 216:led.c         ****     } else {
 1178               		.loc 3 216 0
 1179 03da 81E0      		ldi r24,lo8(1)
 1180 03dc 8093 0000 		sts selectingPercentage,r24
 1181               	/* epilogue start */
 1182               	.LBE68:
 1183               	.LBE67:
 228:led.c         **** 
 1184               		.loc 3 228 0
 1185 03e0 CF91      		pop r28
 1186 03e2 1F91      		pop r17
 1187 03e4 0F91      		pop r16
 1188 03e6 0895      		ret
 1189               	.LVL110:
 1190               	.L50:
 218:led.c         ****         for (uint8_t i = 0; i < 4; i++) {
 1191               		.loc 3 218 0
 1192 03e8 0E94 0000 		call displayOrderComplete
 1193               	.LVL111:
 1194 03ec 00E0      		ldi r16,lo8(percentages)
 1195 03ee 10E0      		ldi r17,hi8(percentages)
 1196               	.LBB69:
 219:led.c         ****             turnOnMotor(i, percentages[i]);  // Turn on motors based on percentages
 1197               		.loc 3 219 0
 1198 03f0 C0E0      		ldi r28,0
 1199               	.LVL112:
 1200               	.L52:
 220:led.c         ****         }
 1201               		.loc 3 220 0 discriminator 3
 1202 03f2 F801      		movw r30,r16
 1203 03f4 6191      		ld r22,Z+
 1204 03f6 8F01      		movw r16,r30
 1205 03f8 8C2F      		mov r24,r28
 1206 03fa 0E94 0000 		call turnOnMotor
 1207               	.LVL113:
 219:led.c         ****             turnOnMotor(i, percentages[i]);  // Turn on motors based on percentages
 1208               		.loc 3 219 0 discriminator 3
 1209 03fe CF5F      		subi r28,lo8(-(1))
 1210               	.LVL114:
 1211 0400 C430      		cpi r28,lo8(4)
 1212 0402 01F4      		brne .L52
 1213               	.LBE69:
 223:led.c         ****         fruitIndex = 0;  // Reset fruit index for new selection
 1214               		.loc 3 223 0
 1215 0404 0E94 0000 		call displayEnjoyDrink
 1216               	.LVL115:
 224:led.c         ****         percentages[0] = percentages[1] = percentages[2] = percentages[3] = 0;  // Reset percentage
 1217               		.loc 3 224 0
 1218 0408 1092 0000 		sts fruitIndex,__zero_reg__
 225:led.c         ****         displayModes();  // Return to mode selection
 1219               		.loc 3 225 0
 1220 040c 1092 0000 		sts percentages+3,__zero_reg__
 1221 0410 1092 0000 		sts percentages+2,__zero_reg__
 1222 0414 1092 0000 		sts percentages+1,__zero_reg__
 1223 0418 1092 0000 		sts percentages,__zero_reg__
 1224               	/* epilogue start */
 228:led.c         **** 
 1225               		.loc 3 228 0
 1226 041c CF91      		pop r28
 1227               	.LVL116:
 1228 041e 1F91      		pop r17
 1229 0420 0F91      		pop r16
 226:led.c         ****     }
 1230               		.loc 3 226 0
 1231 0422 0C94 0000 		jmp displayModes
 1232               	.LVL117:
 1233               		.cfi_endproc
 1234               	.LFE29:
 1236               		.section	.rodata.str1.1
 1237               	.LC14:
 1238 0097 4D61 6E75 		.string	"Manual Mode..."
 1238      616C 204D 
 1238      6F64 652E 
 1238      2E2E 00
 1239               	.LC15:
 1240 00a6 5365 6C65 		.string	"Select only"
 1240      6374 206F 
 1240      6E6C 7900 
 1241               	.LC16:
 1242 00b2 4F6E 6520 		.string	"One Fruit!"
 1242      4672 7569 
 1242      7421 00
 1243               		.text
 1244               	.global	manualMode
 1246               	manualMode:
 1247               	.LFB34:
 279:led.c         **** 
 280:led.c         **** // Function for Manual Mode
 281:led.c         **** void manualMode() {
 1248               		.loc 3 281 0
 1249               		.cfi_startproc
 1250 0426 CF93      		push r28
 1251               	.LCFI23:
 1252               		.cfi_def_cfa_offset 3
 1253               		.cfi_offset 28, -2
 1254               	/* prologue: function */
 1255               	/* frame size = 0 */
 1256               	/* stack size = 1 */
 1257               	.L__stack_usage = 1
 282:led.c         ****     lcd_clear();
 1258               		.loc 3 282 0
 1259 0428 0E94 0000 		call lcd_clear
 1260               	.LVL118:
 283:led.c         ****     lcd_setCursor(0, 0);
 1261               		.loc 3 283 0
 1262 042c 60E0      		ldi r22,0
 1263 042e 80E0      		ldi r24,0
 1264 0430 0E94 0000 		call lcd_setCursor
 1265               	.LVL119:
 284:led.c         ****     lcd_print("Processing");
 1266               		.loc 3 284 0
 1267 0434 80E0      		ldi r24,lo8(.LC3)
 1268 0436 90E0      		ldi r25,hi8(.LC3)
 1269 0438 0E94 0000 		call lcd_print
 1270               	.LVL120:
 285:led.c         ****     lcd_setCursor(0,1);
 1271               		.loc 3 285 0
 1272 043c 61E0      		ldi r22,lo8(1)
 1273 043e 80E0      		ldi r24,0
 1274 0440 0E94 0000 		call lcd_setCursor
 1275               	.LVL121:
 286:led.c         ****     lcd_print("Manual Mode...");
 1276               		.loc 3 286 0
 1277 0444 80E0      		ldi r24,lo8(.LC14)
 1278 0446 90E0      		ldi r25,hi8(.LC14)
 1279 0448 0E94 0000 		call lcd_print
 1280               	.LVL122:
 1281               	.LBB70:
 1282               	.LBB71:
 187:/usr/lib/avr/include/util/delay.h **** 
 1283               		.loc 2 187 0
 1284 044c 2FEF      		ldi r18,lo8(799999)
 1285 044e 84E3      		ldi r24,hi8(799999)
 1286 0450 9CE0      		ldi r25,hlo8(799999)
 1287 0452 2150      	1:	subi r18,1
 1288 0454 8040      		sbci r24,0
 1289 0456 9040      		sbci r25,0
 1290 0458 01F4      		brne 1b
 1291 045a 00C0      		rjmp .
 1292 045c 0000      		nop
 1293               	.LVL123:
 1294               	.LBE71:
 1295               	.LBE70:
 287:led.c         ****     _delay_ms(4000);
 288:led.c         **** 
 289:led.c         ****     lcd_clear();
 1296               		.loc 3 289 0
 1297 045e 0E94 0000 		call lcd_clear
 1298               	.LVL124:
 290:led.c         ****     lcd_setCursor(0, 0);
 1299               		.loc 3 290 0
 1300 0462 60E0      		ldi r22,0
 1301 0464 80E0      		ldi r24,0
 1302 0466 0E94 0000 		call lcd_setCursor
 1303               	.LVL125:
 291:led.c         ****     lcd_print("Select only");
 1304               		.loc 3 291 0
 1305 046a 80E0      		ldi r24,lo8(.LC15)
 1306 046c 90E0      		ldi r25,hi8(.LC15)
 1307 046e 0E94 0000 		call lcd_print
 1308               	.LVL126:
 292:led.c         ****     lcd_setCursor(0,1);
 1309               		.loc 3 292 0
 1310 0472 61E0      		ldi r22,lo8(1)
 1311 0474 80E0      		ldi r24,0
 1312 0476 0E94 0000 		call lcd_setCursor
 1313               	.LVL127:
 293:led.c         ****     lcd_print("One Fruit!");
 1314               		.loc 3 293 0
 1315 047a 80E0      		ldi r24,lo8(.LC16)
 1316 047c 90E0      		ldi r25,hi8(.LC16)
 1317 047e 0E94 0000 		call lcd_print
 1318               	.LVL128:
 1319               	.LBB72:
 1320               	.LBB73:
 187:/usr/lib/avr/include/util/delay.h **** 
 1321               		.loc 2 187 0
 1322 0482 2FEF      		ldi r18,lo8(799999)
 1323 0484 84E3      		ldi r24,hi8(799999)
 1324 0486 9CE0      		ldi r25,hlo8(799999)
 1325 0488 2150      	1:	subi r18,1
 1326 048a 8040      		sbci r24,0
 1327 048c 9040      		sbci r25,0
 1328 048e 01F4      		brne 1b
 1329 0490 00C0      		rjmp .
 1330 0492 0000      		nop
 1331               	.LVL129:
 1332               	.LBE73:
 1333               	.LBE72:
 294:led.c         ****     _delay_ms(4000);
 295:led.c         ****     
 296:led.c         ****     uint8_t selectedFruitIndex = 0; // Index for the currently selected fruit
 1334               		.loc 3 296 0
 1335 0494 C0E0      		ldi r28,0
 1336               	.LVL130:
 1337               	.L61:
 1338               	.LBB74:
 297:led.c         ****     uint8_t fruitSelected = 0;       // Flag to check if a fruit is selected
 298:led.c         **** 
 299:led.c         ****     // Main loop for manual mode
 300:led.c         ****     while (1) {
 301:led.c         ****         // Display the currently selected fruit
 302:led.c         ****         displayFruit(fruits[selectedFruitIndex], percentages[selectedFruitIndex]);
 1339               		.loc 3 302 0
 1340 0496 8C2F      		mov r24,r28
 1341 0498 90E0      		ldi r25,0
 1342 049a DC01      		movw r26,r24
 1343 049c A050      		subi r26,lo8(-(percentages))
 1344 049e B040      		sbci r27,hi8(-(percentages))
 1345 04a0 880F      		lsl r24
 1346 04a2 991F      		rol r25
 1347 04a4 FC01      		movw r30,r24
 1348 04a6 E050      		subi r30,lo8(-(fruits))
 1349 04a8 F040      		sbci r31,hi8(-(fruits))
 1350 04aa 6C91      		ld r22,X
 1351 04ac 8081      		ld r24,Z
 1352 04ae 9181      		ldd r25,Z+1
 1353 04b0 0E94 0000 		call displayFruit
 1354               	.LVL131:
 303:led.c         ****         
 304:led.c         ****         // Read the rotary encoder to switch between fruits
 305:led.c         ****         int8_t rotation = readEncoder();
 1355               		.loc 3 305 0
 1356 04b4 0E94 0000 		call readEncoder
 1357               	.LVL132:
 306:led.c         ****         if (rotation > 0) {
 1358               		.loc 3 306 0
 1359 04b8 1816      		cp __zero_reg__,r24
 1360 04ba 04F4      		brge .L56
 307:led.c         ****             // Rotate clockwise to select the next fruit
 308:led.c         ****             selectedFruitIndex++;
 1361               		.loc 3 308 0
 1362 04bc CF5F      		subi r28,lo8(-(1))
 1363               	.LVL133:
 309:led.c         ****             if (selectedFruitIndex >= 4) {
 1364               		.loc 3 309 0
 1365 04be C430      		cpi r28,lo8(4)
 1366 04c0 01F4      		brne .L59
 310:led.c         ****                 selectedFruitIndex = 0; // Wrap around
 1367               		.loc 3 310 0
 1368 04c2 C0E0      		ldi r28,0
 1369               	.LVL134:
 1370 04c4 00C0      		rjmp .L59
 1371               	.LVL135:
 1372               	.L56:
 311:led.c         ****             }
 312:led.c         ****             _delay_ms(200); // Debounce delay
 313:led.c         ****         } else if (rotation < 0) {
 1373               		.loc 3 313 0
 1374 04c6 8823      		tst r24
 1375 04c8 01F0      		breq .L58
 314:led.c         ****             // Rotate counterclockwise to select the previous fruit
 315:led.c         ****             if (selectedFruitIndex == 0) {
 1376               		.loc 3 315 0
 1377 04ca CC23      		tst r28
 1378 04cc 01F0      		breq .L62
 316:led.c         ****                 selectedFruitIndex = 3; // Wrap around
 317:led.c         ****             } else {
 318:led.c         ****                 selectedFruitIndex--;
 1379               		.loc 3 318 0
 1380 04ce C150      		subi r28,lo8(-(-1))
 1381               	.LVL136:
 1382 04d0 00C0      		rjmp .L59
 1383               	.L62:
 316:led.c         ****                 selectedFruitIndex = 3; // Wrap around
 1384               		.loc 3 316 0
 1385 04d2 C3E0      		ldi r28,lo8(3)
 1386               	.LVL137:
 1387               	.L59:
 1388               	.LBB75:
 1389               	.LBB76:
 187:/usr/lib/avr/include/util/delay.h **** 
 1390               		.loc 2 187 0
 1391 04d4 8FE4      		ldi r24,lo8(-15537)
 1392 04d6 93EC      		ldi r25,hi8(-15537)
 1393 04d8 0197      	1:	sbiw r24,1
 1394 04da 01F4      		brne 1b
 1395               	.LVL138:
 1396 04dc 00C0      		rjmp .
 1397 04de 0000      		nop
 1398               	.LVL139:
 1399               	.L58:
 1400               	.LBE76:
 1401               	.LBE75:
 319:led.c         ****             }
 320:led.c         ****             _delay_ms(200); // Debounce delay
 321:led.c         ****         }
 322:led.c         **** 
 323:led.c         ****         // Check if the rotary encoder switch is pressed to confirm selection
 324:led.c         ****         if (isEncoderPressed()) {
 1402               		.loc 3 324 0
 1403 04e0 0E94 0000 		call isEncoderPressed
 1404               	.LVL140:
 1405 04e4 8823      		tst r24
 1406 04e6 01F0      		breq .L60
 1407               	.LVL141:
 1408               	.LBB77:
 1409               	.LBB78:
 187:/usr/lib/avr/include/util/delay.h **** 
 1410               		.loc 2 187 0
 1411 04e8 83ED      		ldi r24,lo8(12499)
 1412 04ea 90E3      		ldi r25,hi8(12499)
 1413 04ec 0197      	1:	sbiw r24,1
 1414 04ee 01F4      		brne 1b
 1415 04f0 00C0      		rjmp .
 1416 04f2 0000      		nop
 1417               	.LVL142:
 1418               	.LBE78:
 1419               	.LBE77:
 325:led.c         ****             _delay_ms(50); // Debounce delay
 326:led.c         ****             if (isEncoderPressed()) { // Confirm switch press after delay
 1420               		.loc 3 326 0
 1421 04f4 0E94 0000 		call isEncoderPressed
 1422               	.LVL143:
 1423 04f8 8823      		tst r24
 1424 04fa 01F0      		breq .L60
 327:led.c         ****                 // Activate the selected fruit
 328:led.c         ****                 percentages[selectedFruitIndex] = 100; // Example: Set percentage to 100%
 1425               		.loc 3 328 0
 1426 04fc EC2F      		mov r30,r28
 1427 04fe F0E0      		ldi r31,0
 1428 0500 E050      		subi r30,lo8(-(percentages))
 1429 0502 F040      		sbci r31,hi8(-(percentages))
 1430 0504 84E6      		ldi r24,lo8(100)
 1431 0506 8083      		st Z,r24
 329:led.c         ****                 turnOnMotor(selectedFruitIndex, percentages[selectedFruitIndex]); // Turn on the se
 1432               		.loc 3 329 0
 1433 0508 64E6      		ldi r22,lo8(100)
 1434 050a 8C2F      		mov r24,r28
 1435 050c 0E94 0000 		call turnOnMotor
 1436               	.LVL144:
 1437               	.LBE74:
 330:led.c         ****                 fruitSelected = 1; // Set flag to indicate fruit is selected
 331:led.c         ****                 break; // Exit manual mode loop
 332:led.c         ****             }
 333:led.c         ****         }
 334:led.c         **** 
 335:led.c         ****         _delay_ms(50); // Small delay for debouncing
 336:led.c         ****     }
 337:led.c         **** 
 338:led.c         ****     // After fruit selection
 339:led.c         ****     if (fruitSelected) {
 340:led.c         ****         displayOrderComplete();  // Display order message
 1438               		.loc 3 340 0
 1439 0510 0E94 0000 		call displayOrderComplete
 1440               	.LVL145:
 341:led.c         ****         displayEnjoyDrink();      // Display enjoy message
 1441               		.loc 3 341 0
 1442 0514 0E94 0000 		call displayEnjoyDrink
 1443               	.LVL146:
 342:led.c         ****     }
 343:led.c         ****     
 344:led.c         ****     // Return to mode selection or reset for another manual selection
 345:led.c         ****     fruitIndex = 0;  // Reset fruit index for new selection
 1444               		.loc 3 345 0
 1445 0518 1092 0000 		sts fruitIndex,__zero_reg__
 346:led.c         ****     percentages[0] = percentages[1] = percentages[2] = percentages[3] = 0;  // Reset percentages
 1446               		.loc 3 346 0
 1447 051c 1092 0000 		sts percentages+3,__zero_reg__
 1448 0520 1092 0000 		sts percentages+2,__zero_reg__
 1449 0524 1092 0000 		sts percentages+1,__zero_reg__
 1450 0528 1092 0000 		sts percentages,__zero_reg__
 1451               	/* epilogue start */
 347:led.c         ****     displayModes();  // Return to mode selection
 348:led.c         **** }
 1452               		.loc 3 348 0
 1453 052c CF91      		pop r28
 1454               	.LVL147:
 347:led.c         ****     displayModes();  // Return to mode selection
 1455               		.loc 3 347 0
 1456 052e 0C94 0000 		jmp displayModes
 1457               	.LVL148:
 1458               	.L60:
 1459               	.LBB81:
 1460               	.LBB79:
 1461               	.LBB80:
 187:/usr/lib/avr/include/util/delay.h **** 
 1462               		.loc 2 187 0
 1463 0532 83ED      		ldi r24,lo8(12499)
 1464 0534 90E3      		ldi r25,hi8(12499)
 1465 0536 0197      	1:	sbiw r24,1
 1466 0538 01F4      		brne 1b
 1467 053a 00C0      		rjmp .
 1468 053c 0000      		nop
 1469 053e 00C0      		rjmp .L61
 1470               	.LBE80:
 1471               	.LBE79:
 1472               	.LBE81:
 1473               		.cfi_endproc
 1474               	.LFE34:
 1476               		.section	.rodata.str1.1
 1477               	.LC17:
 1478 00bd 546F 7461 		.string	"Total should not"
 1478      6C20 7368 
 1478      6F75 6C64 
 1478      206E 6F74 
 1478      00
 1479               	.LC18:
 1480 00ce 6578 6365 		.string	"exceed 100%"
 1480      6564 2031 
 1480      3030 2500 
 1481               		.section	.text.startup,"ax",@progbits
 1482               	.global	main
 1484               	main:
 1485               	.LFB17:
  33:led.c         ****     setup();  // Initialize pins
 1486               		.loc 3 33 0
 1487               		.cfi_startproc
 1488               	/* prologue: function */
 1489               	/* frame size = 0 */
 1490               	/* stack size = 0 */
 1491               	.L__stack_usage = 0
  34:led.c         ****     initialize();  // Initialize LCD
 1492               		.loc 3 34 0
 1493 0000 0E94 0000 		call setup
 1494               	.LVL149:
  35:led.c         **** 
 1495               		.loc 3 35 0
 1496 0004 0E94 0000 		call initialize
 1497               	.LVL150:
  45:led.c         ****                 manualMode();        // Go to Manual Mode
 1498               		.loc 3 45 0
 1499 0008 C1E0      		ldi r28,lo8(1)
 1500               	.L81:
  38:led.c         **** 
 1501               		.loc 3 38 0
 1502 000a 0E94 0000 		call displayModes
 1503               	.LVL151:
 1504               	.L74:
  41:led.c         ****             // Check if Switch 2 (PC1) is pressed for Manual Mode
 1505               		.loc 3 41 0
 1506 000e 0E94 0000 		call isSwitch1Pressed
 1507               	.LVL152:
 1508 0012 8111      		cpse r24,__zero_reg__
 1509 0014 00C0      		rjmp .L101
  43:led.c         ****                 // Disable Switches for Manual Mode
 1510               		.loc 3 43 0
 1511 0016 0E94 0000 		call isSwitch2Pressed
 1512               	.LVL153:
 1513 001a 8823      		tst r24
 1514 001c 01F0      		breq .L74
  45:led.c         ****                 manualMode();        // Go to Manual Mode
 1515               		.loc 3 45 0
 1516 001e C093 0000 		sts switch1Pressed,r28
  46:led.c         ****             }
 1517               		.loc 3 46 0
 1518 0022 0E94 0000 		call manualMode
 1519               	.LVL154:
 1520 0026 00C0      		rjmp .L74
 1521               	.L101:
  51:led.c         **** 
 1522               		.loc 3 51 0
 1523 0028 C093 0000 		sts switch1Pressed,r28
  54:led.c         ****         _delay_ms(4000);
 1524               		.loc 3 54 0
 1525 002c 0E94 0000 		call displayProcessing
 1526               	.LVL155:
 1527               	.LBB82:
 1528               	.LBB83:
 187:/usr/lib/avr/include/util/delay.h **** 
 1529               		.loc 2 187 0
 1530 0030 2FEF      		ldi r18,lo8(799999)
 1531 0032 84E3      		ldi r24,hi8(799999)
 1532 0034 9CE0      		ldi r25,hlo8(799999)
 1533 0036 2150      	1:	subi r18,1
 1534 0038 8040      		sbci r24,0
 1535 003a 9040      		sbci r25,0
 1536 003c 01F4      		brne 1b
 1537 003e 00C0      		rjmp .
 1538 0040 0000      		nop
 1539               	.LVL156:
 1540               	.LBE83:
 1541               	.LBE82:
  57:led.c         ****         _delay_ms(4000);
 1542               		.loc 3 57 0
 1543 0042 0E94 0000 		call displayChoosePercentages
 1544               	.LVL157:
 1545               	.LBB84:
 1546               	.LBB85:
 187:/usr/lib/avr/include/util/delay.h **** 
 1547               		.loc 2 187 0
 1548 0046 2FEF      		ldi r18,lo8(799999)
 1549 0048 84E3      		ldi r24,hi8(799999)
 1550 004a 9CE0      		ldi r25,hlo8(799999)
 1551 004c 2150      	1:	subi r18,1
 1552 004e 8040      		sbci r24,0
 1553 0050 9040      		sbci r25,0
 1554 0052 01F4      		brne 1b
 1555 0054 00C0      		rjmp .
 1556 0056 0000      		nop
 1557               	.LVL158:
 1558               	.LBE85:
 1559               	.LBE84:
  60:led.c         ****         lcd_setCursor(0, 0);
 1560               		.loc 3 60 0
 1561 0058 0E94 0000 		call lcd_clear
 1562               	.LVL159:
  61:led.c         ****         lcd_print("Total should not");
 1563               		.loc 3 61 0
 1564 005c 60E0      		ldi r22,0
 1565 005e 80E0      		ldi r24,0
 1566 0060 0E94 0000 		call lcd_setCursor
 1567               	.LVL160:
  62:led.c         ****         lcd_setCursor(0, 1);
 1568               		.loc 3 62 0
 1569 0064 80E0      		ldi r24,lo8(.LC17)
 1570 0066 90E0      		ldi r25,hi8(.LC17)
 1571 0068 0E94 0000 		call lcd_print
 1572               	.LVL161:
  63:led.c         ****         lcd_print("exceed 100%");
 1573               		.loc 3 63 0
 1574 006c 61E0      		ldi r22,lo8(1)
 1575 006e 80E0      		ldi r24,0
 1576 0070 0E94 0000 		call lcd_setCursor
 1577               	.LVL162:
  64:led.c         ****         _delay_ms(4000);
 1578               		.loc 3 64 0
 1579 0074 80E0      		ldi r24,lo8(.LC18)
 1580 0076 90E0      		ldi r25,hi8(.LC18)
 1581 0078 0E94 0000 		call lcd_print
 1582               	.LVL163:
 1583               	.LBB86:
 1584               	.LBB87:
 187:/usr/lib/avr/include/util/delay.h **** 
 1585               		.loc 2 187 0
 1586 007c 2FEF      		ldi r18,lo8(799999)
 1587 007e 84E3      		ldi r24,hi8(799999)
 1588 0080 9CE0      		ldi r25,hlo8(799999)
 1589 0082 2150      	1:	subi r18,1
 1590 0084 8040      		sbci r24,0
 1591 0086 9040      		sbci r25,0
 1592 0088 01F4      		brne 1b
 1593 008a 00C0      		rjmp .
 1594 008c 0000      		nop
 1595               	.LVL164:
 1596               	.LBE87:
 1597               	.LBE86:
  68:led.c         ****         selectingPercentage = 1;  // Enable percentage selection
 1598               		.loc 3 68 0
 1599 008e E091 0000 		lds r30,fruitIndex
 1600 0092 F0E0      		ldi r31,0
 1601 0094 EE0F      		lsl r30
 1602 0096 FF1F      		rol r31
 1603 0098 E050      		subi r30,lo8(-(fruits))
 1604 009a F040      		sbci r31,hi8(-(fruits))
 1605 009c 6091 0000 		lds r22,percentage
 1606 00a0 8081      		ld r24,Z
 1607 00a2 9181      		ldd r25,Z+1
 1608 00a4 0E94 0000 		call displayFruit
 1609               	.LVL165:
  69:led.c         **** 
 1610               		.loc 3 69 0
 1611 00a8 C093 0000 		sts selectingPercentage,r28
 1612               	.L82:
  72:led.c         ****                 // Read the rotary encoder to adjust the percentage
 1613               		.loc 3 72 0
 1614 00ac 8091 0000 		lds r24,selectingPercentage
 1615 00b0 8823      		tst r24
 1616 00b2 01F4      		brne .+2
 1617 00b4 00C0      		rjmp .L80
 1618               	.LBB88:
  74:led.c         ****                 if (rotation > 0 && percentage < 100) {
 1619               		.loc 3 74 0
 1620 00b6 0E94 0000 		call readEncoder
 1621               	.LVL166:
  75:led.c         ****                     percentage += 20;
 1622               		.loc 3 75 0
 1623 00ba 1816      		cp __zero_reg__,r24
 1624 00bc 04F4      		brge .L77
  75:led.c         ****                     percentage += 20;
 1625               		.loc 3 75 0 is_stmt 0 discriminator 1
 1626 00be 6091 0000 		lds r22,percentage
 1627 00c2 6436      		cpi r22,lo8(100)
 1628 00c4 00F4      		brsh .L78
  76:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percenta
 1629               		.loc 3 76 0 is_stmt 1
 1630 00c6 6C5E      		subi r22,lo8(-(20))
 1631 00c8 00C0      		rjmp .L100
 1632               	.L77:
  78:led.c         ****                     percentage -= 20;
 1633               		.loc 3 78 0
 1634 00ca 8823      		tst r24
 1635 00cc 01F0      		breq .L78
  78:led.c         ****                     percentage -= 20;
 1636               		.loc 3 78 0 is_stmt 0 discriminator 1
 1637 00ce 6091 0000 		lds r22,percentage
 1638 00d2 6623      		tst r22
 1639 00d4 01F0      		breq .L78
  79:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percenta
 1640               		.loc 3 79 0 is_stmt 1
 1641 00d6 6451      		subi r22,lo8(-(-20))
 1642               	.L100:
 1643 00d8 6093 0000 		sts percentage,r22
  80:led.c         ****                 }
 1644               		.loc 3 80 0
 1645 00dc E091 0000 		lds r30,fruitIndex
 1646 00e0 F0E0      		ldi r31,0
 1647 00e2 EE0F      		lsl r30
 1648 00e4 FF1F      		rol r31
 1649 00e6 E050      		subi r30,lo8(-(fruits))
 1650 00e8 F040      		sbci r31,hi8(-(fruits))
 1651 00ea 8081      		ld r24,Z
 1652 00ec 9181      		ldd r25,Z+1
 1653               	.LVL167:
 1654 00ee 0E94 0000 		call displayFruit
 1655               	.LVL168:
 1656               	.L78:
  84:led.c         ****                     _delay_ms(50); // Debounce delay
 1657               		.loc 3 84 0
 1658 00f2 0E94 0000 		call isEncoderPressed
 1659               	.LVL169:
 1660 00f6 8823      		tst r24
 1661 00f8 01F0      		breq .L80
 1662               	.LVL170:
 1663               	.LBB89:
 1664               	.LBB90:
 187:/usr/lib/avr/include/util/delay.h **** 
 1665               		.loc 2 187 0
 1666 00fa 83ED      		ldi r24,lo8(12499)
 1667 00fc 90E3      		ldi r25,hi8(12499)
 1668 00fe 0197      	1:	sbiw r24,1
 1669 0100 01F4      		brne 1b
 1670 0102 00C0      		rjmp .
 1671 0104 0000      		nop
 1672               	.LVL171:
 1673               	.LBE90:
 1674               	.LBE89:
  86:led.c         ****                         percentages[fruitIndex] = percentage;  // Store the selected percentage
 1675               		.loc 3 86 0
 1676 0106 0E94 0000 		call isEncoderPressed
 1677               	.LVL172:
 1678 010a 8823      		tst r24
 1679 010c 01F0      		breq .L80
  87:led.c         ****                         fruitIndex++;  // Move to the next fruit
 1680               		.loc 3 87 0
 1681 010e E091 0000 		lds r30,fruitIndex
 1682 0112 AE2F      		mov r26,r30
 1683 0114 B0E0      		ldi r27,0
 1684 0116 A050      		subi r26,lo8(-(percentages))
 1685 0118 B040      		sbci r27,hi8(-(percentages))
 1686 011a 8091 0000 		lds r24,percentage
 1687 011e 8C93      		st X,r24
  88:led.c         **** 
 1688               		.loc 3 88 0
 1689 0120 EF5F      		subi r30,lo8(-(1))
 1690 0122 E093 0000 		sts fruitIndex,r30
  90:led.c         ****                             percentage = 0;  // Reset percentage for the next fruit
 1691               		.loc 3 90 0
 1692 0126 E430      		cpi r30,lo8(4)
 1693 0128 00F4      		brsh .L79
  91:led.c         ****                             displayFruit(fruits[fruitIndex], percentage);  // Display next fruit
 1694               		.loc 3 91 0
 1695 012a 1092 0000 		sts percentage,__zero_reg__
  92:led.c         ****                         } else {
 1696               		.loc 3 92 0
 1697 012e F0E0      		ldi r31,0
 1698 0130 EE0F      		lsl r30
 1699 0132 FF1F      		rol r31
 1700 0134 E050      		subi r30,lo8(-(fruits))
 1701 0136 F040      		sbci r31,hi8(-(fruits))
 1702 0138 60E0      		ldi r22,0
 1703 013a 8081      		ld r24,Z
 1704 013c 9181      		ldd r25,Z+1
 1705 013e 0E94 0000 		call displayFruit
 1706               	.LVL173:
 1707 0142 00C0      		rjmp .L80
 1708               	.L79:
  94:led.c         ****                             checkPercentageSum();  // Check if total exceeds 100
 1709               		.loc 3 94 0
 1710 0144 1092 0000 		sts selectingPercentage,__zero_reg__
  95:led.c         ****                             break;  // Exit the inner loop
 1711               		.loc 3 95 0
 1712 0148 0E94 0000 		call checkPercentageSum
 1713               	.LVL174:
 1714               	.LBE88:
 103:led.c         **** 
 1715               		.loc 3 103 0
 1716 014c 00C0      		rjmp .L81
 1717               	.L80:
 1718               	.LVL175:
 1719               	.LBB91:
 1720               	.LBB92:
 187:/usr/lib/avr/include/util/delay.h **** 
 1721               		.loc 2 187 0
 1722 014e 83ED      		ldi r24,lo8(12499)
 1723 0150 90E3      		ldi r25,hi8(12499)
 1724 0152 0197      	1:	sbiw r24,1
 1725 0154 01F4      		brne 1b
 1726 0156 00C0      		rjmp .
 1727 0158 0000      		nop
 1728 015a 00C0      		rjmp .L82
 1729               	.LBE92:
 1730               	.LBE91:
 1731               		.cfi_endproc
 1732               	.LFE17:
 1734               		.local	lastStateCLK.1848
 1735               		.comm	lastStateCLK.1848,1,1
 1736               	.global	switch1Pressed
 1737               		.section .bss
 1740               	switch1Pressed:
 1741 0000 00        		.zero	1
 1742               	.global	selectingPercentage
 1745               	selectingPercentage:
 1746 0001 00        		.zero	1
 1747               	.global	percentage
 1750               	percentage:
 1751 0002 00        		.zero	1
 1752               	.global	percentages
 1755               	percentages:
 1756 0003 0000 0000 		.zero	4
 1757               	.global	fruitIndex
 1760               	fruitIndex:
 1761 0007 00        		.zero	1
 1762               	.global	fruits
 1763               		.section	.rodata.str1.1
 1764               	.LC19:
 1765 00da 5049 4E45 		.string	"PINEAPPLE"
 1765      4150 504C 
 1765      4500 
 1766               	.LC20:
 1767 00e4 4D41 4E47 		.string	"MANGO"
 1767      4F00 
 1768               	.LC21:
 1769 00ea 4150 504C 		.string	"APPLE"
 1769      4500 
 1770               	.LC22:
 1771 00f0 4F52 414E 		.string	"ORANGE"
 1771      4745 00
 1772               		.data
 1775               	fruits:
 1776 0000 0000      		.word	.LC19
 1777 0002 0000      		.word	.LC20
 1778 0004 0000      		.word	.LC21
 1779 0006 0000      		.word	.LC22
 1780               		.text
 1781               	.Letext0:
 1782               		.file 4 "/usr/lib/avr/include/stdint.h"
 1783               		.file 5 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 led.c
     /tmp/ccswUK1i.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccswUK1i.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccswUK1i.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccswUK1i.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccswUK1i.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccswUK1i.s:12     .text:0000000000000000 i2c_init
     /tmp/ccswUK1i.s:35     .text:0000000000000012 i2c_start
     /tmp/ccswUK1i.s:59     .text:0000000000000022 i2c_stop
     /tmp/ccswUK1i.s:76     .text:000000000000002a i2c_write
     /tmp/ccswUK1i.s:105    .text:000000000000003e lcd_enable
     /tmp/ccswUK1i.s:171    .text:0000000000000070 lcd_send
     /tmp/ccswUK1i.s:219    .text:0000000000000094 lcd_command
     /tmp/ccswUK1i.s:237    .text:000000000000009a lcd_print
     /tmp/ccswUK1i.s:280    .text:00000000000000b4 lcd_clear
     /tmp/ccswUK1i.s:317    .text:00000000000000c8 lcd_setCursor
     /tmp/ccswUK1i.s:385    .text:0000000000000110 initialize
     /tmp/ccswUK1i.s:430    .text:0000000000000138 isSwitch1Pressed
     /tmp/ccswUK1i.s:450    .text:0000000000000140 isSwitch2Pressed
     /tmp/ccswUK1i.s:471    .text:000000000000014c isEncoderPressed
     /tmp/ccswUK1i.s:499    .text:000000000000015a displayModes
     /tmp/ccswUK1i.s:541    .text:000000000000017e displayProcessing
     /tmp/ccswUK1i.s:583    .text:00000000000001a2 displayChoosePercentages
     /tmp/ccswUK1i.s:625    .text:00000000000001c6 displayExceed100
     /tmp/ccswUK1i.s:681    .text:00000000000001fe displayFruit
     /tmp/ccswUK1i.s:799    .text:0000000000000282 displayOrderComplete
     /tmp/ccswUK1i.s:841    .text:00000000000002a6 displayEnjoyDrink
     /tmp/ccswUK1i.s:893    .text:00000000000002de readEncoder
                             .bss:0000000000000008 lastStateCLK.1848
     /tmp/ccswUK1i.s:938    .text:0000000000000302 turnOffMotors
     /tmp/ccswUK1i.s:956    .text:000000000000030a setup
     /tmp/ccswUK1i.s:994    .text:0000000000000328 getDelayForPercentage
     /tmp/ccswUK1i.s:1062   .text:0000000000000362 turnOnMotor
     /tmp/ccswUK1i.s:1132   .text:00000000000003a0 checkPercentageSum
     /tmp/ccswUK1i.s:1755   .bss:0000000000000003 percentages
     /tmp/ccswUK1i.s:1760   .bss:0000000000000007 fruitIndex
     /tmp/ccswUK1i.s:1750   .bss:0000000000000002 percentage
     /tmp/ccswUK1i.s:1775   .data:0000000000000000 fruits
     /tmp/ccswUK1i.s:1745   .bss:0000000000000001 selectingPercentage
     /tmp/ccswUK1i.s:1246   .text:0000000000000426 manualMode
     /tmp/ccswUK1i.s:1484   .text.startup:0000000000000000 main
     /tmp/ccswUK1i.s:1740   .bss:0000000000000000 switch1Pressed

UNDEFINED SYMBOLS
snprintf
__do_copy_data
__do_clear_bss
