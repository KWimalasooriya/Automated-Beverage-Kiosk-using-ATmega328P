   1               		.file	"led.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	I2C_Init
  12               	I2C_Init:
  13               	.LFB6:
  14               		.file 1 "i2c.h"
   1:i2c.h         **** #ifndef I2C_H
   2:i2c.h         **** #define I2C_H
   3:i2c.h         **** 
   4:i2c.h         **** #include <avr/io.h>           /* Include AVR std. library file */
   5:i2c.h         **** #include <util/delay.h>       /* Include Delay header file */
   6:i2c.h         **** 
   7:i2c.h         **** /* LCD I2C address */
   8:i2c.h         **** #define LCD_I2C_ADDRESS 0x27  /* Define I2C address of the LCD, often 0x27 or 0x3F */
   9:i2c.h         **** #define LCD_BACKLIGHT 0x08    /* Backlight control bit */
  10:i2c.h         **** #define ENABLE 0x04           /* Enable bit */
  11:i2c.h         **** #define READ_WRITE 0x02       /* Read/Write bit */
  12:i2c.h         **** #define REGISTER_SELECT 0x01  /* Register select bit */
  13:i2c.h         **** 
  14:i2c.h         **** /* I2C Functions */
  15:i2c.h         **** void I2C_Init(void) {
  15               		.loc 1 15 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  16:i2c.h         ****     TWSR = 0x00;              /* Set prescaler bits to zero */
  21               		.loc 1 16 0
  22 0000 1092 B900 		sts 185,__zero_reg__
  17:i2c.h         ****     TWBR = 0x46;              /* SCL frequency = 50kHz for F_CPU = 8MHz */
  23               		.loc 1 17 0
  24 0004 86E4      		ldi r24,lo8(70)
  25 0006 8093 B800 		sts 184,r24
  18:i2c.h         ****     TWCR = (1<<TWEN);         /* Enable TWI */
  26               		.loc 1 18 0
  27 000a 84E0      		ldi r24,lo8(4)
  28 000c 8093 BC00 		sts 188,r24
  29 0010 0895      		ret
  30               		.cfi_endproc
  31               	.LFE6:
  33               	.global	I2C_Start
  35               	I2C_Start:
  36               	.LFB7:
  19:i2c.h         **** }
  20:i2c.h         **** 
  21:i2c.h         **** void I2C_Start(void) {
  37               		.loc 1 21 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
  22:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);  /* Enable TWI, generate start condition */
  43               		.loc 1 22 0
  44 0012 84EA      		ldi r24,lo8(-92)
  45 0014 8093 BC00 		sts 188,r24
  46               	.L3:
  23:i2c.h         ****     while (!(TWCR & (1<<TWINT)));            /* Wait for TWINT flag to set */
  47               		.loc 1 23 0 discriminator 1
  48 0018 8091 BC00 		lds r24,188
  49 001c 87FF      		sbrs r24,7
  50 001e 00C0      		rjmp .L3
  51               	/* epilogue start */
  24:i2c.h         **** }
  52               		.loc 1 24 0
  53 0020 0895      		ret
  54               		.cfi_endproc
  55               	.LFE7:
  57               	.global	I2C_Stop
  59               	I2C_Stop:
  60               	.LFB8:
  25:i2c.h         **** 
  26:i2c.h         **** void I2C_Stop(void) {
  61               		.loc 1 26 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
  27:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);  /* Enable TWI, generate stop condition */
  67               		.loc 1 27 0
  68 0022 84E9      		ldi r24,lo8(-108)
  69 0024 8093 BC00 		sts 188,r24
  70               	.LVL0:
  71               	.LBB16:
  72               	.LBB17:
  73               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  74               		.loc 2 276 0
  75 0028 8FE8      		ldi r24,lo8(399)
  76 002a 91E0      		ldi r25,hi8(399)
  77 002c 0197      	1:	sbiw r24,1
  78 002e 01F4      		brne 1b
  79 0030 00C0      		rjmp .
  80 0032 0000      		nop
  81               	.LVL1:
  82 0034 0895      		ret
  83               	.LBE17:
  84               	.LBE16:
  85               		.cfi_endproc
  86               	.LFE8:
  88               	.global	I2C_Write
  90               	I2C_Write:
  91               	.LFB9:
  28:i2c.h         ****     _delay_us(100);
  29:i2c.h         **** }
  30:i2c.h         **** 
  31:i2c.h         **** uint8_t I2C_Write(uint8_t data) {
  92               		.loc 1 31 0
  93               		.cfi_startproc
  94               	.LVL2:
  95               	/* prologue: function */
  96               	/* frame size = 0 */
  97               	/* stack size = 0 */
  98               	.L__stack_usage = 0
  32:i2c.h         ****     TWDR = data;              /* Copy data to TWI data register */
  99               		.loc 1 32 0
 100 0036 8093 BB00 		sts 187,r24
  33:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWEN); /* Enable TWI and clear interrupt flag */
 101               		.loc 1 33 0
 102 003a 84E8      		ldi r24,lo8(-124)
 103               	.LVL3:
 104 003c 8093 BC00 		sts 188,r24
 105               	.LVL4:
 106               	.L8:
  34:i2c.h         ****     while (!(TWCR & (1<<TWINT)));  /* Wait for TWINT flag to set */
 107               		.loc 1 34 0 discriminator 1
 108 0040 8091 BC00 		lds r24,188
 109 0044 87FF      		sbrs r24,7
 110 0046 00C0      		rjmp .L8
  35:i2c.h         ****     
  36:i2c.h         ****     // Check status
  37:i2c.h         ****     uint8_t status = TWSR & 0xF8;
 111               		.loc 1 37 0
 112 0048 9091 B900 		lds r25,185
 113 004c 987F      		andi r25,lo8(-8)
 114               	.LVL5:
  38:i2c.h         ****     if (status == 0x28 || status == 0x18) { /* 0x28 = TW_MT_DATA_ACK, 0x18 = TW_MT_SLA_ACK */
 115               		.loc 1 38 0
 116 004e 9832      		cpi r25,lo8(40)
 117 0050 01F0      		breq .L11
  39:i2c.h         ****         return 0;  // ACK received
 118               		.loc 1 39 0 discriminator 1
 119 0052 81E0      		ldi r24,lo8(1)
 120 0054 9831      		cpi r25,lo8(24)
 121 0056 01F4      		brne .L9
 122               	.L11:
 123               		.loc 1 39 0 is_stmt 0
 124 0058 80E0      		ldi r24,0
 125               	.L9:
  40:i2c.h         ****     } else {
  41:i2c.h         ****         return 1;  // NACK or error
  42:i2c.h         ****     }
  43:i2c.h         **** }
 126               		.loc 1 43 0 is_stmt 1
 127 005a 0895      		ret
 128               		.cfi_endproc
 129               	.LFE9:
 131               	.global	LCD_EnablePulse
 133               	LCD_EnablePulse:
 134               	.LFB10:
  44:i2c.h         **** 
  45:i2c.h         **** /* LCD Functions */
  46:i2c.h         **** void LCD_EnablePulse(uint8_t data) {
 135               		.loc 1 46 0
 136               		.cfi_startproc
 137               	.LVL6:
 138 005c CF93      		push r28
 139               	.LCFI0:
 140               		.cfi_def_cfa_offset 3
 141               		.cfi_offset 28, -2
 142               	/* prologue: function */
 143               	/* frame size = 0 */
 144               	/* stack size = 1 */
 145               	.L__stack_usage = 1
 146 005e C82F      		mov r28,r24
  47:i2c.h         ****     I2C_Write(data | ENABLE);  /* Enable bit high */
 147               		.loc 1 47 0
 148 0060 8460      		ori r24,lo8(4)
 149               	.LVL7:
 150 0062 0E94 0000 		call I2C_Write
 151               	.LVL8:
 152               	.LBB18:
 153               	.LBB19:
 154               		.loc 2 276 0
 155 0066 85E0      		ldi r24,lo8(5)
 156 0068 8A95      	1:	dec r24
 157 006a 01F4      		brne 1b
 158 006c 0000      		nop
 159               	.LVL9:
 160               	.LBE19:
 161               	.LBE18:
  48:i2c.h         ****     _delay_us(1);              /* Enable pulse width */
  49:i2c.h         ****     I2C_Write(data & ~ENABLE); /* Enable bit low */
 162               		.loc 1 49 0
 163 006e 8C2F      		mov r24,r28
 164 0070 8B7F      		andi r24,lo8(-5)
 165 0072 0E94 0000 		call I2C_Write
 166               	.LVL10:
 167               	.LBB20:
 168               	.LBB21:
 187:/usr/lib/avr/include/util/delay.h **** 
 169               		.loc 2 187 0
 170 0076 8FE3      		ldi r24,lo8(7999)
 171 0078 9FE1      		ldi r25,hi8(7999)
 172 007a 0197      	1:	sbiw r24,1
 173 007c 01F4      		brne 1b
 174 007e 00C0      		rjmp .
 175 0080 0000      		nop
 176               	.LVL11:
 177               	/* epilogue start */
 178               	.LBE21:
 179               	.LBE20:
  50:i2c.h         ****     _delay_ms(2);              /* Wait for the command to execute */
  51:i2c.h         **** }
 180               		.loc 1 51 0
 181 0082 CF91      		pop r28
 182               	.LVL12:
 183 0084 0895      		ret
 184               		.cfi_endproc
 185               	.LFE10:
 187               	.global	LCD_Command
 189               	LCD_Command:
 190               	.LFB11:
  52:i2c.h         **** 
  53:i2c.h         **** void LCD_Command(uint8_t cmnd) {
 191               		.loc 1 53 0
 192               		.cfi_startproc
 193               	.LVL13:
 194 0086 CF93      		push r28
 195               	.LCFI1:
 196               		.cfi_def_cfa_offset 3
 197               		.cfi_offset 28, -2
 198               	/* prologue: function */
 199               	/* frame size = 0 */
 200               	/* stack size = 1 */
 201               	.L__stack_usage = 1
 202 0088 C82F      		mov r28,r24
 203               	.LVL14:
  54:i2c.h         ****     uint8_t highNibble = (cmnd & 0xF0) | LCD_BACKLIGHT;
  55:i2c.h         ****     uint8_t lowNibble = ((cmnd << 4) & 0xF0) | LCD_BACKLIGHT;
  56:i2c.h         **** 
  57:i2c.h         ****     I2C_Start();
 204               		.loc 1 57 0
 205 008a 0E94 0000 		call I2C_Start
 206               	.LVL15:
  58:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 207               		.loc 1 58 0
 208 008e 8EE4      		ldi r24,lo8(78)
 209 0090 0E94 0000 		call I2C_Write
 210               	.LVL16:
  59:i2c.h         ****     
  60:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble */
 211               		.loc 1 60 0
 212 0094 8C2F      		mov r24,r28
 213 0096 807F      		andi r24,lo8(-16)
 214 0098 8860      		ori r24,lo8(8)
 215               	.LVL17:
 216 009a 0E94 0000 		call LCD_EnablePulse
 217               	.LVL18:
  61:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble */
 218               		.loc 1 61 0
 219 009e 20E1      		ldi r18,lo8(16)
 220 00a0 C29F      		mul r28,r18
 221 00a2 C001      		movw r24,r0
 222 00a4 1124      		clr __zero_reg__
 223 00a6 8860      		ori r24,lo8(8)
 224 00a8 0E94 0000 		call LCD_EnablePulse
 225               	.LVL19:
 226               	/* epilogue start */
  62:i2c.h         ****     
  63:i2c.h         ****     I2C_Stop();
  64:i2c.h         **** }
 227               		.loc 1 64 0
 228 00ac CF91      		pop r28
 229               	.LVL20:
  63:i2c.h         **** }
 230               		.loc 1 63 0
 231 00ae 0C94 0000 		jmp I2C_Stop
 232               	.LVL21:
 233               		.cfi_endproc
 234               	.LFE11:
 236               	.global	LCD_Char
 238               	LCD_Char:
 239               	.LFB12:
  65:i2c.h         **** 
  66:i2c.h         **** void LCD_Char(uint8_t data) {
 240               		.loc 1 66 0
 241               		.cfi_startproc
 242               	.LVL22:
 243 00b2 CF93      		push r28
 244               	.LCFI2:
 245               		.cfi_def_cfa_offset 3
 246               		.cfi_offset 28, -2
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 1 */
 250               	.L__stack_usage = 1
 251 00b4 C82F      		mov r28,r24
 252               	.LVL23:
  67:i2c.h         ****     uint8_t highNibble = (data & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  68:i2c.h         ****     uint8_t lowNibble = ((data << 4) & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  69:i2c.h         **** 
  70:i2c.h         ****     I2C_Start();
 253               		.loc 1 70 0
 254 00b6 0E94 0000 		call I2C_Start
 255               	.LVL24:
  71:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 256               		.loc 1 71 0
 257 00ba 8EE4      		ldi r24,lo8(78)
 258 00bc 0E94 0000 		call I2C_Write
 259               	.LVL25:
  72:i2c.h         ****     
  73:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble with RS=1 for data */
 260               		.loc 1 73 0
 261 00c0 8C2F      		mov r24,r28
 262 00c2 807F      		andi r24,lo8(-16)
 263 00c4 8960      		ori r24,lo8(9)
 264               	.LVL26:
 265 00c6 0E94 0000 		call LCD_EnablePulse
 266               	.LVL27:
  74:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble with RS=1 */
 267               		.loc 1 74 0
 268 00ca 20E1      		ldi r18,lo8(16)
 269 00cc C29F      		mul r28,r18
 270 00ce C001      		movw r24,r0
 271 00d0 1124      		clr __zero_reg__
 272 00d2 8960      		ori r24,lo8(9)
 273 00d4 0E94 0000 		call LCD_EnablePulse
 274               	.LVL28:
 275               	/* epilogue start */
  75:i2c.h         ****     
  76:i2c.h         ****     I2C_Stop();
  77:i2c.h         **** }
 276               		.loc 1 77 0
 277 00d8 CF91      		pop r28
 278               	.LVL29:
  76:i2c.h         **** }
 279               		.loc 1 76 0
 280 00da 0C94 0000 		jmp I2C_Stop
 281               	.LVL30:
 282               		.cfi_endproc
 283               	.LFE12:
 285               	.global	LCD_Init
 287               	LCD_Init:
 288               	.LFB13:
  78:i2c.h         **** 
  79:i2c.h         **** void LCD_Init(void) {
 289               		.loc 1 79 0
 290               		.cfi_startproc
 291               	/* prologue: function */
 292               	/* frame size = 0 */
 293               	/* stack size = 0 */
 294               	.L__stack_usage = 0
  80:i2c.h         ****     I2C_Init();                /* Initialize I2C */
 295               		.loc 1 80 0
 296 00de 0E94 0000 		call I2C_Init
 297               	.LVL31:
 298               	.LBB22:
 299               	.LBB23:
 187:/usr/lib/avr/include/util/delay.h **** 
 300               		.loc 2 187 0
 301 00e2 2FEF      		ldi r18,lo8(63999)
 302 00e4 89EF      		ldi r24,hi8(63999)
 303 00e6 90E0      		ldi r25,hlo8(63999)
 304 00e8 2150      	1:	subi r18,1
 305 00ea 8040      		sbci r24,0
 306 00ec 9040      		sbci r25,0
 307 00ee 01F4      		brne 1b
 308 00f0 00C0      		rjmp .
 309 00f2 0000      		nop
 310               	.LVL32:
 311               	.LBE23:
 312               	.LBE22:
  81:i2c.h         ****     _delay_ms(20);             /* LCD Power ON delay */
  82:i2c.h         ****     
  83:i2c.h         ****     LCD_Command(0x02);         /* Initialize for 4-bit mode */
 313               		.loc 1 83 0
 314 00f4 82E0      		ldi r24,lo8(2)
 315 00f6 0E94 0000 		call LCD_Command
 316               	.LVL33:
  84:i2c.h         ****     LCD_Command(0x28);         /* 2 lines, 5x7 matrix in 4-bit mode */
 317               		.loc 1 84 0
 318 00fa 88E2      		ldi r24,lo8(40)
 319 00fc 0E94 0000 		call LCD_Command
 320               	.LVL34:
  85:i2c.h         ****     LCD_Command(0x0C);         /* Display ON, Cursor OFF */
 321               		.loc 1 85 0
 322 0100 8CE0      		ldi r24,lo8(12)
 323 0102 0E94 0000 		call LCD_Command
 324               	.LVL35:
  86:i2c.h         ****     LCD_Command(0x06);         /* Auto increment cursor */
 325               		.loc 1 86 0
 326 0106 86E0      		ldi r24,lo8(6)
 327 0108 0E94 0000 		call LCD_Command
 328               	.LVL36:
  87:i2c.h         ****     LCD_Command(0x01);         /* Clear display */
 329               		.loc 1 87 0
 330 010c 81E0      		ldi r24,lo8(1)
 331 010e 0E94 0000 		call LCD_Command
 332               	.LVL37:
 333               	.LBB24:
 334               	.LBB25:
 187:/usr/lib/avr/include/util/delay.h **** 
 335               		.loc 2 187 0
 336 0112 8FE3      		ldi r24,lo8(7999)
 337 0114 9FE1      		ldi r25,hi8(7999)
 338 0116 0197      	1:	sbiw r24,1
 339 0118 01F4      		brne 1b
 340 011a 00C0      		rjmp .
 341 011c 0000      		nop
 342               	.LVL38:
 343 011e 0895      		ret
 344               	.LBE25:
 345               	.LBE24:
 346               		.cfi_endproc
 347               	.LFE13:
 349               	.global	LCD_String
 351               	LCD_String:
 352               	.LFB14:
  88:i2c.h         ****     _delay_ms(2);
  89:i2c.h         **** }
  90:i2c.h         **** 
  91:i2c.h         **** void LCD_String(char *str) {
 353               		.loc 1 91 0
 354               		.cfi_startproc
 355               	.LVL39:
 356 0120 CF93      		push r28
 357               	.LCFI3:
 358               		.cfi_def_cfa_offset 3
 359               		.cfi_offset 28, -2
 360 0122 DF93      		push r29
 361               	.LCFI4:
 362               		.cfi_def_cfa_offset 4
 363               		.cfi_offset 29, -3
 364               	/* prologue: function */
 365               	/* frame size = 0 */
 366               	/* stack size = 2 */
 367               	.L__stack_usage = 2
 368 0124 EC01      		movw r28,r24
 369               	.LVL40:
 370               	.L18:
  92:i2c.h         ****     while (*str) {
 371               		.loc 1 92 0
 372 0126 8991      		ld r24,Y+
 373               	.LVL41:
 374 0128 8823      		tst r24
 375 012a 01F0      		breq .L20
 376               	.LVL42:
  93:i2c.h         ****         LCD_Char(*str++);
 377               		.loc 1 93 0
 378 012c 0E94 0000 		call LCD_Char
 379               	.LVL43:
 380 0130 00C0      		rjmp .L18
 381               	.LVL44:
 382               	.L20:
 383               	/* epilogue start */
  94:i2c.h         ****     }
  95:i2c.h         **** }
 384               		.loc 1 95 0
 385 0132 DF91      		pop r29
 386 0134 CF91      		pop r28
 387               	.LVL45:
 388 0136 0895      		ret
 389               		.cfi_endproc
 390               	.LFE14:
 392               	.global	LCD_Clear
 394               	LCD_Clear:
 395               	.LFB15:
  96:i2c.h         **** 
  97:i2c.h         **** void LCD_Clear(void) {
 396               		.loc 1 97 0
 397               		.cfi_startproc
 398               	/* prologue: function */
 399               	/* frame size = 0 */
 400               	/* stack size = 0 */
 401               	.L__stack_usage = 0
  98:i2c.h         ****     LCD_Command(0x01);  // 0x01 is the command to clear the display
 402               		.loc 1 98 0
 403 0138 81E0      		ldi r24,lo8(1)
 404 013a 0E94 0000 		call LCD_Command
 405               	.LVL46:
 406               	.LBB26:
 407               	.LBB27:
 187:/usr/lib/avr/include/util/delay.h **** 
 408               		.loc 2 187 0
 409 013e 8FE3      		ldi r24,lo8(7999)
 410 0140 9FE1      		ldi r25,hi8(7999)
 411 0142 0197      	1:	sbiw r24,1
 412 0144 01F4      		brne 1b
 413 0146 00C0      		rjmp .
 414 0148 0000      		nop
 415               	.LVL47:
 416 014a 0895      		ret
 417               	.LBE27:
 418               	.LBE26:
 419               		.cfi_endproc
 420               	.LFE15:
 422               	.global	setup
 424               	setup:
 425               	.LFB17:
 426               		.file 3 "led.c"
   1:led.c         **** #include <avr/io.h>
   2:led.c         **** #include <util/delay.h>    // Include for delay functions
   3:led.c         **** #include "i2c.h"           // Include the I2C LCD header file
   4:led.c         **** 
   5:led.c         **** // Function prototypes
   6:led.c         **** void setup();
   7:led.c         **** uint8_t isButtonPressed();
   8:led.c         **** void displayProcessing();  // Function to display "Processing" and "Auto Mode"
   9:led.c         **** 
  10:led.c         **** int main(void) {
  11:led.c         ****     uint8_t buttonState = 0;       // Variable to store the current button state
  12:led.c         ****     uint8_t lastButtonState = 0;   // Variable to track the previous state of the button (for edge 
  13:led.c         **** 
  14:led.c         ****     setup();                       // Initialize pins
  15:led.c         ****     LCD_Init();                    // Initialize LCD
  16:led.c         **** 
  17:led.c         ****     // Initial LCD Display
  18:led.c         ****     LCD_String("1. Auto Mode");    // Write initial string on the 1st row
  19:led.c         ****     LCD_Command(0x80 | 0x40);      // Move cursor to 2nd row
  20:led.c         ****     LCD_String("2. Manual Mode");  // Write string on the 2nd row
  21:led.c         **** 
  22:led.c         ****     while (1) {
  23:led.c         ****         // Read the button state
  24:led.c         ****         buttonState = isButtonPressed();
  25:led.c         **** 
  26:led.c         ****         // Detect if the button was just pressed (falling edge detection)
  27:led.c         ****         if (buttonState && !lastButtonState) {
  28:led.c         ****             // Update LCD to show "Processing" and "Auto Mode"
  29:led.c         ****             displayProcessing();
  30:led.c         ****         }
  31:led.c         **** 
  32:led.c         ****         // Save the current button state for the next loop
  33:led.c         ****         lastButtonState = buttonState;
  34:led.c         **** 
  35:led.c         ****         // Small delay for debouncing
  36:led.c         ****         _delay_ms(100);
  37:led.c         ****     }
  38:led.c         **** 
  39:led.c         ****     return 0;
  40:led.c         **** }
  41:led.c         **** 
  42:led.c         **** // Function to set up the button pins
  43:led.c         **** void setup() {
 427               		.loc 3 43 0
 428               		.cfi_startproc
 429               	/* prologue: function */
 430               	/* frame size = 0 */
 431               	/* stack size = 0 */
 432               	.L__stack_usage = 0
  44:led.c         ****     // Set PC3 as input for the button (NO pin)
  45:led.c         ****     DDRC &= ~(1 << PC3);
 433               		.loc 3 45 0
 434 014c 3B98      		cbi 0x7,3
  46:led.c         **** 
  47:led.c         ****     // Enable pull-up resistor on PC3
  48:led.c         ****     PORTC |= (1 << PC3);
 435               		.loc 3 48 0
 436 014e 439A      		sbi 0x8,3
 437 0150 0895      		ret
 438               		.cfi_endproc
 439               	.LFE17:
 441               	.global	isButtonPressed
 443               	isButtonPressed:
 444               	.LFB18:
  49:led.c         **** }
  50:led.c         **** 
  51:led.c         **** // Function to check if the button is pressed
  52:led.c         **** uint8_t isButtonPressed() {
 445               		.loc 3 52 0
 446               		.cfi_startproc
 447               	/* prologue: function */
 448               	/* frame size = 0 */
 449               	/* stack size = 0 */
 450               	.L__stack_usage = 0
  53:led.c         ****     return !(PINC & (1 << PC3));  // Return true (1) if button is pressed
 451               		.loc 3 53 0
 452 0152 86B1      		in r24,0x6
 453 0154 83FB      		bst r24,3
 454 0156 8827      		clr r24
 455 0158 80F9      		bld r24,0
  54:led.c         **** }
 456               		.loc 3 54 0
 457 015a 91E0      		ldi r25,lo8(1)
 458 015c 8927      		eor r24,r25
 459 015e 0895      		ret
 460               		.cfi_endproc
 461               	.LFE18:
 463               		.section	.rodata.str1.1,"aMS",@progbits,1
 464               	.LC0:
 465 0000 5072 6F63 		.string	"Processing"
 465      6573 7369 
 465      6E67 00
 466               	.LC1:
 467 000b 4175 746F 		.string	"Auto Mode...."
 467      204D 6F64 
 467      652E 2E2E 
 467      2E00 
 468               		.text
 469               	.global	displayProcessing
 471               	displayProcessing:
 472               	.LFB19:
  55:led.c         **** 
  56:led.c         **** // Function to update the LCD with "Processing" and "Auto Mode"
  57:led.c         **** void displayProcessing() {
 473               		.loc 3 57 0
 474               		.cfi_startproc
 475               	/* prologue: function */
 476               	/* frame size = 0 */
 477               	/* stack size = 0 */
 478               	.L__stack_usage = 0
  58:led.c         ****     LCD_Clear();                    // Clear the LCD
 479               		.loc 3 58 0
 480 0160 0E94 0000 		call LCD_Clear
 481               	.LVL48:
  59:led.c         ****     LCD_String("Processing");        // Display "Processing" on the 1st row
 482               		.loc 3 59 0
 483 0164 80E0      		ldi r24,lo8(.LC0)
 484 0166 90E0      		ldi r25,hi8(.LC0)
 485 0168 0E94 0000 		call LCD_String
 486               	.LVL49:
  60:led.c         ****     LCD_Command(0x80 | 0x40);        // Move cursor to 2nd row
 487               		.loc 3 60 0
 488 016c 80EC      		ldi r24,lo8(-64)
 489 016e 0E94 0000 		call LCD_Command
 490               	.LVL50:
  61:led.c         ****     LCD_String("Auto Mode....");         // Display "Auto Mode" on the 2nd row
 491               		.loc 3 61 0
 492 0172 80E0      		ldi r24,lo8(.LC1)
 493 0174 90E0      		ldi r25,hi8(.LC1)
 494 0176 0C94 0000 		jmp LCD_String
 495               	.LVL51:
 496               		.cfi_endproc
 497               	.LFE19:
 499               		.section	.rodata.str1.1
 500               	.LC2:
 501 0019 312E 2041 		.string	"1. Auto Mode"
 501      7574 6F20 
 501      4D6F 6465 
 501      00
 502               	.LC3:
 503 0026 322E 204D 		.string	"2. Manual Mode"
 503      616E 7561 
 503      6C20 4D6F 
 503      6465 00
 504               		.section	.text.startup,"ax",@progbits
 505               	.global	main
 507               	main:
 508               	.LFB16:
  10:led.c         ****     uint8_t buttonState = 0;       // Variable to store the current button state
 509               		.loc 3 10 0
 510               		.cfi_startproc
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 0 */
 514               	.L__stack_usage = 0
 515               	.LVL52:
  14:led.c         ****     LCD_Init();                    // Initialize LCD
 516               		.loc 3 14 0
 517 0000 0E94 0000 		call setup
 518               	.LVL53:
  15:led.c         **** 
 519               		.loc 3 15 0
 520 0004 0E94 0000 		call LCD_Init
 521               	.LVL54:
  18:led.c         ****     LCD_Command(0x80 | 0x40);      // Move cursor to 2nd row
 522               		.loc 3 18 0
 523 0008 80E0      		ldi r24,lo8(.LC2)
 524 000a 90E0      		ldi r25,hi8(.LC2)
 525 000c 0E94 0000 		call LCD_String
 526               	.LVL55:
  19:led.c         ****     LCD_String("2. Manual Mode");  // Write string on the 2nd row
 527               		.loc 3 19 0
 528 0010 80EC      		ldi r24,lo8(-64)
 529 0012 0E94 0000 		call LCD_Command
 530               	.LVL56:
  20:led.c         **** 
 531               		.loc 3 20 0
 532 0016 80E0      		ldi r24,lo8(.LC3)
 533 0018 90E0      		ldi r25,hi8(.LC3)
 534 001a 0E94 0000 		call LCD_String
 535               	.LVL57:
  12:led.c         **** 
 536               		.loc 3 12 0
 537 001e C0E0      		ldi r28,0
 538               	.LVL58:
 539               	.L27:
  24:led.c         **** 
 540               		.loc 3 24 0
 541 0020 0E94 0000 		call isButtonPressed
 542               	.LVL59:
 543 0024 D82F      		mov r29,r24
 544               	.LVL60:
  27:led.c         ****             // Update LCD to show "Processing" and "Auto Mode"
 545               		.loc 3 27 0
 546 0026 8823      		tst r24
 547 0028 01F0      		breq .L26
  27:led.c         ****             // Update LCD to show "Processing" and "Auto Mode"
 548               		.loc 3 27 0 is_stmt 0 discriminator 1
 549 002a C111      		cpse r28,__zero_reg__
 550 002c 00C0      		rjmp .L26
  29:led.c         ****         }
 551               		.loc 3 29 0 is_stmt 1
 552 002e 0E94 0000 		call displayProcessing
 553               	.LVL61:
 554               	.L26:
 555               	.LBB28:
 556               	.LBB29:
 187:/usr/lib/avr/include/util/delay.h **** 
 557               		.loc 2 187 0
 558 0032 2FEF      		ldi r18,lo8(319999)
 559 0034 81EE      		ldi r24,hi8(319999)
 560 0036 94E0      		ldi r25,hlo8(319999)
 561 0038 2150      	1:	subi r18,1
 562 003a 8040      		sbci r24,0
 563 003c 9040      		sbci r25,0
 564 003e 01F4      		brne 1b
 565 0040 00C0      		rjmp .
 566 0042 0000      		nop
 567               	.LBE29:
 568               	.LBE28:
  24:led.c         **** 
 569               		.loc 3 24 0
 570 0044 CD2F      		mov r28,r29
 571 0046 00C0      		rjmp .L27
 572               		.cfi_endproc
 573               	.LFE16:
 575               		.text
 576               	.Letext0:
 577               		.file 4 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 led.c
     /tmp/ccu9cyfD.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccu9cyfD.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccu9cyfD.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccu9cyfD.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccu9cyfD.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccu9cyfD.s:12     .text:0000000000000000 I2C_Init
     /tmp/ccu9cyfD.s:35     .text:0000000000000012 I2C_Start
     /tmp/ccu9cyfD.s:59     .text:0000000000000022 I2C_Stop
     /tmp/ccu9cyfD.s:90     .text:0000000000000036 I2C_Write
     /tmp/ccu9cyfD.s:133    .text:000000000000005c LCD_EnablePulse
     /tmp/ccu9cyfD.s:189    .text:0000000000000086 LCD_Command
     /tmp/ccu9cyfD.s:238    .text:00000000000000b2 LCD_Char
     /tmp/ccu9cyfD.s:287    .text:00000000000000de LCD_Init
     /tmp/ccu9cyfD.s:351    .text:0000000000000120 LCD_String
     /tmp/ccu9cyfD.s:394    .text:0000000000000138 LCD_Clear
     /tmp/ccu9cyfD.s:424    .text:000000000000014c setup
     /tmp/ccu9cyfD.s:443    .text:0000000000000152 isButtonPressed
     /tmp/ccu9cyfD.s:471    .text:0000000000000160 displayProcessing
     /tmp/ccu9cyfD.s:507    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__do_copy_data
