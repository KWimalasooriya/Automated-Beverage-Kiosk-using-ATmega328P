   1               		.file	"led.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	I2C_Init
  12               	I2C_Init:
  13               	.LFB6:
  14               		.file 1 "i2c.h"
   1:i2c.h         **** #ifndef I2C_H
   2:i2c.h         **** #define I2C_H
   3:i2c.h         **** 
   4:i2c.h         **** #include <avr/io.h>           /* Include AVR std. library file */
   5:i2c.h         **** #include <util/delay.h>       /* Include Delay header file */
   6:i2c.h         **** 
   7:i2c.h         **** /* LCD I2C address */
   8:i2c.h         **** #define LCD_I2C_ADDRESS 0x27  /* Define I2C address of the LCD, often 0x27 or 0x3F */
   9:i2c.h         **** #define LCD_BACKLIGHT 0x08    /* Backlight control bit */
  10:i2c.h         **** #define ENABLE 0x04           /* Enable bit */
  11:i2c.h         **** #define READ_WRITE 0x02       /* Read/Write bit */
  12:i2c.h         **** #define REGISTER_SELECT 0x01  /* Register select bit */
  13:i2c.h         **** 
  14:i2c.h         **** /* I2C Functions */
  15:i2c.h         **** void I2C_Init(void) {
  15               		.loc 1 15 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  16:i2c.h         ****     TWSR = 0x00;              /* Set prescaler bits to zero */
  21               		.loc 1 16 0
  22 0000 1092 B900 		sts 185,__zero_reg__
  17:i2c.h         ****     TWBR = 0x46;              /* SCL frequency = 50kHz for F_CPU = 8MHz */
  23               		.loc 1 17 0
  24 0004 86E4      		ldi r24,lo8(70)
  25 0006 8093 B800 		sts 184,r24
  18:i2c.h         ****     TWCR = (1<<TWEN);         /* Enable TWI */
  26               		.loc 1 18 0
  27 000a 84E0      		ldi r24,lo8(4)
  28 000c 8093 BC00 		sts 188,r24
  29 0010 0895      		ret
  30               		.cfi_endproc
  31               	.LFE6:
  33               	.global	I2C_Start
  35               	I2C_Start:
  36               	.LFB7:
  19:i2c.h         **** }
  20:i2c.h         **** 
  21:i2c.h         **** void I2C_Start(void) {
  37               		.loc 1 21 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
  22:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);  /* Enable TWI, generate start condition */
  43               		.loc 1 22 0
  44 0012 84EA      		ldi r24,lo8(-92)
  45 0014 8093 BC00 		sts 188,r24
  46               	.L3:
  23:i2c.h         ****     while (!(TWCR & (1<<TWINT)));            /* Wait for TWINT flag to set */
  47               		.loc 1 23 0 discriminator 1
  48 0018 8091 BC00 		lds r24,188
  49 001c 87FF      		sbrs r24,7
  50 001e 00C0      		rjmp .L3
  51               	/* epilogue start */
  24:i2c.h         **** }
  52               		.loc 1 24 0
  53 0020 0895      		ret
  54               		.cfi_endproc
  55               	.LFE7:
  57               	.global	I2C_Stop
  59               	I2C_Stop:
  60               	.LFB8:
  25:i2c.h         **** 
  26:i2c.h         **** void I2C_Stop(void) {
  61               		.loc 1 26 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
  27:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);  /* Enable TWI, generate stop condition */
  67               		.loc 1 27 0
  68 0022 84E9      		ldi r24,lo8(-108)
  69 0024 8093 BC00 		sts 188,r24
  70               	.LVL0:
  71               	.LBB14:
  72               	.LBB15:
  73               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  74               		.loc 2 276 0
  75 0028 8FE8      		ldi r24,lo8(399)
  76 002a 91E0      		ldi r25,hi8(399)
  77 002c 0197      	1:	sbiw r24,1
  78 002e 01F4      		brne 1b
  79 0030 00C0      		rjmp .
  80 0032 0000      		nop
  81               	.LVL1:
  82 0034 0895      		ret
  83               	.LBE15:
  84               	.LBE14:
  85               		.cfi_endproc
  86               	.LFE8:
  88               	.global	I2C_Write
  90               	I2C_Write:
  91               	.LFB9:
  28:i2c.h         ****     _delay_us(100);
  29:i2c.h         **** }
  30:i2c.h         **** 
  31:i2c.h         **** uint8_t I2C_Write(uint8_t data) {
  92               		.loc 1 31 0
  93               		.cfi_startproc
  94               	.LVL2:
  95               	/* prologue: function */
  96               	/* frame size = 0 */
  97               	/* stack size = 0 */
  98               	.L__stack_usage = 0
  32:i2c.h         ****     TWDR = data;              /* Copy data to TWI data register */
  99               		.loc 1 32 0
 100 0036 8093 BB00 		sts 187,r24
  33:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWEN); /* Enable TWI and clear interrupt flag */
 101               		.loc 1 33 0
 102 003a 84E8      		ldi r24,lo8(-124)
 103               	.LVL3:
 104 003c 8093 BC00 		sts 188,r24
 105               	.LVL4:
 106               	.L8:
  34:i2c.h         ****     while (!(TWCR & (1<<TWINT)));  /* Wait for TWINT flag to set */
 107               		.loc 1 34 0 discriminator 1
 108 0040 8091 BC00 		lds r24,188
 109 0044 87FF      		sbrs r24,7
 110 0046 00C0      		rjmp .L8
  35:i2c.h         ****     
  36:i2c.h         ****     // Check status
  37:i2c.h         ****     uint8_t status = TWSR & 0xF8;
 111               		.loc 1 37 0
 112 0048 9091 B900 		lds r25,185
 113 004c 987F      		andi r25,lo8(-8)
 114               	.LVL5:
  38:i2c.h         ****     if (status == 0x28 || status == 0x18) { /* 0x28 = TW_MT_DATA_ACK, 0x18 = TW_MT_SLA_ACK */
 115               		.loc 1 38 0
 116 004e 9832      		cpi r25,lo8(40)
 117 0050 01F0      		breq .L11
  39:i2c.h         ****         return 0;  // ACK received
 118               		.loc 1 39 0 discriminator 1
 119 0052 81E0      		ldi r24,lo8(1)
 120 0054 9831      		cpi r25,lo8(24)
 121 0056 01F4      		brne .L9
 122               	.L11:
 123               		.loc 1 39 0 is_stmt 0
 124 0058 80E0      		ldi r24,0
 125               	.L9:
  40:i2c.h         ****     } else {
  41:i2c.h         ****         return 1;  // NACK or error
  42:i2c.h         ****     }
  43:i2c.h         **** }
 126               		.loc 1 43 0 is_stmt 1
 127 005a 0895      		ret
 128               		.cfi_endproc
 129               	.LFE9:
 131               	.global	LCD_EnablePulse
 133               	LCD_EnablePulse:
 134               	.LFB10:
  44:i2c.h         **** 
  45:i2c.h         **** /* LCD Functions */
  46:i2c.h         **** void LCD_EnablePulse(uint8_t data) {
 135               		.loc 1 46 0
 136               		.cfi_startproc
 137               	.LVL6:
 138 005c CF93      		push r28
 139               	.LCFI0:
 140               		.cfi_def_cfa_offset 3
 141               		.cfi_offset 28, -2
 142               	/* prologue: function */
 143               	/* frame size = 0 */
 144               	/* stack size = 1 */
 145               	.L__stack_usage = 1
 146 005e C82F      		mov r28,r24
  47:i2c.h         ****     I2C_Write(data | ENABLE);  /* Enable bit high */
 147               		.loc 1 47 0
 148 0060 8460      		ori r24,lo8(4)
 149               	.LVL7:
 150 0062 0E94 0000 		call I2C_Write
 151               	.LVL8:
 152               	.LBB16:
 153               	.LBB17:
 154               		.loc 2 276 0
 155 0066 85E0      		ldi r24,lo8(5)
 156 0068 8A95      	1:	dec r24
 157 006a 01F4      		brne 1b
 158 006c 0000      		nop
 159               	.LVL9:
 160               	.LBE17:
 161               	.LBE16:
  48:i2c.h         ****     _delay_us(1);              /* Enable pulse width */
  49:i2c.h         ****     I2C_Write(data & ~ENABLE); /* Enable bit low */
 162               		.loc 1 49 0
 163 006e 8C2F      		mov r24,r28
 164 0070 8B7F      		andi r24,lo8(-5)
 165 0072 0E94 0000 		call I2C_Write
 166               	.LVL10:
 167               	.LBB18:
 168               	.LBB19:
 187:/usr/lib/avr/include/util/delay.h **** 
 169               		.loc 2 187 0
 170 0076 8FE3      		ldi r24,lo8(7999)
 171 0078 9FE1      		ldi r25,hi8(7999)
 172 007a 0197      	1:	sbiw r24,1
 173 007c 01F4      		brne 1b
 174 007e 00C0      		rjmp .
 175 0080 0000      		nop
 176               	.LVL11:
 177               	/* epilogue start */
 178               	.LBE19:
 179               	.LBE18:
  50:i2c.h         ****     _delay_ms(2);              /* Wait for the command to execute */
  51:i2c.h         **** }
 180               		.loc 1 51 0
 181 0082 CF91      		pop r28
 182               	.LVL12:
 183 0084 0895      		ret
 184               		.cfi_endproc
 185               	.LFE10:
 187               	.global	LCD_Command
 189               	LCD_Command:
 190               	.LFB11:
  52:i2c.h         **** 
  53:i2c.h         **** void LCD_Command(uint8_t cmnd) {
 191               		.loc 1 53 0
 192               		.cfi_startproc
 193               	.LVL13:
 194 0086 CF93      		push r28
 195               	.LCFI1:
 196               		.cfi_def_cfa_offset 3
 197               		.cfi_offset 28, -2
 198               	/* prologue: function */
 199               	/* frame size = 0 */
 200               	/* stack size = 1 */
 201               	.L__stack_usage = 1
 202 0088 C82F      		mov r28,r24
 203               	.LVL14:
  54:i2c.h         ****     uint8_t highNibble = (cmnd & 0xF0) | LCD_BACKLIGHT;
  55:i2c.h         ****     uint8_t lowNibble = ((cmnd << 4) & 0xF0) | LCD_BACKLIGHT;
  56:i2c.h         **** 
  57:i2c.h         ****     I2C_Start();
 204               		.loc 1 57 0
 205 008a 0E94 0000 		call I2C_Start
 206               	.LVL15:
  58:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 207               		.loc 1 58 0
 208 008e 8EE4      		ldi r24,lo8(78)
 209 0090 0E94 0000 		call I2C_Write
 210               	.LVL16:
  59:i2c.h         ****     
  60:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble */
 211               		.loc 1 60 0
 212 0094 8C2F      		mov r24,r28
 213 0096 807F      		andi r24,lo8(-16)
 214 0098 8860      		ori r24,lo8(8)
 215               	.LVL17:
 216 009a 0E94 0000 		call LCD_EnablePulse
 217               	.LVL18:
  61:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble */
 218               		.loc 1 61 0
 219 009e 20E1      		ldi r18,lo8(16)
 220 00a0 C29F      		mul r28,r18
 221 00a2 C001      		movw r24,r0
 222 00a4 1124      		clr __zero_reg__
 223 00a6 8860      		ori r24,lo8(8)
 224 00a8 0E94 0000 		call LCD_EnablePulse
 225               	.LVL19:
 226               	/* epilogue start */
  62:i2c.h         ****     
  63:i2c.h         ****     I2C_Stop();
  64:i2c.h         **** }
 227               		.loc 1 64 0
 228 00ac CF91      		pop r28
 229               	.LVL20:
  63:i2c.h         **** }
 230               		.loc 1 63 0
 231 00ae 0C94 0000 		jmp I2C_Stop
 232               	.LVL21:
 233               		.cfi_endproc
 234               	.LFE11:
 236               	.global	LCD_Char
 238               	LCD_Char:
 239               	.LFB12:
  65:i2c.h         **** 
  66:i2c.h         **** void LCD_Char(uint8_t data) {
 240               		.loc 1 66 0
 241               		.cfi_startproc
 242               	.LVL22:
 243 00b2 CF93      		push r28
 244               	.LCFI2:
 245               		.cfi_def_cfa_offset 3
 246               		.cfi_offset 28, -2
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 1 */
 250               	.L__stack_usage = 1
 251 00b4 C82F      		mov r28,r24
 252               	.LVL23:
  67:i2c.h         ****     uint8_t highNibble = (data & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  68:i2c.h         ****     uint8_t lowNibble = ((data << 4) & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  69:i2c.h         **** 
  70:i2c.h         ****     I2C_Start();
 253               		.loc 1 70 0
 254 00b6 0E94 0000 		call I2C_Start
 255               	.LVL24:
  71:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 256               		.loc 1 71 0
 257 00ba 8EE4      		ldi r24,lo8(78)
 258 00bc 0E94 0000 		call I2C_Write
 259               	.LVL25:
  72:i2c.h         ****     
  73:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble with RS=1 for data */
 260               		.loc 1 73 0
 261 00c0 8C2F      		mov r24,r28
 262 00c2 807F      		andi r24,lo8(-16)
 263 00c4 8960      		ori r24,lo8(9)
 264               	.LVL26:
 265 00c6 0E94 0000 		call LCD_EnablePulse
 266               	.LVL27:
  74:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble with RS=1 */
 267               		.loc 1 74 0
 268 00ca 20E1      		ldi r18,lo8(16)
 269 00cc C29F      		mul r28,r18
 270 00ce C001      		movw r24,r0
 271 00d0 1124      		clr __zero_reg__
 272 00d2 8960      		ori r24,lo8(9)
 273 00d4 0E94 0000 		call LCD_EnablePulse
 274               	.LVL28:
 275               	/* epilogue start */
  75:i2c.h         ****     
  76:i2c.h         ****     I2C_Stop();
  77:i2c.h         **** }
 276               		.loc 1 77 0
 277 00d8 CF91      		pop r28
 278               	.LVL29:
  76:i2c.h         **** }
 279               		.loc 1 76 0
 280 00da 0C94 0000 		jmp I2C_Stop
 281               	.LVL30:
 282               		.cfi_endproc
 283               	.LFE12:
 285               	.global	LCD_Init
 287               	LCD_Init:
 288               	.LFB13:
  78:i2c.h         **** 
  79:i2c.h         **** void LCD_Init(void) {
 289               		.loc 1 79 0
 290               		.cfi_startproc
 291               	/* prologue: function */
 292               	/* frame size = 0 */
 293               	/* stack size = 0 */
 294               	.L__stack_usage = 0
  80:i2c.h         ****     I2C_Init();                /* Initialize I2C */
 295               		.loc 1 80 0
 296 00de 0E94 0000 		call I2C_Init
 297               	.LVL31:
 298               	.LBB20:
 299               	.LBB21:
 187:/usr/lib/avr/include/util/delay.h **** 
 300               		.loc 2 187 0
 301 00e2 2FEF      		ldi r18,lo8(63999)
 302 00e4 89EF      		ldi r24,hi8(63999)
 303 00e6 90E0      		ldi r25,hlo8(63999)
 304 00e8 2150      	1:	subi r18,1
 305 00ea 8040      		sbci r24,0
 306 00ec 9040      		sbci r25,0
 307 00ee 01F4      		brne 1b
 308 00f0 00C0      		rjmp .
 309 00f2 0000      		nop
 310               	.LVL32:
 311               	.LBE21:
 312               	.LBE20:
  81:i2c.h         ****     _delay_ms(20);             /* LCD Power ON delay */
  82:i2c.h         ****     
  83:i2c.h         ****     LCD_Command(0x02);         /* Initialize for 4-bit mode */
 313               		.loc 1 83 0
 314 00f4 82E0      		ldi r24,lo8(2)
 315 00f6 0E94 0000 		call LCD_Command
 316               	.LVL33:
  84:i2c.h         ****     LCD_Command(0x28);         /* 2 lines, 5x7 matrix in 4-bit mode */
 317               		.loc 1 84 0
 318 00fa 88E2      		ldi r24,lo8(40)
 319 00fc 0E94 0000 		call LCD_Command
 320               	.LVL34:
  85:i2c.h         ****     LCD_Command(0x0C);         /* Display ON, Cursor OFF */
 321               		.loc 1 85 0
 322 0100 8CE0      		ldi r24,lo8(12)
 323 0102 0E94 0000 		call LCD_Command
 324               	.LVL35:
  86:i2c.h         ****     LCD_Command(0x06);         /* Auto increment cursor */
 325               		.loc 1 86 0
 326 0106 86E0      		ldi r24,lo8(6)
 327 0108 0E94 0000 		call LCD_Command
 328               	.LVL36:
  87:i2c.h         ****     LCD_Command(0x01);         /* Clear display */
 329               		.loc 1 87 0
 330 010c 81E0      		ldi r24,lo8(1)
 331 010e 0E94 0000 		call LCD_Command
 332               	.LVL37:
 333               	.LBB22:
 334               	.LBB23:
 187:/usr/lib/avr/include/util/delay.h **** 
 335               		.loc 2 187 0
 336 0112 8FE3      		ldi r24,lo8(7999)
 337 0114 9FE1      		ldi r25,hi8(7999)
 338 0116 0197      	1:	sbiw r24,1
 339 0118 01F4      		brne 1b
 340 011a 00C0      		rjmp .
 341 011c 0000      		nop
 342               	.LVL38:
 343 011e 0895      		ret
 344               	.LBE23:
 345               	.LBE22:
 346               		.cfi_endproc
 347               	.LFE13:
 349               	.global	LCD_SetCursor
 351               	LCD_SetCursor:
 352               	.LFB14:
  88:i2c.h         ****     _delay_ms(2);
  89:i2c.h         **** }
  90:i2c.h         **** 
  91:i2c.h         **** void LCD_SetCursor(uint8_t row, uint8_t col) {
 353               		.loc 1 91 0
 354               		.cfi_startproc
 355               	.LVL39:
 356               	/* prologue: function */
 357               	/* frame size = 0 */
 358               	/* stack size = 0 */
 359               	.L__stack_usage = 0
  92:i2c.h         ****     uint8_t address;
  93:i2c.h         ****     if (row == 0) {
 360               		.loc 1 93 0
 361 0120 8111      		cpse r24,__zero_reg__
 362 0122 00C0      		rjmp .L18
  94:i2c.h         ****         address = 0x80 + col; // Move to column of row 0
 363               		.loc 1 94 0
 364 0124 80E8      		ldi r24,lo8(-128)
 365               	.LVL40:
 366 0126 00C0      		rjmp .L20
 367               	.LVL41:
 368               	.L18:
  95:i2c.h         ****     } else {
  96:i2c.h         ****         address = 0xC0 + col; // Move to column of row 1
 369               		.loc 1 96 0
 370 0128 80EC      		ldi r24,lo8(-64)
 371               	.LVL42:
 372               	.L20:
 373 012a 860F      		add r24,r22
 374               	.LVL43:
  97:i2c.h         ****     }
  98:i2c.h         ****     LCD_Command(address);  // Send command to move the cursor
 375               		.loc 1 98 0
 376 012c 0C94 0000 		jmp LCD_Command
 377               	.LVL44:
 378               		.cfi_endproc
 379               	.LFE14:
 381               	.global	LCD_String
 383               	LCD_String:
 384               	.LFB15:
  99:i2c.h         **** }
 100:i2c.h         **** 
 101:i2c.h         **** void LCD_String(char *str) {
 385               		.loc 1 101 0
 386               		.cfi_startproc
 387               	.LVL45:
 388 0130 CF93      		push r28
 389               	.LCFI3:
 390               		.cfi_def_cfa_offset 3
 391               		.cfi_offset 28, -2
 392 0132 DF93      		push r29
 393               	.LCFI4:
 394               		.cfi_def_cfa_offset 4
 395               		.cfi_offset 29, -3
 396               	/* prologue: function */
 397               	/* frame size = 0 */
 398               	/* stack size = 2 */
 399               	.L__stack_usage = 2
 400 0134 EC01      		movw r28,r24
 401               	.LVL46:
 402               	.L22:
 102:i2c.h         ****     while (*str) {
 403               		.loc 1 102 0
 404 0136 8991      		ld r24,Y+
 405               	.LVL47:
 406 0138 8823      		tst r24
 407 013a 01F0      		breq .L24
 408               	.LVL48:
 103:i2c.h         ****         LCD_Char(*str++);
 409               		.loc 1 103 0
 410 013c 0E94 0000 		call LCD_Char
 411               	.LVL49:
 412 0140 00C0      		rjmp .L22
 413               	.LVL50:
 414               	.L24:
 415               	/* epilogue start */
 104:i2c.h         ****     }
 105:i2c.h         **** }
 416               		.loc 1 105 0
 417 0142 DF91      		pop r29
 418 0144 CF91      		pop r28
 419               	.LVL51:
 420 0146 0895      		ret
 421               		.cfi_endproc
 422               	.LFE15:
 424               	.global	LCD_Clear
 426               	LCD_Clear:
 427               	.LFB16:
 106:i2c.h         **** 
 107:i2c.h         **** void LCD_Clear(void) {
 428               		.loc 1 107 0
 429               		.cfi_startproc
 430               	/* prologue: function */
 431               	/* frame size = 0 */
 432               	/* stack size = 0 */
 433               	.L__stack_usage = 0
 108:i2c.h         ****     LCD_Command(0x01);  // 0x01 is the command to clear the display
 434               		.loc 1 108 0
 435 0148 81E0      		ldi r24,lo8(1)
 436 014a 0E94 0000 		call LCD_Command
 437               	.LVL52:
 438               	.LBB24:
 439               	.LBB25:
 187:/usr/lib/avr/include/util/delay.h **** 
 440               		.loc 2 187 0
 441 014e 8FE3      		ldi r24,lo8(7999)
 442 0150 9FE1      		ldi r25,hi8(7999)
 443 0152 0197      	1:	sbiw r24,1
 444 0154 01F4      		brne 1b
 445 0156 00C0      		rjmp .
 446 0158 0000      		nop
 447               	.LVL53:
 448 015a 0895      		ret
 449               	.LBE25:
 450               	.LBE24:
 451               		.cfi_endproc
 452               	.LFE16:
 454               		.section	.rodata.str1.1,"aMS",@progbits,1
 455               	.LC0:
 456 0000 5661 6C75 		.string	"Value: "
 456      653A 2000 
 457               	.LC1:
 458 0008 3030 3000 		.string	"000"
 459               		.text
 460               	.global	setup
 462               	setup:
 463               	.LFB17:
 464               		.file 3 "led.c"
   1:led.c         **** #include <avr/io.h>
   2:led.c         **** #include <avr/interrupt.h>
   3:led.c         **** #include "i2c.h" // Make sure to include the LCD driver library (you should have this configured fo
   4:led.c         **** 
   5:led.c         **** #define encClk PD2  // Rotary encoder CLK
   6:led.c         **** #define encButton PD3 // Rotary encoder button
   7:led.c         **** #define encQuad PD4  // Rotary encoder Quadrature pin
   8:led.c         **** 
   9:led.c         **** volatile int decCount = 0;
  10:led.c         **** volatile int onesCount = 0;
  11:led.c         **** volatile int tensCount = 0;
  12:led.c         **** 
  13:led.c         **** void setup() {
 465               		.loc 3 13 0
 466               		.cfi_startproc
 467               	/* prologue: function */
 468               	/* frame size = 0 */
 469               	/* stack size = 0 */
 470               	.L__stack_usage = 0
  14:led.c         ****     // Set up pins for rotary encoder
  15:led.c         ****     DDRD &= ~(1 << encClk);   // Set encClk as input
 471               		.loc 3 15 0
 472 015c 5298      		cbi 0xa,2
  16:led.c         ****     DDRD &= ~(1 << encButton); // Set encButton as input
 473               		.loc 3 16 0
 474 015e 5398      		cbi 0xa,3
  17:led.c         ****     DDRD &= ~(1 << encQuad);  // Set encQuad as input
 475               		.loc 3 17 0
 476 0160 5498      		cbi 0xa,4
  18:led.c         ****     PORTD |= (1 << encClk) | (1 << encButton) | (1 << encQuad); // Enable internal pull-up resistor
 477               		.loc 3 18 0
 478 0162 8BB1      		in r24,0xb
 479 0164 8C61      		ori r24,lo8(28)
 480 0166 8BB9      		out 0xb,r24
  19:led.c         **** 
  20:led.c         ****     // Set up interrupts
  21:led.c         ****     EICRA |= (1 << ISC00);    // Set INT0 to trigger on rising edge
 481               		.loc 3 21 0
 482 0168 E9E6      		ldi r30,lo8(105)
 483 016a F0E0      		ldi r31,0
 484 016c 8081      		ld r24,Z
 485 016e 8160      		ori r24,lo8(1)
 486 0170 8083      		st Z,r24
  22:led.c         ****     EIMSK |= (1 << INT0);     // Enable external interrupt on INT0
 487               		.loc 3 22 0
 488 0172 E89A      		sbi 0x1d,0
  23:led.c         ****     sei();                    // Enable global interrupts
 489               		.loc 3 23 0
 490               	/* #APP */
 491               	 ;  23 "led.c" 1
 492 0174 7894      		sei
 493               	 ;  0 "" 2
  24:led.c         **** 
  25:led.c         ****     // Initialize LCD
  26:led.c         ****     lcd_init();               // Initialize the LCD
 494               		.loc 3 26 0
 495               	/* #NOAPP */
 496 0176 0E94 0000 		call lcd_init
 497               	.LVL54:
  27:led.c         ****     lcd_clear();
 498               		.loc 3 27 0
 499 017a 0E94 0000 		call lcd_clear
 500               	.LVL55:
  28:led.c         ****     lcd_gotoxy(0, 0);
 501               		.loc 3 28 0
 502 017e 60E0      		ldi r22,0
 503 0180 70E0      		ldi r23,0
 504 0182 80E0      		ldi r24,0
 505 0184 90E0      		ldi r25,0
 506 0186 0E94 0000 		call lcd_gotoxy
 507               	.LVL56:
  29:led.c         ****     lcd_puts("Value: ");      // Display static label
 508               		.loc 3 29 0
 509 018a 80E0      		ldi r24,lo8(.LC0)
 510 018c 90E0      		ldi r25,hi8(.LC0)
 511 018e 0E94 0000 		call lcd_puts
 512               	.LVL57:
  30:led.c         **** 
  31:led.c         ****     lcd_gotoxy(0, 1);
 513               		.loc 3 31 0
 514 0192 61E0      		ldi r22,lo8(1)
 515 0194 70E0      		ldi r23,0
 516 0196 80E0      		ldi r24,0
 517 0198 90E0      		ldi r25,0
 518 019a 0E94 0000 		call lcd_gotoxy
 519               	.LVL58:
  32:led.c         ****     lcd_puts("000");          // Initialize value display with "000"
 520               		.loc 3 32 0
 521 019e 80E0      		ldi r24,lo8(.LC1)
 522 01a0 90E0      		ldi r25,hi8(.LC1)
 523 01a2 0C94 0000 		jmp lcd_puts
 524               	.LVL59:
 525               		.cfi_endproc
 526               	.LFE17:
 528               	.global	loop
 530               	loop:
 531               	.LFB18:
  33:led.c         **** }
  34:led.c         **** 
  35:led.c         **** void loop() {
 532               		.loc 3 35 0
 533               		.cfi_startproc
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 0 */
 537               	.L__stack_usage = 0
 538 01a6 0895      		ret
 539               		.cfi_endproc
 540               	.LFE18:
 542               	.global	countUp
 544               	countUp:
 545               	.LFB20:
  36:led.c         ****     // Loop does nothing, everything is handled by interrupts
  37:led.c         **** }
  38:led.c         **** 
  39:led.c         **** ISR(INT0_vect) {
  40:led.c         ****     // Rotary encoder ISR for count up/down
  41:led.c         ****     if (PIND & (1 << encClk)) {  // If CLK is HIGH
  42:led.c         ****         if (PIND & (1 << encQuad)) {
  43:led.c         ****             countUp();
  44:led.c         ****         } else {
  45:led.c         ****             countDown();
  46:led.c         ****         }
  47:led.c         ****     } else {
  48:led.c         ****         if (PIND & (1 << encQuad)) {
  49:led.c         ****             countDown();
  50:led.c         ****         } else {
  51:led.c         ****             countUp();
  52:led.c         ****         }
  53:led.c         ****     }
  54:led.c         ****     updateDisplay(); // Update the display whenever the encoder is turned
  55:led.c         **** }
  56:led.c         **** 
  57:led.c         **** void countUp(void) {
 546               		.loc 3 57 0
 547               		.cfi_startproc
 548               	/* prologue: function */
 549               	/* frame size = 0 */
 550               	/* stack size = 0 */
 551               	.L__stack_usage = 0
  58:led.c         ****     decCount++;
 552               		.loc 3 58 0
 553 01a8 8091 0000 		lds r24,decCount
 554 01ac 9091 0000 		lds r25,decCount+1
 555 01b0 0196      		adiw r24,1
 556 01b2 9093 0000 		sts decCount+1,r25
 557 01b6 8093 0000 		sts decCount,r24
  59:led.c         ****     if (decCount > 9) {
 558               		.loc 3 59 0
 559 01ba 8091 0000 		lds r24,decCount
 560 01be 9091 0000 		lds r25,decCount+1
 561 01c2 0A97      		sbiw r24,10
 562 01c4 04F0      		brlt .L29
  60:led.c         ****         decCount = 0;
 563               		.loc 3 60 0
 564 01c6 1092 0000 		sts decCount+1,__zero_reg__
 565 01ca 1092 0000 		sts decCount,__zero_reg__
  61:led.c         ****         onesCount++;
 566               		.loc 3 61 0
 567 01ce 8091 0000 		lds r24,onesCount
 568 01d2 9091 0000 		lds r25,onesCount+1
 569 01d6 0196      		adiw r24,1
 570 01d8 9093 0000 		sts onesCount+1,r25
 571 01dc 8093 0000 		sts onesCount,r24
 572               	.L29:
  62:led.c         ****     }
  63:led.c         ****     if (onesCount > 9) {
 573               		.loc 3 63 0
 574 01e0 8091 0000 		lds r24,onesCount
 575 01e4 9091 0000 		lds r25,onesCount+1
 576 01e8 0A97      		sbiw r24,10
 577 01ea 04F0      		brlt .L30
  64:led.c         ****         onesCount = 0;
 578               		.loc 3 64 0
 579 01ec 1092 0000 		sts onesCount+1,__zero_reg__
 580 01f0 1092 0000 		sts onesCount,__zero_reg__
  65:led.c         ****         tensCount++;
 581               		.loc 3 65 0
 582 01f4 8091 0000 		lds r24,tensCount
 583 01f8 9091 0000 		lds r25,tensCount+1
 584 01fc 0196      		adiw r24,1
 585 01fe 9093 0000 		sts tensCount+1,r25
 586 0202 8093 0000 		sts tensCount,r24
 587               	.L30:
  66:led.c         ****     }
  67:led.c         ****     if (tensCount > 9) {
 588               		.loc 3 67 0
 589 0206 8091 0000 		lds r24,tensCount
 590 020a 9091 0000 		lds r25,tensCount+1
 591 020e 0A97      		sbiw r24,10
 592 0210 04F0      		brlt .L28
  68:led.c         ****         tensCount = 0;
 593               		.loc 3 68 0
 594 0212 1092 0000 		sts tensCount+1,__zero_reg__
 595 0216 1092 0000 		sts tensCount,__zero_reg__
 596               	.L28:
 597 021a 0895      		ret
 598               		.cfi_endproc
 599               	.LFE20:
 601               	.global	countDown
 603               	countDown:
 604               	.LFB21:
  69:led.c         ****     }
  70:led.c         **** }
  71:led.c         **** 
  72:led.c         **** void countDown(void) {
 605               		.loc 3 72 0
 606               		.cfi_startproc
 607               	/* prologue: function */
 608               	/* frame size = 0 */
 609               	/* stack size = 0 */
 610               	.L__stack_usage = 0
  73:led.c         ****     decCount--;
 611               		.loc 3 73 0
 612 021c 8091 0000 		lds r24,decCount
 613 0220 9091 0000 		lds r25,decCount+1
 614 0224 0197      		sbiw r24,1
 615 0226 9093 0000 		sts decCount+1,r25
 616 022a 8093 0000 		sts decCount,r24
  74:led.c         ****     if (decCount < 0) {
 617               		.loc 3 74 0
 618 022e 8091 0000 		lds r24,decCount
 619 0232 9091 0000 		lds r25,decCount+1
 620 0236 97FF      		sbrs r25,7
 621 0238 00C0      		rjmp .L33
  75:led.c         ****         decCount = 9;
 622               		.loc 3 75 0
 623 023a 89E0      		ldi r24,lo8(9)
 624 023c 90E0      		ldi r25,0
 625 023e 9093 0000 		sts decCount+1,r25
 626 0242 8093 0000 		sts decCount,r24
  76:led.c         ****         onesCount--;
 627               		.loc 3 76 0
 628 0246 8091 0000 		lds r24,onesCount
 629 024a 9091 0000 		lds r25,onesCount+1
 630 024e 0197      		sbiw r24,1
 631 0250 9093 0000 		sts onesCount+1,r25
 632 0254 8093 0000 		sts onesCount,r24
 633               	.L33:
  77:led.c         ****     }
  78:led.c         ****     if (onesCount < 0) {
 634               		.loc 3 78 0
 635 0258 8091 0000 		lds r24,onesCount
 636 025c 9091 0000 		lds r25,onesCount+1
 637 0260 97FF      		sbrs r25,7
 638 0262 00C0      		rjmp .L34
  79:led.c         ****         onesCount = 9;
 639               		.loc 3 79 0
 640 0264 89E0      		ldi r24,lo8(9)
 641 0266 90E0      		ldi r25,0
 642 0268 9093 0000 		sts onesCount+1,r25
 643 026c 8093 0000 		sts onesCount,r24
  80:led.c         ****         tensCount--;
 644               		.loc 3 80 0
 645 0270 8091 0000 		lds r24,tensCount
 646 0274 9091 0000 		lds r25,tensCount+1
 647 0278 0197      		sbiw r24,1
 648 027a 9093 0000 		sts tensCount+1,r25
 649 027e 8093 0000 		sts tensCount,r24
 650               	.L34:
  81:led.c         ****     }
  82:led.c         ****     if (tensCount < 0) {
 651               		.loc 3 82 0
 652 0282 8091 0000 		lds r24,tensCount
 653 0286 9091 0000 		lds r25,tensCount+1
 654 028a 97FF      		sbrs r25,7
 655 028c 00C0      		rjmp .L32
  83:led.c         ****         tensCount = 9;
 656               		.loc 3 83 0
 657 028e 89E0      		ldi r24,lo8(9)
 658 0290 90E0      		ldi r25,0
 659 0292 9093 0000 		sts tensCount+1,r25
 660 0296 8093 0000 		sts tensCount,r24
 661               	.L32:
 662 029a 0895      		ret
 663               		.cfi_endproc
 664               	.LFE21:
 666               		.section	.rodata.str1.1
 667               	.LC2:
 668 000c 2564 2564 		.string	"%d%d%d"
 668      2564 00
 669               		.text
 670               	.global	updateDisplay
 672               	updateDisplay:
 673               	.LFB22:
  84:led.c         ****     }
  85:led.c         **** }
  86:led.c         **** 
  87:led.c         **** void updateDisplay(void) {
 674               		.loc 3 87 0
 675               		.cfi_startproc
 676 029c 0F93      		push r16
 677               	.LCFI5:
 678               		.cfi_def_cfa_offset 3
 679               		.cfi_offset 16, -2
 680 029e 1F93      		push r17
 681               	.LCFI6:
 682               		.cfi_def_cfa_offset 4
 683               		.cfi_offset 17, -3
 684 02a0 CF93      		push r28
 685               	.LCFI7:
 686               		.cfi_def_cfa_offset 5
 687               		.cfi_offset 28, -4
 688 02a2 DF93      		push r29
 689               	.LCFI8:
 690               		.cfi_def_cfa_offset 6
 691               		.cfi_offset 29, -5
 692 02a4 00D0      		rcall .
 693 02a6 00D0      		rcall .
 694               	.LCFI9:
 695               		.cfi_def_cfa_offset 10
 696 02a8 CDB7      		in r28,__SP_L__
 697 02aa DEB7      		in r29,__SP_H__
 698               	.LCFI10:
 699               		.cfi_def_cfa_register 28
 700               	/* prologue: function */
 701               	/* frame size = 4 */
 702               	/* stack size = 8 */
 703               	.L__stack_usage = 8
  88:led.c         ****     char value[4];
  89:led.c         ****     snprintf(value, sizeof(value), "%d%d%d", tensCount, onesCount, decCount);  // Convert counts to
 704               		.loc 3 89 0
 705 02ac 4091 0000 		lds r20,decCount
 706 02b0 5091 0000 		lds r21,decCount+1
 707 02b4 2091 0000 		lds r18,onesCount
 708 02b8 3091 0000 		lds r19,onesCount+1
 709 02bc 8091 0000 		lds r24,tensCount
 710 02c0 9091 0000 		lds r25,tensCount+1
 711 02c4 5F93      		push r21
 712 02c6 4F93      		push r20
 713 02c8 3F93      		push r19
 714 02ca 2F93      		push r18
 715 02cc 9F93      		push r25
 716 02ce 8F93      		push r24
 717 02d0 80E0      		ldi r24,lo8(.LC2)
 718 02d2 90E0      		ldi r25,hi8(.LC2)
 719 02d4 9F93      		push r25
 720 02d6 8F93      		push r24
 721 02d8 1F92      		push __zero_reg__
 722 02da 84E0      		ldi r24,lo8(4)
 723 02dc 8F93      		push r24
 724 02de 8E01      		movw r16,r28
 725 02e0 0F5F      		subi r16,-1
 726 02e2 1F4F      		sbci r17,-1
 727 02e4 1F93      		push r17
 728 02e6 0F93      		push r16
 729 02e8 0E94 0000 		call snprintf
 730               	.LVL60:
  90:led.c         **** 
  91:led.c         ****     lcd_gotoxy(0, 1);          // Move to the second row
 731               		.loc 3 91 0
 732 02ec 61E0      		ldi r22,lo8(1)
 733 02ee 70E0      		ldi r23,0
 734 02f0 80E0      		ldi r24,0
 735 02f2 90E0      		ldi r25,0
 736 02f4 0E94 0000 		call lcd_gotoxy
 737               	.LVL61:
  92:led.c         ****     lcd_puts(value);           // Display the updated value
 738               		.loc 3 92 0
 739 02f8 C801      		movw r24,r16
 740 02fa 0E94 0000 		call lcd_puts
 741               	.LVL62:
  93:led.c         **** }
 742               		.loc 3 93 0
 743 02fe 0FB6      		in __tmp_reg__,__SREG__
 744 0300 F894      		cli
 745 0302 DEBF      		out __SP_H__,r29
 746 0304 0FBE      		out __SREG__,__tmp_reg__
 747 0306 CDBF      		out __SP_L__,r28
 748               	/* epilogue start */
 749 0308 0F90      		pop __tmp_reg__
 750 030a 0F90      		pop __tmp_reg__
 751 030c 0F90      		pop __tmp_reg__
 752 030e 0F90      		pop __tmp_reg__
 753 0310 DF91      		pop r29
 754 0312 CF91      		pop r28
 755 0314 1F91      		pop r17
 756 0316 0F91      		pop r16
 757 0318 0895      		ret
 758               		.cfi_endproc
 759               	.LFE22:
 761               	.global	__vector_1
 763               	__vector_1:
 764               	.LFB19:
  39:led.c         ****     // Rotary encoder ISR for count up/down
 765               		.loc 3 39 0
 766               		.cfi_startproc
 767 031a 1F92      		push r1
 768               	.LCFI11:
 769               		.cfi_def_cfa_offset 3
 770               		.cfi_offset 1, -2
 771 031c 0F92      		push r0
 772               	.LCFI12:
 773               		.cfi_def_cfa_offset 4
 774               		.cfi_offset 0, -3
 775 031e 0FB6      		in r0,__SREG__
 776 0320 0F92      		push r0
 777 0322 1124      		clr __zero_reg__
 778 0324 2F93      		push r18
 779               	.LCFI13:
 780               		.cfi_def_cfa_offset 5
 781               		.cfi_offset 18, -4
 782 0326 3F93      		push r19
 783               	.LCFI14:
 784               		.cfi_def_cfa_offset 6
 785               		.cfi_offset 19, -5
 786 0328 4F93      		push r20
 787               	.LCFI15:
 788               		.cfi_def_cfa_offset 7
 789               		.cfi_offset 20, -6
 790 032a 5F93      		push r21
 791               	.LCFI16:
 792               		.cfi_def_cfa_offset 8
 793               		.cfi_offset 21, -7
 794 032c 6F93      		push r22
 795               	.LCFI17:
 796               		.cfi_def_cfa_offset 9
 797               		.cfi_offset 22, -8
 798 032e 7F93      		push r23
 799               	.LCFI18:
 800               		.cfi_def_cfa_offset 10
 801               		.cfi_offset 23, -9
 802 0330 8F93      		push r24
 803               	.LCFI19:
 804               		.cfi_def_cfa_offset 11
 805               		.cfi_offset 24, -10
 806 0332 9F93      		push r25
 807               	.LCFI20:
 808               		.cfi_def_cfa_offset 12
 809               		.cfi_offset 25, -11
 810 0334 AF93      		push r26
 811               	.LCFI21:
 812               		.cfi_def_cfa_offset 13
 813               		.cfi_offset 26, -12
 814 0336 BF93      		push r27
 815               	.LCFI22:
 816               		.cfi_def_cfa_offset 14
 817               		.cfi_offset 27, -13
 818 0338 EF93      		push r30
 819               	.LCFI23:
 820               		.cfi_def_cfa_offset 15
 821               		.cfi_offset 30, -14
 822 033a FF93      		push r31
 823               	.LCFI24:
 824               		.cfi_def_cfa_offset 16
 825               		.cfi_offset 31, -15
 826               	/* prologue: Signal */
 827               	/* frame size = 0 */
 828               	/* stack size = 15 */
 829               	.L__stack_usage = 15
  41:led.c         ****         if (PIND & (1 << encQuad)) {
 830               		.loc 3 41 0
 831 033c 4A9B      		sbis 0x9,2
 832 033e 00C0      		rjmp .L38
  42:led.c         ****             countUp();
 833               		.loc 3 42 0
 834 0340 4C9B      		sbis 0x9,4
 835 0342 00C0      		rjmp .L39
 836               	.L41:
 837               	.LBB26:
  43:led.c         ****         } else {
 838               		.loc 3 43 0
 839 0344 0E94 0000 		call countUp
 840               	.LVL63:
 841               	.LBE26:
 842 0348 00C0      		rjmp .L40
 843               	.L38:
  48:led.c         ****             countDown();
 844               		.loc 3 48 0
 845 034a 4C9B      		sbis 0x9,4
 846 034c 00C0      		rjmp .L41
 847               	.L39:
 848               	.LBB27:
  45:led.c         ****         }
 849               		.loc 3 45 0
 850 034e 0E94 0000 		call countDown
 851               	.LVL64:
 852               	.L40:
 853               	.LBE27:
  54:led.c         **** }
 854               		.loc 3 54 0
 855 0352 0E94 0000 		call updateDisplay
 856               	.LVL65:
 857               	/* epilogue start */
  55:led.c         **** 
 858               		.loc 3 55 0
 859 0356 FF91      		pop r31
 860 0358 EF91      		pop r30
 861 035a BF91      		pop r27
 862 035c AF91      		pop r26
 863 035e 9F91      		pop r25
 864 0360 8F91      		pop r24
 865 0362 7F91      		pop r23
 866 0364 6F91      		pop r22
 867 0366 5F91      		pop r21
 868 0368 4F91      		pop r20
 869 036a 3F91      		pop r19
 870 036c 2F91      		pop r18
 871 036e 0F90      		pop r0
 872 0370 0FBE      		out __SREG__,r0
 873 0372 0F90      		pop r0
 874 0374 1F90      		pop r1
 875 0376 1895      		reti
 876               		.cfi_endproc
 877               	.LFE19:
 879               	.global	tensCount
 880               		.section .bss
 883               	tensCount:
 884 0000 0000      		.zero	2
 885               	.global	onesCount
 888               	onesCount:
 889 0002 0000      		.zero	2
 890               	.global	decCount
 893               	decCount:
 894 0004 0000      		.zero	2
 895               		.text
 896               	.Letext0:
 897               		.file 4 "/usr/lib/avr/include/stdint.h"
 898               		.file 5 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 led.c
     /tmp/ccbO3v3K.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccbO3v3K.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccbO3v3K.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccbO3v3K.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccbO3v3K.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccbO3v3K.s:12     .text:0000000000000000 I2C_Init
     /tmp/ccbO3v3K.s:35     .text:0000000000000012 I2C_Start
     /tmp/ccbO3v3K.s:59     .text:0000000000000022 I2C_Stop
     /tmp/ccbO3v3K.s:90     .text:0000000000000036 I2C_Write
     /tmp/ccbO3v3K.s:133    .text:000000000000005c LCD_EnablePulse
     /tmp/ccbO3v3K.s:189    .text:0000000000000086 LCD_Command
     /tmp/ccbO3v3K.s:238    .text:00000000000000b2 LCD_Char
     /tmp/ccbO3v3K.s:287    .text:00000000000000de LCD_Init
     /tmp/ccbO3v3K.s:351    .text:0000000000000120 LCD_SetCursor
     /tmp/ccbO3v3K.s:383    .text:0000000000000130 LCD_String
     /tmp/ccbO3v3K.s:426    .text:0000000000000148 LCD_Clear
     /tmp/ccbO3v3K.s:462    .text:000000000000015c setup
     /tmp/ccbO3v3K.s:530    .text:00000000000001a6 loop
     /tmp/ccbO3v3K.s:544    .text:00000000000001a8 countUp
     /tmp/ccbO3v3K.s:893    .bss:0000000000000004 decCount
     /tmp/ccbO3v3K.s:888    .bss:0000000000000002 onesCount
     /tmp/ccbO3v3K.s:883    .bss:0000000000000000 tensCount
     /tmp/ccbO3v3K.s:603    .text:000000000000021c countDown
     /tmp/ccbO3v3K.s:672    .text:000000000000029c updateDisplay
     /tmp/ccbO3v3K.s:763    .text:000000000000031a __vector_1

UNDEFINED SYMBOLS
lcd_init
lcd_clear
lcd_gotoxy
lcd_puts
snprintf
__do_copy_data
__do_clear_bss
