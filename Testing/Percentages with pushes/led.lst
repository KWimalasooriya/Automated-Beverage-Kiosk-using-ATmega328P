   1               		.file	"led.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	I2C_Init
  12               	I2C_Init:
  13               	.LFB6:
  14               		.file 1 "i2c.h"
   1:i2c.h         **** #ifndef I2C_H
   2:i2c.h         **** #define I2C_H
   3:i2c.h         **** 
   4:i2c.h         **** #include <avr/io.h>           /* Include AVR std. library file */
   5:i2c.h         **** #include <util/delay.h>       /* Include Delay header file */
   6:i2c.h         **** 
   7:i2c.h         **** /* LCD I2C address */
   8:i2c.h         **** #define LCD_I2C_ADDRESS 0x27  /* Define I2C address of the LCD, often 0x27 or 0x3F */
   9:i2c.h         **** #define LCD_BACKLIGHT 0x08    /* Backlight control bit */
  10:i2c.h         **** #define ENABLE 0x04           /* Enable bit */
  11:i2c.h         **** #define READ_WRITE 0x02       /* Read/Write bit */
  12:i2c.h         **** #define REGISTER_SELECT 0x01  /* Register select bit */
  13:i2c.h         **** 
  14:i2c.h         **** /* I2C Functions */
  15:i2c.h         **** void I2C_Init(void) {
  15               		.loc 1 15 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  16:i2c.h         ****     TWSR = 0x00;              /* Set prescaler bits to zero */
  21               		.loc 1 16 0
  22 0000 1092 B900 		sts 185,__zero_reg__
  17:i2c.h         ****     TWBR = 0x46;              /* SCL frequency = 50kHz for F_CPU = 8MHz */
  23               		.loc 1 17 0
  24 0004 86E4      		ldi r24,lo8(70)
  25 0006 8093 B800 		sts 184,r24
  18:i2c.h         ****     TWCR = (1<<TWEN);         /* Enable TWI */
  26               		.loc 1 18 0
  27 000a 84E0      		ldi r24,lo8(4)
  28 000c 8093 BC00 		sts 188,r24
  29 0010 0895      		ret
  30               		.cfi_endproc
  31               	.LFE6:
  33               	.global	I2C_Start
  35               	I2C_Start:
  36               	.LFB7:
  19:i2c.h         **** }
  20:i2c.h         **** 
  21:i2c.h         **** void I2C_Start(void) {
  37               		.loc 1 21 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
  22:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);  /* Enable TWI, generate start condition */
  43               		.loc 1 22 0
  44 0012 84EA      		ldi r24,lo8(-92)
  45 0014 8093 BC00 		sts 188,r24
  46               	.L3:
  23:i2c.h         ****     while (!(TWCR & (1<<TWINT)));            /* Wait for TWINT flag to set */
  47               		.loc 1 23 0 discriminator 1
  48 0018 8091 BC00 		lds r24,188
  49 001c 87FF      		sbrs r24,7
  50 001e 00C0      		rjmp .L3
  51               	/* epilogue start */
  24:i2c.h         **** }
  52               		.loc 1 24 0
  53 0020 0895      		ret
  54               		.cfi_endproc
  55               	.LFE7:
  57               	.global	I2C_Stop
  59               	I2C_Stop:
  60               	.LFB8:
  25:i2c.h         **** 
  26:i2c.h         **** void I2C_Stop(void) {
  61               		.loc 1 26 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
  27:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);  /* Enable TWI, generate stop condition */
  67               		.loc 1 27 0
  68 0022 84E9      		ldi r24,lo8(-108)
  69 0024 8093 BC00 		sts 188,r24
  70               	.LVL0:
  71               	.LBB29:
  72               	.LBB30:
  73               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  74               		.loc 2 276 0
  75 0028 81E2      		ldi r24,lo8(33)
  76 002a 8A95      	1:	dec r24
  77 002c 01F4      		brne 1b
  78 002e 0000      		nop
  79               	.LVL1:
  80 0030 0895      		ret
  81               	.LBE30:
  82               	.LBE29:
  83               		.cfi_endproc
  84               	.LFE8:
  86               	.global	I2C_Write
  88               	I2C_Write:
  89               	.LFB9:
  28:i2c.h         ****     _delay_us(100);
  29:i2c.h         **** }
  30:i2c.h         **** 
  31:i2c.h         **** uint8_t I2C_Write(uint8_t data) {
  90               		.loc 1 31 0
  91               		.cfi_startproc
  92               	.LVL2:
  93               	/* prologue: function */
  94               	/* frame size = 0 */
  95               	/* stack size = 0 */
  96               	.L__stack_usage = 0
  32:i2c.h         ****     TWDR = data;              /* Copy data to TWI data register */
  97               		.loc 1 32 0
  98 0032 8093 BB00 		sts 187,r24
  33:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWEN); /* Enable TWI and clear interrupt flag */
  99               		.loc 1 33 0
 100 0036 84E8      		ldi r24,lo8(-124)
 101               	.LVL3:
 102 0038 8093 BC00 		sts 188,r24
 103               	.LVL4:
 104               	.L8:
  34:i2c.h         ****     while (!(TWCR & (1<<TWINT)));  /* Wait for TWINT flag to set */
 105               		.loc 1 34 0 discriminator 1
 106 003c 8091 BC00 		lds r24,188
 107 0040 87FF      		sbrs r24,7
 108 0042 00C0      		rjmp .L8
  35:i2c.h         ****     
  36:i2c.h         ****     // Check status
  37:i2c.h         ****     uint8_t status = TWSR & 0xF8;
 109               		.loc 1 37 0
 110 0044 9091 B900 		lds r25,185
 111 0048 987F      		andi r25,lo8(-8)
 112               	.LVL5:
  38:i2c.h         ****     if (status == 0x28 || status == 0x18) { /* 0x28 = TW_MT_DATA_ACK, 0x18 = TW_MT_SLA_ACK */
 113               		.loc 1 38 0
 114 004a 9832      		cpi r25,lo8(40)
 115 004c 01F0      		breq .L11
  39:i2c.h         ****         return 0;  // ACK received
 116               		.loc 1 39 0 discriminator 1
 117 004e 81E0      		ldi r24,lo8(1)
 118 0050 9831      		cpi r25,lo8(24)
 119 0052 01F4      		brne .L9
 120               	.L11:
 121               		.loc 1 39 0 is_stmt 0
 122 0054 80E0      		ldi r24,0
 123               	.L9:
  40:i2c.h         ****     } else {
  41:i2c.h         ****         return 1;  // NACK or error
  42:i2c.h         ****     }
  43:i2c.h         **** }
 124               		.loc 1 43 0 is_stmt 1
 125 0056 0895      		ret
 126               		.cfi_endproc
 127               	.LFE9:
 129               	.global	LCD_EnablePulse
 131               	LCD_EnablePulse:
 132               	.LFB10:
  44:i2c.h         **** 
  45:i2c.h         **** /* LCD Functions */
  46:i2c.h         **** void LCD_EnablePulse(uint8_t data) {
 133               		.loc 1 46 0
 134               		.cfi_startproc
 135               	.LVL6:
 136 0058 CF93      		push r28
 137               	.LCFI0:
 138               		.cfi_def_cfa_offset 3
 139               		.cfi_offset 28, -2
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 1 */
 143               	.L__stack_usage = 1
 144 005a C82F      		mov r28,r24
  47:i2c.h         ****     I2C_Write(data | ENABLE);  /* Enable bit high */
 145               		.loc 1 47 0
 146 005c 8460      		ori r24,lo8(4)
 147               	.LVL7:
 148 005e 0E94 0000 		call I2C_Write
 149               	.LVL8:
 150               	.LBB31:
 151               	.LBB32:
 152               		.loc 2 276 0
 153 0062 0000      		nop
 154               	.LVL9:
 155               	.LBE32:
 156               	.LBE31:
  48:i2c.h         ****     _delay_us(1);              /* Enable pulse width */
  49:i2c.h         ****     I2C_Write(data & ~ENABLE); /* Enable bit low */
 157               		.loc 1 49 0
 158 0064 8C2F      		mov r24,r28
 159 0066 8B7F      		andi r24,lo8(-5)
 160 0068 0E94 0000 		call I2C_Write
 161               	.LVL10:
 162               	.LBB33:
 163               	.LBB34:
 187:/usr/lib/avr/include/util/delay.h **** 
 164               		.loc 2 187 0
 165 006c 83EF      		ldi r24,lo8(499)
 166 006e 91E0      		ldi r25,hi8(499)
 167 0070 0197      	1:	sbiw r24,1
 168 0072 01F4      		brne 1b
 169 0074 00C0      		rjmp .
 170 0076 0000      		nop
 171               	.LVL11:
 172               	/* epilogue start */
 173               	.LBE34:
 174               	.LBE33:
  50:i2c.h         ****     _delay_ms(2);              /* Wait for the command to execute */
  51:i2c.h         **** }
 175               		.loc 1 51 0
 176 0078 CF91      		pop r28
 177               	.LVL12:
 178 007a 0895      		ret
 179               		.cfi_endproc
 180               	.LFE10:
 182               	.global	LCD_Command
 184               	LCD_Command:
 185               	.LFB11:
  52:i2c.h         **** 
  53:i2c.h         **** void LCD_Command(uint8_t cmnd) {
 186               		.loc 1 53 0
 187               		.cfi_startproc
 188               	.LVL13:
 189 007c CF93      		push r28
 190               	.LCFI1:
 191               		.cfi_def_cfa_offset 3
 192               		.cfi_offset 28, -2
 193               	/* prologue: function */
 194               	/* frame size = 0 */
 195               	/* stack size = 1 */
 196               	.L__stack_usage = 1
 197 007e C82F      		mov r28,r24
 198               	.LVL14:
  54:i2c.h         ****     uint8_t highNibble = (cmnd & 0xF0) | LCD_BACKLIGHT;
  55:i2c.h         ****     uint8_t lowNibble = ((cmnd << 4) & 0xF0) | LCD_BACKLIGHT;
  56:i2c.h         **** 
  57:i2c.h         ****     I2C_Start();
 199               		.loc 1 57 0
 200 0080 0E94 0000 		call I2C_Start
 201               	.LVL15:
  58:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 202               		.loc 1 58 0
 203 0084 8EE4      		ldi r24,lo8(78)
 204 0086 0E94 0000 		call I2C_Write
 205               	.LVL16:
  59:i2c.h         ****     
  60:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble */
 206               		.loc 1 60 0
 207 008a 8C2F      		mov r24,r28
 208 008c 807F      		andi r24,lo8(-16)
 209 008e 8860      		ori r24,lo8(8)
 210               	.LVL17:
 211 0090 0E94 0000 		call LCD_EnablePulse
 212               	.LVL18:
  61:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble */
 213               		.loc 1 61 0
 214 0094 20E1      		ldi r18,lo8(16)
 215 0096 C29F      		mul r28,r18
 216 0098 C001      		movw r24,r0
 217 009a 1124      		clr __zero_reg__
 218 009c 8860      		ori r24,lo8(8)
 219 009e 0E94 0000 		call LCD_EnablePulse
 220               	.LVL19:
 221               	/* epilogue start */
  62:i2c.h         ****     
  63:i2c.h         ****     I2C_Stop();
  64:i2c.h         **** }
 222               		.loc 1 64 0
 223 00a2 CF91      		pop r28
 224               	.LVL20:
  63:i2c.h         **** }
 225               		.loc 1 63 0
 226 00a4 0C94 0000 		jmp I2C_Stop
 227               	.LVL21:
 228               		.cfi_endproc
 229               	.LFE11:
 231               	.global	LCD_Char
 233               	LCD_Char:
 234               	.LFB12:
  65:i2c.h         **** 
  66:i2c.h         **** void LCD_Char(uint8_t data) {
 235               		.loc 1 66 0
 236               		.cfi_startproc
 237               	.LVL22:
 238 00a8 CF93      		push r28
 239               	.LCFI2:
 240               		.cfi_def_cfa_offset 3
 241               		.cfi_offset 28, -2
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 1 */
 245               	.L__stack_usage = 1
 246 00aa C82F      		mov r28,r24
 247               	.LVL23:
  67:i2c.h         ****     uint8_t highNibble = (data & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  68:i2c.h         ****     uint8_t lowNibble = ((data << 4) & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  69:i2c.h         **** 
  70:i2c.h         ****     I2C_Start();
 248               		.loc 1 70 0
 249 00ac 0E94 0000 		call I2C_Start
 250               	.LVL24:
  71:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 251               		.loc 1 71 0
 252 00b0 8EE4      		ldi r24,lo8(78)
 253 00b2 0E94 0000 		call I2C_Write
 254               	.LVL25:
  72:i2c.h         ****     
  73:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble with RS=1 for data */
 255               		.loc 1 73 0
 256 00b6 8C2F      		mov r24,r28
 257 00b8 807F      		andi r24,lo8(-16)
 258 00ba 8960      		ori r24,lo8(9)
 259               	.LVL26:
 260 00bc 0E94 0000 		call LCD_EnablePulse
 261               	.LVL27:
  74:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble with RS=1 */
 262               		.loc 1 74 0
 263 00c0 20E1      		ldi r18,lo8(16)
 264 00c2 C29F      		mul r28,r18
 265 00c4 C001      		movw r24,r0
 266 00c6 1124      		clr __zero_reg__
 267 00c8 8960      		ori r24,lo8(9)
 268 00ca 0E94 0000 		call LCD_EnablePulse
 269               	.LVL28:
 270               	/* epilogue start */
  75:i2c.h         ****     
  76:i2c.h         ****     I2C_Stop();
  77:i2c.h         **** }
 271               		.loc 1 77 0
 272 00ce CF91      		pop r28
 273               	.LVL29:
  76:i2c.h         **** }
 274               		.loc 1 76 0
 275 00d0 0C94 0000 		jmp I2C_Stop
 276               	.LVL30:
 277               		.cfi_endproc
 278               	.LFE12:
 280               	.global	LCD_Init
 282               	LCD_Init:
 283               	.LFB13:
  78:i2c.h         **** 
  79:i2c.h         **** void LCD_Init(void) {
 284               		.loc 1 79 0
 285               		.cfi_startproc
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
  80:i2c.h         ****     I2C_Init();                /* Initialize I2C */
 290               		.loc 1 80 0
 291 00d4 0E94 0000 		call I2C_Init
 292               	.LVL31:
 293               	.LBB35:
 294               	.LBB36:
 187:/usr/lib/avr/include/util/delay.h **** 
 295               		.loc 2 187 0
 296 00d8 87E8      		ldi r24,lo8(4999)
 297 00da 93E1      		ldi r25,hi8(4999)
 298 00dc 0197      	1:	sbiw r24,1
 299 00de 01F4      		brne 1b
 300 00e0 00C0      		rjmp .
 301 00e2 0000      		nop
 302               	.LVL32:
 303               	.LBE36:
 304               	.LBE35:
  81:i2c.h         ****     _delay_ms(20);             /* LCD Power ON delay */
  82:i2c.h         ****     
  83:i2c.h         ****     LCD_Command(0x02);         /* Initialize for 4-bit mode */
 305               		.loc 1 83 0
 306 00e4 82E0      		ldi r24,lo8(2)
 307 00e6 0E94 0000 		call LCD_Command
 308               	.LVL33:
  84:i2c.h         ****     LCD_Command(0x28);         /* 2 lines, 5x7 matrix in 4-bit mode */
 309               		.loc 1 84 0
 310 00ea 88E2      		ldi r24,lo8(40)
 311 00ec 0E94 0000 		call LCD_Command
 312               	.LVL34:
  85:i2c.h         ****     LCD_Command(0x0C);         /* Display ON, Cursor OFF */
 313               		.loc 1 85 0
 314 00f0 8CE0      		ldi r24,lo8(12)
 315 00f2 0E94 0000 		call LCD_Command
 316               	.LVL35:
  86:i2c.h         ****     LCD_Command(0x06);         /* Auto increment cursor */
 317               		.loc 1 86 0
 318 00f6 86E0      		ldi r24,lo8(6)
 319 00f8 0E94 0000 		call LCD_Command
 320               	.LVL36:
  87:i2c.h         ****     LCD_Command(0x01);         /* Clear display */
 321               		.loc 1 87 0
 322 00fc 81E0      		ldi r24,lo8(1)
 323 00fe 0E94 0000 		call LCD_Command
 324               	.LVL37:
 325               	.LBB37:
 326               	.LBB38:
 187:/usr/lib/avr/include/util/delay.h **** 
 327               		.loc 2 187 0
 328 0102 83EF      		ldi r24,lo8(499)
 329 0104 91E0      		ldi r25,hi8(499)
 330 0106 0197      	1:	sbiw r24,1
 331 0108 01F4      		brne 1b
 332 010a 00C0      		rjmp .
 333 010c 0000      		nop
 334               	.LVL38:
 335 010e 0895      		ret
 336               	.LBE38:
 337               	.LBE37:
 338               		.cfi_endproc
 339               	.LFE13:
 341               	.global	LCD_String
 343               	LCD_String:
 344               	.LFB14:
  88:i2c.h         ****     _delay_ms(2);
  89:i2c.h         **** }
  90:i2c.h         **** 
  91:i2c.h         **** void LCD_String(char *str) {
 345               		.loc 1 91 0
 346               		.cfi_startproc
 347               	.LVL39:
 348 0110 CF93      		push r28
 349               	.LCFI3:
 350               		.cfi_def_cfa_offset 3
 351               		.cfi_offset 28, -2
 352 0112 DF93      		push r29
 353               	.LCFI4:
 354               		.cfi_def_cfa_offset 4
 355               		.cfi_offset 29, -3
 356               	/* prologue: function */
 357               	/* frame size = 0 */
 358               	/* stack size = 2 */
 359               	.L__stack_usage = 2
 360 0114 EC01      		movw r28,r24
 361               	.LVL40:
 362               	.L18:
  92:i2c.h         ****     while (*str) {
 363               		.loc 1 92 0
 364 0116 8991      		ld r24,Y+
 365               	.LVL41:
 366 0118 8823      		tst r24
 367 011a 01F0      		breq .L20
 368               	.LVL42:
  93:i2c.h         ****         LCD_Char(*str++);
 369               		.loc 1 93 0
 370 011c 0E94 0000 		call LCD_Char
 371               	.LVL43:
 372 0120 00C0      		rjmp .L18
 373               	.LVL44:
 374               	.L20:
 375               	/* epilogue start */
  94:i2c.h         ****     }
  95:i2c.h         **** }
 376               		.loc 1 95 0
 377 0122 DF91      		pop r29
 378 0124 CF91      		pop r28
 379               	.LVL45:
 380 0126 0895      		ret
 381               		.cfi_endproc
 382               	.LFE14:
 384               	.global	LCD_Clear
 386               	LCD_Clear:
 387               	.LFB15:
  96:i2c.h         **** 
  97:i2c.h         **** void LCD_Clear(void) {
 388               		.loc 1 97 0
 389               		.cfi_startproc
 390               	/* prologue: function */
 391               	/* frame size = 0 */
 392               	/* stack size = 0 */
 393               	.L__stack_usage = 0
  98:i2c.h         ****     LCD_Command(0x01);  // 0x01 is the command to clear the display
 394               		.loc 1 98 0
 395 0128 81E0      		ldi r24,lo8(1)
 396 012a 0E94 0000 		call LCD_Command
 397               	.LVL46:
 398               	.LBB39:
 399               	.LBB40:
 187:/usr/lib/avr/include/util/delay.h **** 
 400               		.loc 2 187 0
 401 012e 83EF      		ldi r24,lo8(499)
 402 0130 91E0      		ldi r25,hi8(499)
 403 0132 0197      	1:	sbiw r24,1
 404 0134 01F4      		brne 1b
 405 0136 00C0      		rjmp .
 406 0138 0000      		nop
 407               	.LVL47:
 408 013a 0895      		ret
 409               	.LBE40:
 410               	.LBE39:
 411               		.cfi_endproc
 412               	.LFE15:
 414               	.global	setup
 416               	setup:
 417               	.LFB17:
 418               		.file 3 "led.c"
   1:led.c         **** #define F_CPU 1000000
   2:led.c         **** #include <avr/io.h>
   3:led.c         **** #include <util/delay.h>
   4:led.c         **** #include "i2c.h"  // Include the I2C LCD header file
   5:led.c         **** 
   6:led.c         **** // Function prototypes
   7:led.c         **** void setup();
   8:led.c         **** uint8_t isSwitch1Pressed();
   9:led.c         **** uint8_t isEncoderPressed();
  10:led.c         **** uint8_t isSwitch2Pressed();
  11:led.c         **** uint8_t isSwitch3Pressed();
  12:led.c         **** void displayAutoManual();
  13:led.c         **** void displayProcessing();
  14:led.c         **** void displayChoosePercentages();
  15:led.c         **** void displayFruit(char *fruit, uint8_t percentage);
  16:led.c         **** void displayExceededMessage();
  17:led.c         **** void displayOrderComplete();
  18:led.c         **** 
  19:led.c         **** // Variables
  20:led.c         **** char *fruits[] = {"PINEAPPLE", "MANGO", "APPLE", "ORANGE"};
  21:led.c         **** uint8_t fruitIndex = 0;
  22:led.c         **** uint8_t percentages[4] = {0, 0, 0, 0};  // Array to store percentages for each fruit
  23:led.c         **** uint8_t percentage = 0;
  24:led.c         **** uint8_t selectingPercentage = 0;
  25:led.c         **** 
  26:led.c         **** int main(void) {
  27:led.c         ****     uint8_t switch1State = 0;
  28:led.c         ****     uint8_t lastSwitch1State = 0;
  29:led.c         ****     uint8_t encoderSwitchState = 0;
  30:led.c         ****     uint8_t lastEncoderSwitchState = 0;
  31:led.c         **** 
  32:led.c         ****     setup();  // Initialize pins
  33:led.c         ****     LCD_Init();  // Initialize LCD
  34:led.c         **** 
  35:led.c         ****     displayAutoManual();  // Initial display
  36:led.c         **** 
  37:led.c         ****     while (1) {
  38:led.c         ****         // Check if Switch 1 (PC0) is pressed
  39:led.c         ****         switch1State = isSwitch1Pressed();
  40:led.c         **** 
  41:led.c         ****         if (switch1State && !lastSwitch1State) {
  42:led.c         ****             // Start the auto mode sequence
  43:led.c         ****             displayProcessing();
  44:led.c         ****             _delay_ms(4000);
  45:led.c         **** 
  46:led.c         ****             displayChoosePercentages();
  47:led.c         ****             _delay_ms(4000);
  48:led.c         **** 
  49:led.c         ****             LCD_Clear();
  50:led.c         ****             LCD_String("Total should not");
  51:led.c         ****             LCD_Command(0xC0);  // Move to 2nd row
  52:led.c         ****             LCD_String("exceed 100%");
  53:led.c         ****             _delay_ms(4000);
  54:led.c         **** 
  55:led.c         ****             // Start selecting percentage for the first fruit
  56:led.c         ****             fruitIndex = 0;
  57:led.c         ****             percentage = 0;
  58:led.c         ****             selectingPercentage = 1;  // Enable percentage selection
  59:led.c         ****             displayFruit(fruits[fruitIndex], percentage);
  60:led.c         ****         }
  61:led.c         ****         lastSwitch1State = switch1State;
  62:led.c         **** 
  63:led.c         ****         // Check encoder only during the percentage selection phase
  64:led.c         ****         if (selectingPercentage) {
  65:led.c         ****             // Check if Switch 2 (PC1) is pressed to increase percentage
  66:led.c         ****             if (isSwitch2Pressed() && percentage < 100) {
  67:led.c         ****                 percentage += 20;
  68:led.c         ****                 if (percentage > 100) {
  69:led.c         ****                     percentage = 100; // Cap at 100%
  70:led.c         ****                 }
  71:led.c         ****                 displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percentage
  72:led.c         ****                 _delay_ms(200);  // Debounce delay
  73:led.c         ****             }
  74:led.c         **** 
  75:led.c         ****             // Check if Switch 3 (PC2) is pressed to decrease percentage
  76:led.c         ****             if (isSwitch3Pressed() && percentage > 0) {
  77:led.c         ****                 percentage -= 20;
  78:led.c         ****                 if (percentage < 0) {
  79:led.c         ****                     percentage = 0; // Floor at 0%
  80:led.c         ****                 }
  81:led.c         ****                 displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percentage
  82:led.c         ****                 _delay_ms(200);  // Debounce delay
  83:led.c         ****             }
  84:led.c         **** 
  85:led.c         ****             // Check if the encoder button is pressed to confirm the percentage
  86:led.c         ****             encoderSwitchState = isEncoderPressed();
  87:led.c         ****             if (encoderSwitchState && !lastEncoderSwitchState) {
  88:led.c         ****                 percentages[fruitIndex] = percentage;  // Store the selected percentage
  89:led.c         ****                 fruitIndex++;  // Move to the next fruit
  90:led.c         **** 
  91:led.c         ****                 if (fruitIndex < 4) {
  92:led.c         ****                     percentage = 0;  // Reset percentage for the next fruit
  93:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Display next fruit
  94:led.c         ****                 } else {
  95:led.c         ****                     selectingPercentage = 0;  // Disable encoder
  96:led.c         **** 
  97:led.c         ****                     // Check if the total exceeds 100%
  98:led.c         ****                     uint8_t totalPercentage = percentages[0] + percentages[1] + percentages[2] + pe
  99:led.c         ****                     if (totalPercentage > 100) {
 100:led.c         ****                         displayExceededMessage();
 101:led.c         ****                         _delay_ms(3000);
 102:led.c         **** 
 103:led.c         ****                         // Restart the selection process
 104:led.c         ****                         fruitIndex = 0;
 105:led.c         ****                         percentage = 0;
 106:led.c         ****                         selectingPercentage = 1;
 107:led.c         ****                         displayFruit(fruits[fruitIndex], percentage);
 108:led.c         ****                     } else {
 109:led.c         ****                         displayOrderComplete();
 110:led.c         ****                         while (1);  // Stop the program
 111:led.c         ****                     }
 112:led.c         ****                 }
 113:led.c         ****             }
 114:led.c         ****             lastEncoderSwitchState = encoderSwitchState;
 115:led.c         ****         }
 116:led.c         **** 
 117:led.c         ****         // Small delay for debouncing
 118:led.c         ****         _delay_ms(50);
 119:led.c         ****     }
 120:led.c         **** 
 121:led.c         ****     return 0;
 122:led.c         **** }
 123:led.c         **** 
 124:led.c         **** // Function to set up the button and encoder pins
 125:led.c         **** void setup() {
 419               		.loc 3 125 0
 420               		.cfi_startproc
 421               	/* prologue: function */
 422               	/* frame size = 0 */
 423               	/* stack size = 0 */
 424               	.L__stack_usage = 0
 126:led.c         ****     DDRC &= ~(1 << PC0);  // Set PC0 (Switch 1) as input
 425               		.loc 3 126 0
 426 013c 3898      		cbi 0x7,0
 127:led.c         ****     PORTC |= (1 << PC0);  // Enable pull-up resistor on PC0
 427               		.loc 3 127 0
 428 013e 409A      		sbi 0x8,0
 128:led.c         **** 
 129:led.c         ****     DDRC &= ~(1 << PC1);  // Set PC1 (Switch 2) as input
 429               		.loc 3 129 0
 430 0140 3998      		cbi 0x7,1
 130:led.c         ****     PORTC |= (1 << PC1);  // Enable pull-up resistor on PC1
 431               		.loc 3 130 0
 432 0142 419A      		sbi 0x8,1
 131:led.c         **** 
 132:led.c         ****     DDRC &= ~(1 << PC2);  // Set PC2 (Switch 3) as input
 433               		.loc 3 132 0
 434 0144 3A98      		cbi 0x7,2
 133:led.c         ****     PORTC |= (1 << PC2);  // Enable pull-up resistor on PC2
 435               		.loc 3 133 0
 436 0146 429A      		sbi 0x8,2
 134:led.c         **** 
 135:led.c         ****     // Encoder setup (only button is used now)
 136:led.c         ****     DDRB &= ~(1 << PB1);  // CLK as input
 437               		.loc 3 136 0
 438 0148 2198      		cbi 0x4,1
 137:led.c         ****     DDRB &= ~(1 << PB2);  // DT as input
 439               		.loc 3 137 0
 440 014a 2298      		cbi 0x4,2
 138:led.c         ****     DDRB &= ~(1 << PB3);  // SW (encoder button) as input
 441               		.loc 3 138 0
 442 014c 2398      		cbi 0x4,3
 139:led.c         ****     PORTB |= (1 << PB3);  // Enable pull-up resistor for encoder button
 443               		.loc 3 139 0
 444 014e 2B9A      		sbi 0x5,3
 445 0150 0895      		ret
 446               		.cfi_endproc
 447               	.LFE17:
 449               	.global	isSwitch1Pressed
 451               	isSwitch1Pressed:
 452               	.LFB18:
 140:led.c         **** }
 141:led.c         **** 
 142:led.c         **** // Function to check if Switch 1 is pressed
 143:led.c         **** uint8_t isSwitch1Pressed() {
 453               		.loc 3 143 0
 454               		.cfi_startproc
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 0 */
 458               	.L__stack_usage = 0
 144:led.c         ****     return !(PINC & (1 << PC0));
 459               		.loc 3 144 0
 460 0152 86B1      		in r24,0x6
 461 0154 8095      		com r24
 145:led.c         **** }
 462               		.loc 3 145 0
 463 0156 8170      		andi r24,lo8(1)
 464 0158 0895      		ret
 465               		.cfi_endproc
 466               	.LFE18:
 468               	.global	isSwitch2Pressed
 470               	isSwitch2Pressed:
 471               	.LFB19:
 146:led.c         **** 
 147:led.c         **** // Function to check if Switch 2 is pressed
 148:led.c         **** uint8_t isSwitch2Pressed() {
 472               		.loc 3 148 0
 473               		.cfi_startproc
 474               	/* prologue: function */
 475               	/* frame size = 0 */
 476               	/* stack size = 0 */
 477               	.L__stack_usage = 0
 149:led.c         ****     return !(PINC & (1 << PC1));
 478               		.loc 3 149 0
 479 015a 86B1      		in r24,0x6
 480 015c 8695      		lsr r24
 481 015e 8170      		andi r24,1
 150:led.c         **** }
 482               		.loc 3 150 0
 483 0160 91E0      		ldi r25,lo8(1)
 484 0162 8927      		eor r24,r25
 485 0164 0895      		ret
 486               		.cfi_endproc
 487               	.LFE19:
 489               	.global	isSwitch3Pressed
 491               	isSwitch3Pressed:
 492               	.LFB20:
 151:led.c         **** 
 152:led.c         **** // Function to check if Switch 3 is pressed
 153:led.c         **** uint8_t isSwitch3Pressed() {
 493               		.loc 3 153 0
 494               		.cfi_startproc
 495               	/* prologue: function */
 496               	/* frame size = 0 */
 497               	/* stack size = 0 */
 498               	.L__stack_usage = 0
 154:led.c         ****     return !(PINC & (1 << PC2));
 499               		.loc 3 154 0
 500 0166 86B1      		in r24,0x6
 501 0168 82FB      		bst r24,2
 502 016a 8827      		clr r24
 503 016c 80F9      		bld r24,0
 155:led.c         **** }
 504               		.loc 3 155 0
 505 016e 91E0      		ldi r25,lo8(1)
 506 0170 8927      		eor r24,r25
 507 0172 0895      		ret
 508               		.cfi_endproc
 509               	.LFE20:
 511               	.global	isEncoderPressed
 513               	isEncoderPressed:
 514               	.LFB21:
 156:led.c         **** 
 157:led.c         **** // Function to check if rotary encoder switch is pressed
 158:led.c         **** uint8_t isEncoderPressed() {
 515               		.loc 3 158 0
 516               		.cfi_startproc
 517               	/* prologue: function */
 518               	/* frame size = 0 */
 519               	/* stack size = 0 */
 520               	.L__stack_usage = 0
 159:led.c         ****     return !(PINB & (1 << PB3));
 521               		.loc 3 159 0
 522 0174 83B1      		in r24,0x3
 523 0176 83FB      		bst r24,3
 524 0178 8827      		clr r24
 525 017a 80F9      		bld r24,0
 160:led.c         **** }
 526               		.loc 3 160 0
 527 017c 91E0      		ldi r25,lo8(1)
 528 017e 8927      		eor r24,r25
 529 0180 0895      		ret
 530               		.cfi_endproc
 531               	.LFE21:
 533               		.section	.rodata.str1.1,"aMS",@progbits,1
 534               	.LC0:
 535 0000 312E 2041 		.string	"1. Auto Mode"
 535      7574 6F20 
 535      4D6F 6465 
 535      00
 536               	.LC1:
 537 000d 322E 204D 		.string	"2. Manual Mode"
 537      616E 7561 
 537      6C20 4D6F 
 537      6465 00
 538               		.text
 539               	.global	displayAutoManual
 541               	displayAutoManual:
 542               	.LFB22:
 161:led.c         **** 
 162:led.c         **** // Function to display "1. Auto Mode" and "2. Manual Mode"
 163:led.c         **** void displayAutoManual() {
 543               		.loc 3 163 0
 544               		.cfi_startproc
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               	/* stack size = 0 */
 548               	.L__stack_usage = 0
 164:led.c         ****     LCD_Clear();
 549               		.loc 3 164 0
 550 0182 0E94 0000 		call LCD_Clear
 551               	.LVL48:
 165:led.c         ****     LCD_String("1. Auto Mode");
 552               		.loc 3 165 0
 553 0186 80E0      		ldi r24,lo8(.LC0)
 554 0188 90E0      		ldi r25,hi8(.LC0)
 555 018a 0E94 0000 		call LCD_String
 556               	.LVL49:
 166:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 557               		.loc 3 166 0
 558 018e 80EC      		ldi r24,lo8(-64)
 559 0190 0E94 0000 		call LCD_Command
 560               	.LVL50:
 167:led.c         ****     LCD_String("2. Manual Mode");
 561               		.loc 3 167 0
 562 0194 80E0      		ldi r24,lo8(.LC1)
 563 0196 90E0      		ldi r25,hi8(.LC1)
 564 0198 0C94 0000 		jmp LCD_String
 565               	.LVL51:
 566               		.cfi_endproc
 567               	.LFE22:
 569               		.section	.rodata.str1.1
 570               	.LC2:
 571 001c 5072 6F63 		.string	"Processing"
 571      6573 7369 
 571      6E67 00
 572               	.LC3:
 573 0027 4175 746F 		.string	"Auto Mode..."
 573      204D 6F64 
 573      652E 2E2E 
 573      00
 574               		.text
 575               	.global	displayProcessing
 577               	displayProcessing:
 578               	.LFB23:
 168:led.c         **** }
 169:led.c         **** 
 170:led.c         **** // Function to display "Processing" and "Auto Mode"
 171:led.c         **** void displayProcessing() {
 579               		.loc 3 171 0
 580               		.cfi_startproc
 581               	/* prologue: function */
 582               	/* frame size = 0 */
 583               	/* stack size = 0 */
 584               	.L__stack_usage = 0
 172:led.c         ****     LCD_Clear();
 585               		.loc 3 172 0
 586 019c 0E94 0000 		call LCD_Clear
 587               	.LVL52:
 173:led.c         ****     LCD_String("Processing");
 588               		.loc 3 173 0
 589 01a0 80E0      		ldi r24,lo8(.LC2)
 590 01a2 90E0      		ldi r25,hi8(.LC2)
 591 01a4 0E94 0000 		call LCD_String
 592               	.LVL53:
 174:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 593               		.loc 3 174 0
 594 01a8 80EC      		ldi r24,lo8(-64)
 595 01aa 0E94 0000 		call LCD_Command
 596               	.LVL54:
 175:led.c         ****     LCD_String("Auto Mode...");
 597               		.loc 3 175 0
 598 01ae 80E0      		ldi r24,lo8(.LC3)
 599 01b0 90E0      		ldi r25,hi8(.LC3)
 600 01b2 0C94 0000 		jmp LCD_String
 601               	.LVL55:
 602               		.cfi_endproc
 603               	.LFE23:
 605               		.section	.rodata.str1.1
 606               	.LC4:
 607 0034 5365 6C65 		.string	"Select the"
 607      6374 2074 
 607      6865 00
 608               	.LC5:
 609 003f 5065 7263 		.string	"Percentages..."
 609      656E 7461 
 609      6765 732E 
 609      2E2E 00
 610               		.text
 611               	.global	displayChoosePercentages
 613               	displayChoosePercentages:
 614               	.LFB24:
 176:led.c         **** }
 177:led.c         **** 
 178:led.c         **** // Function to display "Select the percentages"
 179:led.c         **** void displayChoosePercentages() {
 615               		.loc 3 179 0
 616               		.cfi_startproc
 617               	/* prologue: function */
 618               	/* frame size = 0 */
 619               	/* stack size = 0 */
 620               	.L__stack_usage = 0
 180:led.c         ****     LCD_Clear();
 621               		.loc 3 180 0
 622 01b6 0E94 0000 		call LCD_Clear
 623               	.LVL56:
 181:led.c         ****     LCD_String("Select the");
 624               		.loc 3 181 0
 625 01ba 80E0      		ldi r24,lo8(.LC4)
 626 01bc 90E0      		ldi r25,hi8(.LC4)
 627 01be 0E94 0000 		call LCD_String
 628               	.LVL57:
 182:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 629               		.loc 3 182 0
 630 01c2 80EC      		ldi r24,lo8(-64)
 631 01c4 0E94 0000 		call LCD_Command
 632               	.LVL58:
 183:led.c         ****     LCD_String("Percentages...");
 633               		.loc 3 183 0
 634 01c8 80E0      		ldi r24,lo8(.LC5)
 635 01ca 90E0      		ldi r25,hi8(.LC5)
 636 01cc 0C94 0000 		jmp LCD_String
 637               	.LVL59:
 638               		.cfi_endproc
 639               	.LFE24:
 641               		.section	.rodata.str1.1
 642               	.LC6:
 643 004e 2564 2525 		.string	"%d%%"
 643      00
 644               		.text
 645               	.global	displayFruit
 647               	displayFruit:
 648               	.LFB25:
 184:led.c         **** }
 185:led.c         **** 
 186:led.c         **** // Function to display a fruit and its percentage
 187:led.c         **** void displayFruit(char *fruit, uint8_t percentage) {
 649               		.loc 3 187 0
 650               		.cfi_startproc
 651               	.LVL60:
 652 01d0 EF92      		push r14
 653               	.LCFI5:
 654               		.cfi_def_cfa_offset 3
 655               		.cfi_offset 14, -2
 656 01d2 FF92      		push r15
 657               	.LCFI6:
 658               		.cfi_def_cfa_offset 4
 659               		.cfi_offset 15, -3
 660 01d4 0F93      		push r16
 661               	.LCFI7:
 662               		.cfi_def_cfa_offset 5
 663               		.cfi_offset 16, -4
 664 01d6 1F93      		push r17
 665               	.LCFI8:
 666               		.cfi_def_cfa_offset 6
 667               		.cfi_offset 17, -5
 668 01d8 CF93      		push r28
 669               	.LCFI9:
 670               		.cfi_def_cfa_offset 7
 671               		.cfi_offset 28, -6
 672 01da DF93      		push r29
 673               	.LCFI10:
 674               		.cfi_def_cfa_offset 8
 675               		.cfi_offset 29, -7
 676 01dc CDB7      		in r28,__SP_L__
 677 01de DEB7      		in r29,__SP_H__
 678               	.LCFI11:
 679               		.cfi_def_cfa_register 28
 680 01e0 6097      		sbiw r28,16
 681               	.LCFI12:
 682               		.cfi_def_cfa_offset 24
 683 01e2 0FB6      		in __tmp_reg__,__SREG__
 684 01e4 F894      		cli
 685 01e6 DEBF      		out __SP_H__,r29
 686 01e8 0FBE      		out __SREG__,__tmp_reg__
 687 01ea CDBF      		out __SP_L__,r28
 688               	/* prologue: function */
 689               	/* frame size = 16 */
 690               	/* stack size = 22 */
 691               	.L__stack_usage = 22
 692 01ec 7C01      		movw r14,r24
 693 01ee 162F      		mov r17,r22
 188:led.c         ****     char buffer[16];
 189:led.c         ****     LCD_Clear();
 694               		.loc 3 189 0
 695 01f0 0E94 0000 		call LCD_Clear
 696               	.LVL61:
 190:led.c         ****     LCD_String(fruit);
 697               		.loc 3 190 0
 698 01f4 C701      		movw r24,r14
 699 01f6 0E94 0000 		call LCD_String
 700               	.LVL62:
 191:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 701               		.loc 3 191 0
 702 01fa 80EC      		ldi r24,lo8(-64)
 703 01fc 0E94 0000 		call LCD_Command
 704               	.LVL63:
 192:led.c         ****     snprintf(buffer, 16, "%d%%", percentage);
 705               		.loc 3 192 0
 706 0200 1F92      		push __zero_reg__
 707 0202 1F93      		push r17
 708 0204 80E0      		ldi r24,lo8(.LC6)
 709 0206 90E0      		ldi r25,hi8(.LC6)
 710 0208 9F93      		push r25
 711 020a 8F93      		push r24
 712 020c 1F92      		push __zero_reg__
 713 020e 80E1      		ldi r24,lo8(16)
 714 0210 8F93      		push r24
 715 0212 8E01      		movw r16,r28
 716 0214 0F5F      		subi r16,-1
 717 0216 1F4F      		sbci r17,-1
 718 0218 1F93      		push r17
 719 021a 0F93      		push r16
 720 021c 0E94 0000 		call snprintf
 721               	.LVL64:
 193:led.c         ****     LCD_String(buffer);
 722               		.loc 3 193 0
 723 0220 C801      		movw r24,r16
 724 0222 0E94 0000 		call LCD_String
 725               	.LVL65:
 194:led.c         **** }
 726               		.loc 3 194 0
 727 0226 0FB6      		in __tmp_reg__,__SREG__
 728 0228 F894      		cli
 729 022a DEBF      		out __SP_H__,r29
 730 022c 0FBE      		out __SREG__,__tmp_reg__
 731 022e CDBF      		out __SP_L__,r28
 732               	/* epilogue start */
 733 0230 6096      		adiw r28,16
 734 0232 0FB6      		in __tmp_reg__,__SREG__
 735 0234 F894      		cli
 736 0236 DEBF      		out __SP_H__,r29
 737 0238 0FBE      		out __SREG__,__tmp_reg__
 738 023a CDBF      		out __SP_L__,r28
 739 023c DF91      		pop r29
 740 023e CF91      		pop r28
 741 0240 1F91      		pop r17
 742               	.LVL66:
 743 0242 0F91      		pop r16
 744 0244 FF90      		pop r15
 745 0246 EF90      		pop r14
 746               	.LVL67:
 747 0248 0895      		ret
 748               		.cfi_endproc
 749               	.LFE25:
 751               		.section	.rodata.str1.1
 752               	.LC7:
 753 0053 4578 6365 		.string	"Exceeded 100%"
 753      6564 6564 
 753      2031 3030 
 753      2500 
 754               	.LC8:
 755 0061 5365 6C65 		.string	"Select Again"
 755      6374 2041 
 755      6761 696E 
 755      00
 756               		.text
 757               	.global	displayExceededMessage
 759               	displayExceededMessage:
 760               	.LFB26:
 195:led.c         **** 
 196:led.c         **** // Function to display "Exceeded 100%" and "Select Again"
 197:led.c         **** void displayExceededMessage() {
 761               		.loc 3 197 0
 762               		.cfi_startproc
 763               	/* prologue: function */
 764               	/* frame size = 0 */
 765               	/* stack size = 0 */
 766               	.L__stack_usage = 0
 198:led.c         ****     LCD_Clear();
 767               		.loc 3 198 0
 768 024a 0E94 0000 		call LCD_Clear
 769               	.LVL68:
 199:led.c         ****     LCD_String("Exceeded 100%");
 770               		.loc 3 199 0
 771 024e 80E0      		ldi r24,lo8(.LC7)
 772 0250 90E0      		ldi r25,hi8(.LC7)
 773 0252 0E94 0000 		call LCD_String
 774               	.LVL69:
 200:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 775               		.loc 3 200 0
 776 0256 80EC      		ldi r24,lo8(-64)
 777 0258 0E94 0000 		call LCD_Command
 778               	.LVL70:
 201:led.c         ****     LCD_String("Select Again");
 779               		.loc 3 201 0
 780 025c 80E0      		ldi r24,lo8(.LC8)
 781 025e 90E0      		ldi r25,hi8(.LC8)
 782 0260 0C94 0000 		jmp LCD_String
 783               	.LVL71:
 784               		.cfi_endproc
 785               	.LFE26:
 787               		.section	.rodata.str1.1
 788               	.LC9:
 789 006e 596F 7572 		.string	"Your order is"
 789      206F 7264 
 789      6572 2069 
 789      7300 
 790               	.LC10:
 791 007c 6F6E 2074 		.string	"on the way"
 791      6865 2077 
 791      6179 00
 792               		.text
 793               	.global	displayOrderComplete
 795               	displayOrderComplete:
 796               	.LFB27:
 202:led.c         **** }
 203:led.c         **** 
 204:led.c         **** // Function to display "Your order is" and "on the way"
 205:led.c         **** void displayOrderComplete() {
 797               		.loc 3 205 0
 798               		.cfi_startproc
 799               	/* prologue: function */
 800               	/* frame size = 0 */
 801               	/* stack size = 0 */
 802               	.L__stack_usage = 0
 206:led.c         ****     LCD_Clear();
 803               		.loc 3 206 0
 804 0264 0E94 0000 		call LCD_Clear
 805               	.LVL72:
 207:led.c         ****     LCD_String("Your order is");
 806               		.loc 3 207 0
 807 0268 80E0      		ldi r24,lo8(.LC9)
 808 026a 90E0      		ldi r25,hi8(.LC9)
 809 026c 0E94 0000 		call LCD_String
 810               	.LVL73:
 208:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 811               		.loc 3 208 0
 812 0270 80EC      		ldi r24,lo8(-64)
 813 0272 0E94 0000 		call LCD_Command
 814               	.LVL74:
 209:led.c         ****     LCD_String("on the way");
 815               		.loc 3 209 0
 816 0276 80E0      		ldi r24,lo8(.LC10)
 817 0278 90E0      		ldi r25,hi8(.LC10)
 818 027a 0C94 0000 		jmp LCD_String
 819               	.LVL75:
 820               		.cfi_endproc
 821               	.LFE27:
 823               		.section	.rodata.str1.1
 824               	.LC11:
 825 0087 546F 7461 		.string	"Total should not"
 825      6C20 7368 
 825      6F75 6C64 
 825      206E 6F74 
 825      00
 826               	.LC12:
 827 0098 6578 6365 		.string	"exceed 100%"
 827      6564 2031 
 827      3030 2500 
 828               		.section	.text.startup,"ax",@progbits
 829               	.global	main
 831               	main:
 832               	.LFB16:
  26:led.c         ****     uint8_t switch1State = 0;
 833               		.loc 3 26 0
 834               		.cfi_startproc
 835               	/* prologue: function */
 836               	/* frame size = 0 */
 837               	/* stack size = 0 */
 838               	.L__stack_usage = 0
 839               	.LVL76:
  32:led.c         ****     LCD_Init();  // Initialize LCD
 840               		.loc 3 32 0
 841 0000 0E94 0000 		call setup
 842               	.LVL77:
  33:led.c         **** 
 843               		.loc 3 33 0
 844 0004 0E94 0000 		call LCD_Init
 845               	.LVL78:
  35:led.c         **** 
 846               		.loc 3 35 0
 847 0008 0E94 0000 		call displayAutoManual
 848               	.LVL79:
  30:led.c         **** 
 849               		.loc 3 30 0
 850 000c 00E0      		ldi r16,0
  28:led.c         ****     uint8_t encoderSwitchState = 0;
 851               		.loc 3 28 0
 852 000e F12C      		mov r15,__zero_reg__
  58:led.c         ****             displayFruit(fruits[fruitIndex], percentage);
 853               		.loc 3 58 0
 854 0010 D1E0      		ldi r29,lo8(1)
  69:led.c         ****                 }
 855               		.loc 3 69 0
 856 0012 14E6      		ldi r17,lo8(100)
 857               	.LVL80:
 858               	.L43:
  39:led.c         **** 
 859               		.loc 3 39 0
 860 0014 0E94 0000 		call isSwitch1Pressed
 861               	.LVL81:
 862 0018 C82F      		mov r28,r24
 863               	.LVL82:
  41:led.c         ****             // Start the auto mode sequence
 864               		.loc 3 41 0
 865 001a 8823      		tst r24
 866 001c 01F0      		breq .L34
  41:led.c         ****             // Start the auto mode sequence
 867               		.loc 3 41 0 is_stmt 0 discriminator 1
 868 001e F110      		cpse r15,__zero_reg__
 869 0020 00C0      		rjmp .L34
  43:led.c         ****             _delay_ms(4000);
 870               		.loc 3 43 0 is_stmt 1
 871 0022 0E94 0000 		call displayProcessing
 872               	.LVL83:
 873               	.LBB41:
 874               	.LBB42:
 187:/usr/lib/avr/include/util/delay.h **** 
 875               		.loc 2 187 0
 876 0026 2FEF      		ldi r18,lo8(799999)
 877 0028 84E3      		ldi r24,hi8(799999)
 878 002a 9CE0      		ldi r25,hlo8(799999)
 879 002c 2150      	1:	subi r18,1
 880 002e 8040      		sbci r24,0
 881 0030 9040      		sbci r25,0
 882 0032 01F4      		brne 1b
 883 0034 00C0      		rjmp .
 884 0036 0000      		nop
 885               	.LVL84:
 886               	.LBE42:
 887               	.LBE41:
  46:led.c         ****             _delay_ms(4000);
 888               		.loc 3 46 0
 889 0038 0E94 0000 		call displayChoosePercentages
 890               	.LVL85:
 891               	.LBB43:
 892               	.LBB44:
 187:/usr/lib/avr/include/util/delay.h **** 
 893               		.loc 2 187 0
 894 003c 2FEF      		ldi r18,lo8(799999)
 895 003e 84E3      		ldi r24,hi8(799999)
 896 0040 9CE0      		ldi r25,hlo8(799999)
 897 0042 2150      	1:	subi r18,1
 898 0044 8040      		sbci r24,0
 899 0046 9040      		sbci r25,0
 900 0048 01F4      		brne 1b
 901 004a 00C0      		rjmp .
 902 004c 0000      		nop
 903               	.LVL86:
 904               	.LBE44:
 905               	.LBE43:
  49:led.c         ****             LCD_String("Total should not");
 906               		.loc 3 49 0
 907 004e 0E94 0000 		call LCD_Clear
 908               	.LVL87:
  50:led.c         ****             LCD_Command(0xC0);  // Move to 2nd row
 909               		.loc 3 50 0
 910 0052 80E0      		ldi r24,lo8(.LC11)
 911 0054 90E0      		ldi r25,hi8(.LC11)
 912 0056 0E94 0000 		call LCD_String
 913               	.LVL88:
  51:led.c         ****             LCD_String("exceed 100%");
 914               		.loc 3 51 0
 915 005a 80EC      		ldi r24,lo8(-64)
 916 005c 0E94 0000 		call LCD_Command
 917               	.LVL89:
  52:led.c         ****             _delay_ms(4000);
 918               		.loc 3 52 0
 919 0060 80E0      		ldi r24,lo8(.LC12)
 920 0062 90E0      		ldi r25,hi8(.LC12)
 921 0064 0E94 0000 		call LCD_String
 922               	.LVL90:
 923               	.LBB45:
 924               	.LBB46:
 187:/usr/lib/avr/include/util/delay.h **** 
 925               		.loc 2 187 0
 926 0068 2FEF      		ldi r18,lo8(799999)
 927 006a 84E3      		ldi r24,hi8(799999)
 928 006c 9CE0      		ldi r25,hlo8(799999)
 929 006e 2150      	1:	subi r18,1
 930 0070 8040      		sbci r24,0
 931 0072 9040      		sbci r25,0
 932 0074 01F4      		brne 1b
 933 0076 00C0      		rjmp .
 934 0078 0000      		nop
 935               	.LVL91:
 936               	.LBE46:
 937               	.LBE45:
  56:led.c         ****             percentage = 0;
 938               		.loc 3 56 0
 939 007a 1092 0000 		sts fruitIndex,__zero_reg__
  57:led.c         ****             selectingPercentage = 1;  // Enable percentage selection
 940               		.loc 3 57 0
 941 007e 1092 0000 		sts percentage,__zero_reg__
  58:led.c         ****             displayFruit(fruits[fruitIndex], percentage);
 942               		.loc 3 58 0
 943 0082 D093 0000 		sts selectingPercentage,r29
  59:led.c         ****         }
 944               		.loc 3 59 0
 945 0086 60E0      		ldi r22,0
 946 0088 8091 0000 		lds r24,fruits
 947 008c 9091 0000 		lds r25,fruits+1
 948 0090 0E94 0000 		call displayFruit
 949               	.LVL92:
 950               	.L34:
  64:led.c         ****             // Check if Switch 2 (PC1) is pressed to increase percentage
 951               		.loc 3 64 0
 952 0094 8091 0000 		lds r24,selectingPercentage
 953 0098 8823      		tst r24
 954 009a 01F4      		brne .+2
 955 009c 00C0      		rjmp .L44
  66:led.c         ****                 percentage += 20;
 956               		.loc 3 66 0
 957 009e 0E94 0000 		call isSwitch2Pressed
 958               	.LVL93:
 959 00a2 8823      		tst r24
 960 00a4 01F0      		breq .L36
  66:led.c         ****                 percentage += 20;
 961               		.loc 3 66 0 is_stmt 0 discriminator 1
 962 00a6 8091 0000 		lds r24,percentage
 963 00aa 8436      		cpi r24,lo8(100)
 964 00ac 00F4      		brsh .L36
  67:led.c         ****                 if (percentage > 100) {
 965               		.loc 3 67 0 is_stmt 1
 966 00ae 8C5E      		subi r24,lo8(-(20))
  68:led.c         ****                     percentage = 100; // Cap at 100%
 967               		.loc 3 68 0
 968 00b0 8536      		cpi r24,lo8(101)
 969 00b2 00F4      		brsh .L37
  67:led.c         ****                 if (percentage > 100) {
 970               		.loc 3 67 0
 971 00b4 8093 0000 		sts percentage,r24
 972 00b8 00C0      		rjmp .L38
 973               	.L37:
  69:led.c         ****                 }
 974               		.loc 3 69 0
 975 00ba 1093 0000 		sts percentage,r17
 976               	.L38:
  71:led.c         ****                 _delay_ms(200);  // Debounce delay
 977               		.loc 3 71 0
 978 00be E091 0000 		lds r30,fruitIndex
 979 00c2 F0E0      		ldi r31,0
 980 00c4 EE0F      		lsl r30
 981 00c6 FF1F      		rol r31
 982 00c8 E050      		subi r30,lo8(-(fruits))
 983 00ca F040      		sbci r31,hi8(-(fruits))
 984 00cc 6091 0000 		lds r22,percentage
 985 00d0 8081      		ld r24,Z
 986 00d2 9181      		ldd r25,Z+1
 987 00d4 0E94 0000 		call displayFruit
 988               	.LVL94:
 989               	.LBB47:
 990               	.LBB48:
 187:/usr/lib/avr/include/util/delay.h **** 
 991               		.loc 2 187 0
 992 00d8 8FE4      		ldi r24,lo8(-15537)
 993 00da 93EC      		ldi r25,hi8(-15537)
 994 00dc 0197      	1:	sbiw r24,1
 995 00de 01F4      		brne 1b
 996 00e0 00C0      		rjmp .
 997 00e2 0000      		nop
 998               	.LVL95:
 999               	.L36:
 1000               	.LBE48:
 1001               	.LBE47:
  76:led.c         ****                 percentage -= 20;
 1002               		.loc 3 76 0
 1003 00e4 0E94 0000 		call isSwitch3Pressed
 1004               	.LVL96:
 1005 00e8 8823      		tst r24
 1006 00ea 01F0      		breq .L39
  76:led.c         ****                 percentage -= 20;
 1007               		.loc 3 76 0 is_stmt 0 discriminator 1
 1008 00ec 6091 0000 		lds r22,percentage
 1009 00f0 6623      		tst r22
 1010 00f2 01F0      		breq .L39
  77:led.c         ****                 if (percentage < 0) {
 1011               		.loc 3 77 0 is_stmt 1
 1012 00f4 6451      		subi r22,lo8(-(-20))
 1013 00f6 6093 0000 		sts percentage,r22
  81:led.c         ****                 _delay_ms(200);  // Debounce delay
 1014               		.loc 3 81 0
 1015 00fa E091 0000 		lds r30,fruitIndex
 1016 00fe F0E0      		ldi r31,0
 1017 0100 EE0F      		lsl r30
 1018 0102 FF1F      		rol r31
 1019 0104 E050      		subi r30,lo8(-(fruits))
 1020 0106 F040      		sbci r31,hi8(-(fruits))
 1021 0108 8081      		ld r24,Z
 1022 010a 9181      		ldd r25,Z+1
 1023 010c 0E94 0000 		call displayFruit
 1024               	.LVL97:
 1025               	.LBB49:
 1026               	.LBB50:
 187:/usr/lib/avr/include/util/delay.h **** 
 1027               		.loc 2 187 0
 1028 0110 8FE4      		ldi r24,lo8(-15537)
 1029 0112 93EC      		ldi r25,hi8(-15537)
 1030 0114 0197      	1:	sbiw r24,1
 1031 0116 01F4      		brne 1b
 1032 0118 00C0      		rjmp .
 1033 011a 0000      		nop
 1034               	.LVL98:
 1035               	.L39:
 1036               	.LBE50:
 1037               	.LBE49:
  86:led.c         ****             if (encoderSwitchState && !lastEncoderSwitchState) {
 1038               		.loc 3 86 0
 1039 011c 0E94 0000 		call isEncoderPressed
 1040               	.LVL99:
 1041 0120 F82E      		mov r15,r24
 1042               	.LVL100:
  87:led.c         ****                 percentages[fruitIndex] = percentage;  // Store the selected percentage
 1043               		.loc 3 87 0
 1044 0122 8823      		tst r24
 1045 0124 01F4      		brne .+2
 1046 0126 00C0      		rjmp .L35
  87:led.c         ****                 percentages[fruitIndex] = percentage;  // Store the selected percentage
 1047               		.loc 3 87 0 is_stmt 0 discriminator 1
 1048 0128 0111      		cpse r16,__zero_reg__
 1049 012a 00C0      		rjmp .L35
  88:led.c         ****                 fruitIndex++;  // Move to the next fruit
 1050               		.loc 3 88 0 is_stmt 1
 1051 012c E091 0000 		lds r30,fruitIndex
 1052 0130 AE2F      		mov r26,r30
 1053 0132 B0E0      		ldi r27,0
 1054 0134 A050      		subi r26,lo8(-(percentages))
 1055 0136 B040      		sbci r27,hi8(-(percentages))
 1056 0138 8091 0000 		lds r24,percentage
 1057 013c 8C93      		st X,r24
  89:led.c         **** 
 1058               		.loc 3 89 0
 1059 013e EF5F      		subi r30,lo8(-(1))
 1060 0140 E093 0000 		sts fruitIndex,r30
  91:led.c         ****                     percentage = 0;  // Reset percentage for the next fruit
 1061               		.loc 3 91 0
 1062 0144 E430      		cpi r30,lo8(4)
 1063 0146 00F4      		brsh .L40
  92:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Display next fruit
 1064               		.loc 3 92 0
 1065 0148 1092 0000 		sts percentage,__zero_reg__
  93:led.c         ****                 } else {
 1066               		.loc 3 93 0
 1067 014c F0E0      		ldi r31,0
 1068 014e EE0F      		lsl r30
 1069 0150 FF1F      		rol r31
 1070 0152 E050      		subi r30,lo8(-(fruits))
 1071 0154 F040      		sbci r31,hi8(-(fruits))
 1072 0156 60E0      		ldi r22,0
 1073 0158 8081      		ld r24,Z
 1074 015a 9181      		ldd r25,Z+1
 1075 015c 00C0      		rjmp .L60
 1076               	.L40:
 1077               	.LBB51:
  95:led.c         **** 
 1078               		.loc 3 95 0
 1079 015e 1092 0000 		sts selectingPercentage,__zero_reg__
 1080               	.LVL101:
  99:led.c         ****                         displayExceededMessage();
 1081               		.loc 3 99 0
 1082 0162 9091 0000 		lds r25,percentages
 1083 0166 8091 0000 		lds r24,percentages+1
 1084 016a 890F      		add r24,r25
 1085 016c 9091 0000 		lds r25,percentages+2
 1086 0170 890F      		add r24,r25
 1087 0172 9091 0000 		lds r25,percentages+3
 1088 0176 890F      		add r24,r25
 1089 0178 8536      		cpi r24,lo8(101)
 1090 017a 00F0      		brlo .L41
 100:led.c         ****                         _delay_ms(3000);
 1091               		.loc 3 100 0
 1092 017c 0E94 0000 		call displayExceededMessage
 1093               	.LVL102:
 1094               	.LBB52:
 1095               	.LBB53:
 187:/usr/lib/avr/include/util/delay.h **** 
 1096               		.loc 2 187 0
 1097 0180 9FEB      		ldi r25,lo8(599999)
 1098 0182 27E2      		ldi r18,hi8(599999)
 1099 0184 89E0      		ldi r24,hlo8(599999)
 1100 0186 9150      	1:	subi r25,1
 1101 0188 2040      		sbci r18,0
 1102 018a 8040      		sbci r24,0
 1103 018c 01F4      		brne 1b
 1104 018e 00C0      		rjmp .
 1105 0190 0000      		nop
 1106               	.LVL103:
 1107               	.LBE53:
 1108               	.LBE52:
 104:led.c         ****                         percentage = 0;
 1109               		.loc 3 104 0
 1110 0192 1092 0000 		sts fruitIndex,__zero_reg__
 105:led.c         ****                         selectingPercentage = 1;
 1111               		.loc 3 105 0
 1112 0196 1092 0000 		sts percentage,__zero_reg__
 106:led.c         ****                         displayFruit(fruits[fruitIndex], percentage);
 1113               		.loc 3 106 0
 1114 019a D093 0000 		sts selectingPercentage,r29
 107:led.c         ****                     } else {
 1115               		.loc 3 107 0
 1116 019e 60E0      		ldi r22,0
 1117 01a0 8091 0000 		lds r24,fruits
 1118 01a4 9091 0000 		lds r25,fruits+1
 1119               	.L60:
 1120 01a8 0E94 0000 		call displayFruit
 1121               	.LVL104:
 1122 01ac 00C0      		rjmp .L35
 1123               	.LVL105:
 1124               	.L41:
 109:led.c         ****                         while (1);  // Stop the program
 1125               		.loc 3 109 0
 1126 01ae 0E94 0000 		call displayOrderComplete
 1127               	.LVL106:
 1128               	.L42:
 1129 01b2 00C0      		rjmp .L42
 1130               	.LVL107:
 1131               	.L44:
 1132               	.LBE51:
 1133 01b4 F02E      		mov r15,r16
 1134               	.L35:
 1135               	.LVL108:
 1136               	.LBB54:
 1137               	.LBB55:
 187:/usr/lib/avr/include/util/delay.h **** 
 1138               		.loc 2 187 0
 1139 01b6 83ED      		ldi r24,lo8(12499)
 1140 01b8 90E3      		ldi r25,hi8(12499)
 1141 01ba 0197      	1:	sbiw r24,1
 1142 01bc 01F4      		brne 1b
 1143 01be 00C0      		rjmp .
 1144 01c0 0000      		nop
 1145               	.LBE55:
 1146               	.LBE54:
  39:led.c         **** 
 1147               		.loc 3 39 0
 1148 01c2 0F2D      		mov r16,r15
 1149 01c4 FC2E      		mov r15,r28
 1150               	.LVL109:
 1151 01c6 00C0      		rjmp .L43
 1152               		.cfi_endproc
 1153               	.LFE16:
 1155               	.global	selectingPercentage
 1156               		.section .bss
 1159               	selectingPercentage:
 1160 0000 00        		.zero	1
 1161               	.global	percentage
 1164               	percentage:
 1165 0001 00        		.zero	1
 1166               	.global	percentages
 1169               	percentages:
 1170 0002 0000 0000 		.zero	4
 1171               	.global	fruitIndex
 1174               	fruitIndex:
 1175 0006 00        		.zero	1
 1176               	.global	fruits
 1177               		.section	.rodata.str1.1
 1178               	.LC13:
 1179 00a4 5049 4E45 		.string	"PINEAPPLE"
 1179      4150 504C 
 1179      4500 
 1180               	.LC14:
 1181 00ae 4D41 4E47 		.string	"MANGO"
 1181      4F00 
 1182               	.LC15:
 1183 00b4 4150 504C 		.string	"APPLE"
 1183      4500 
 1184               	.LC16:
 1185 00ba 4F52 414E 		.string	"ORANGE"
 1185      4745 00
 1186               		.data
 1189               	fruits:
 1190 0000 0000      		.word	.LC13
 1191 0002 0000      		.word	.LC14
 1192 0004 0000      		.word	.LC15
 1193 0006 0000      		.word	.LC16
 1194               		.text
 1195               	.Letext0:
 1196               		.file 4 "/usr/lib/avr/include/stdint.h"
 1197               		.file 5 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 led.c
     /tmp/ccPSPsUE.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPSPsUE.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPSPsUE.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPSPsUE.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPSPsUE.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPSPsUE.s:12     .text:0000000000000000 I2C_Init
     /tmp/ccPSPsUE.s:35     .text:0000000000000012 I2C_Start
     /tmp/ccPSPsUE.s:59     .text:0000000000000022 I2C_Stop
     /tmp/ccPSPsUE.s:88     .text:0000000000000032 I2C_Write
     /tmp/ccPSPsUE.s:131    .text:0000000000000058 LCD_EnablePulse
     /tmp/ccPSPsUE.s:184    .text:000000000000007c LCD_Command
     /tmp/ccPSPsUE.s:233    .text:00000000000000a8 LCD_Char
     /tmp/ccPSPsUE.s:282    .text:00000000000000d4 LCD_Init
     /tmp/ccPSPsUE.s:343    .text:0000000000000110 LCD_String
     /tmp/ccPSPsUE.s:386    .text:0000000000000128 LCD_Clear
     /tmp/ccPSPsUE.s:416    .text:000000000000013c setup
     /tmp/ccPSPsUE.s:451    .text:0000000000000152 isSwitch1Pressed
     /tmp/ccPSPsUE.s:470    .text:000000000000015a isSwitch2Pressed
     /tmp/ccPSPsUE.s:491    .text:0000000000000166 isSwitch3Pressed
     /tmp/ccPSPsUE.s:513    .text:0000000000000174 isEncoderPressed
     /tmp/ccPSPsUE.s:541    .text:0000000000000182 displayAutoManual
     /tmp/ccPSPsUE.s:577    .text:000000000000019c displayProcessing
     /tmp/ccPSPsUE.s:613    .text:00000000000001b6 displayChoosePercentages
     /tmp/ccPSPsUE.s:647    .text:00000000000001d0 displayFruit
     /tmp/ccPSPsUE.s:759    .text:000000000000024a displayExceededMessage
     /tmp/ccPSPsUE.s:795    .text:0000000000000264 displayOrderComplete
     /tmp/ccPSPsUE.s:831    .text.startup:0000000000000000 main
     /tmp/ccPSPsUE.s:1174   .bss:0000000000000006 fruitIndex
     /tmp/ccPSPsUE.s:1164   .bss:0000000000000001 percentage
     /tmp/ccPSPsUE.s:1159   .bss:0000000000000000 selectingPercentage
     /tmp/ccPSPsUE.s:1189   .data:0000000000000000 fruits
     /tmp/ccPSPsUE.s:1169   .bss:0000000000000002 percentages

UNDEFINED SYMBOLS
snprintf
__do_copy_data
__do_clear_bss
