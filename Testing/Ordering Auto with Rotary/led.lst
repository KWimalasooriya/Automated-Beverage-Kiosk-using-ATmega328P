   1               		.file	"led.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	I2C_Init
  12               	I2C_Init:
  13               	.LFB6:
  14               		.file 1 "i2c.h"
   1:i2c.h         **** #ifndef I2C_H
   2:i2c.h         **** #define I2C_H
   3:i2c.h         **** 
   4:i2c.h         **** #include <avr/io.h>           /* Include AVR std. library file */
   5:i2c.h         **** #include <util/delay.h>       /* Include Delay header file */
   6:i2c.h         **** 
   7:i2c.h         **** /* LCD I2C address */
   8:i2c.h         **** #define LCD_I2C_ADDRESS 0x27  /* Define I2C address of the LCD, often 0x27 or 0x3F */
   9:i2c.h         **** #define LCD_BACKLIGHT 0x08    /* Backlight control bit */
  10:i2c.h         **** #define ENABLE 0x04           /* Enable bit */
  11:i2c.h         **** #define READ_WRITE 0x02       /* Read/Write bit */
  12:i2c.h         **** #define REGISTER_SELECT 0x01  /* Register select bit */
  13:i2c.h         **** 
  14:i2c.h         **** /* I2C Functions */
  15:i2c.h         **** void I2C_Init(void) {
  15               		.loc 1 15 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  16:i2c.h         ****     TWSR = 0x00;              /* Set prescaler bits to zero */
  21               		.loc 1 16 0
  22 0000 1092 B900 		sts 185,__zero_reg__
  17:i2c.h         ****     TWBR = 0x46;              /* SCL frequency = 50kHz for F_CPU = 8MHz */
  23               		.loc 1 17 0
  24 0004 86E4      		ldi r24,lo8(70)
  25 0006 8093 B800 		sts 184,r24
  18:i2c.h         ****     TWCR = (1<<TWEN);         /* Enable TWI */
  26               		.loc 1 18 0
  27 000a 84E0      		ldi r24,lo8(4)
  28 000c 8093 BC00 		sts 188,r24
  29 0010 0895      		ret
  30               		.cfi_endproc
  31               	.LFE6:
  33               	.global	I2C_Start
  35               	I2C_Start:
  36               	.LFB7:
  19:i2c.h         **** }
  20:i2c.h         **** 
  21:i2c.h         **** void I2C_Start(void) {
  37               		.loc 1 21 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
  22:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);  /* Enable TWI, generate start condition */
  43               		.loc 1 22 0
  44 0012 84EA      		ldi r24,lo8(-92)
  45 0014 8093 BC00 		sts 188,r24
  46               	.L3:
  23:i2c.h         ****     while (!(TWCR & (1<<TWINT)));            /* Wait for TWINT flag to set */
  47               		.loc 1 23 0 discriminator 1
  48 0018 8091 BC00 		lds r24,188
  49 001c 87FF      		sbrs r24,7
  50 001e 00C0      		rjmp .L3
  51               	/* epilogue start */
  24:i2c.h         **** }
  52               		.loc 1 24 0
  53 0020 0895      		ret
  54               		.cfi_endproc
  55               	.LFE7:
  57               	.global	I2C_Stop
  59               	I2C_Stop:
  60               	.LFB8:
  25:i2c.h         **** 
  26:i2c.h         **** void I2C_Stop(void) {
  61               		.loc 1 26 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
  27:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);  /* Enable TWI, generate stop condition */
  67               		.loc 1 27 0
  68 0022 84E9      		ldi r24,lo8(-108)
  69 0024 8093 BC00 		sts 188,r24
  70               	.LVL0:
  71               	.LBB26:
  72               	.LBB27:
  73               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  74               		.loc 2 276 0
  75 0028 81E2      		ldi r24,lo8(33)
  76 002a 8A95      	1:	dec r24
  77 002c 01F4      		brne 1b
  78 002e 0000      		nop
  79               	.LVL1:
  80 0030 0895      		ret
  81               	.LBE27:
  82               	.LBE26:
  83               		.cfi_endproc
  84               	.LFE8:
  86               	.global	I2C_Write
  88               	I2C_Write:
  89               	.LFB9:
  28:i2c.h         ****     _delay_us(100);
  29:i2c.h         **** }
  30:i2c.h         **** 
  31:i2c.h         **** uint8_t I2C_Write(uint8_t data) {
  90               		.loc 1 31 0
  91               		.cfi_startproc
  92               	.LVL2:
  93               	/* prologue: function */
  94               	/* frame size = 0 */
  95               	/* stack size = 0 */
  96               	.L__stack_usage = 0
  32:i2c.h         ****     TWDR = data;              /* Copy data to TWI data register */
  97               		.loc 1 32 0
  98 0032 8093 BB00 		sts 187,r24
  33:i2c.h         ****     TWCR = (1<<TWINT)|(1<<TWEN); /* Enable TWI and clear interrupt flag */
  99               		.loc 1 33 0
 100 0036 84E8      		ldi r24,lo8(-124)
 101               	.LVL3:
 102 0038 8093 BC00 		sts 188,r24
 103               	.LVL4:
 104               	.L8:
  34:i2c.h         ****     while (!(TWCR & (1<<TWINT)));  /* Wait for TWINT flag to set */
 105               		.loc 1 34 0 discriminator 1
 106 003c 8091 BC00 		lds r24,188
 107 0040 87FF      		sbrs r24,7
 108 0042 00C0      		rjmp .L8
  35:i2c.h         ****     
  36:i2c.h         ****     // Check status
  37:i2c.h         ****     uint8_t status = TWSR & 0xF8;
 109               		.loc 1 37 0
 110 0044 9091 B900 		lds r25,185
 111 0048 987F      		andi r25,lo8(-8)
 112               	.LVL5:
  38:i2c.h         ****     if (status == 0x28 || status == 0x18) { /* 0x28 = TW_MT_DATA_ACK, 0x18 = TW_MT_SLA_ACK */
 113               		.loc 1 38 0
 114 004a 9832      		cpi r25,lo8(40)
 115 004c 01F0      		breq .L11
  39:i2c.h         ****         return 0;  // ACK received
 116               		.loc 1 39 0 discriminator 1
 117 004e 81E0      		ldi r24,lo8(1)
 118 0050 9831      		cpi r25,lo8(24)
 119 0052 01F4      		brne .L9
 120               	.L11:
 121               		.loc 1 39 0 is_stmt 0
 122 0054 80E0      		ldi r24,0
 123               	.L9:
  40:i2c.h         ****     } else {
  41:i2c.h         ****         return 1;  // NACK or error
  42:i2c.h         ****     }
  43:i2c.h         **** }
 124               		.loc 1 43 0 is_stmt 1
 125 0056 0895      		ret
 126               		.cfi_endproc
 127               	.LFE9:
 129               	.global	LCD_EnablePulse
 131               	LCD_EnablePulse:
 132               	.LFB10:
  44:i2c.h         **** 
  45:i2c.h         **** /* LCD Functions */
  46:i2c.h         **** void LCD_EnablePulse(uint8_t data) {
 133               		.loc 1 46 0
 134               		.cfi_startproc
 135               	.LVL6:
 136 0058 CF93      		push r28
 137               	.LCFI0:
 138               		.cfi_def_cfa_offset 3
 139               		.cfi_offset 28, -2
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 1 */
 143               	.L__stack_usage = 1
 144 005a C82F      		mov r28,r24
  47:i2c.h         ****     I2C_Write(data | ENABLE);  /* Enable bit high */
 145               		.loc 1 47 0
 146 005c 8460      		ori r24,lo8(4)
 147               	.LVL7:
 148 005e 0E94 0000 		call I2C_Write
 149               	.LVL8:
 150               	.LBB28:
 151               	.LBB29:
 152               		.loc 2 276 0
 153 0062 0000      		nop
 154               	.LVL9:
 155               	.LBE29:
 156               	.LBE28:
  48:i2c.h         ****     _delay_us(1);              /* Enable pulse width */
  49:i2c.h         ****     I2C_Write(data & ~ENABLE); /* Enable bit low */
 157               		.loc 1 49 0
 158 0064 8C2F      		mov r24,r28
 159 0066 8B7F      		andi r24,lo8(-5)
 160 0068 0E94 0000 		call I2C_Write
 161               	.LVL10:
 162               	.LBB30:
 163               	.LBB31:
 187:/usr/lib/avr/include/util/delay.h **** 
 164               		.loc 2 187 0
 165 006c 83EF      		ldi r24,lo8(499)
 166 006e 91E0      		ldi r25,hi8(499)
 167 0070 0197      	1:	sbiw r24,1
 168 0072 01F4      		brne 1b
 169 0074 00C0      		rjmp .
 170 0076 0000      		nop
 171               	.LVL11:
 172               	/* epilogue start */
 173               	.LBE31:
 174               	.LBE30:
  50:i2c.h         ****     _delay_ms(2);              /* Wait for the command to execute */
  51:i2c.h         **** }
 175               		.loc 1 51 0
 176 0078 CF91      		pop r28
 177               	.LVL12:
 178 007a 0895      		ret
 179               		.cfi_endproc
 180               	.LFE10:
 182               	.global	LCD_Command
 184               	LCD_Command:
 185               	.LFB11:
  52:i2c.h         **** 
  53:i2c.h         **** void LCD_Command(uint8_t cmnd) {
 186               		.loc 1 53 0
 187               		.cfi_startproc
 188               	.LVL13:
 189 007c CF93      		push r28
 190               	.LCFI1:
 191               		.cfi_def_cfa_offset 3
 192               		.cfi_offset 28, -2
 193               	/* prologue: function */
 194               	/* frame size = 0 */
 195               	/* stack size = 1 */
 196               	.L__stack_usage = 1
 197 007e C82F      		mov r28,r24
 198               	.LVL14:
  54:i2c.h         ****     uint8_t highNibble = (cmnd & 0xF0) | LCD_BACKLIGHT;
  55:i2c.h         ****     uint8_t lowNibble = ((cmnd << 4) & 0xF0) | LCD_BACKLIGHT;
  56:i2c.h         **** 
  57:i2c.h         ****     I2C_Start();
 199               		.loc 1 57 0
 200 0080 0E94 0000 		call I2C_Start
 201               	.LVL15:
  58:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 202               		.loc 1 58 0
 203 0084 8EE4      		ldi r24,lo8(78)
 204 0086 0E94 0000 		call I2C_Write
 205               	.LVL16:
  59:i2c.h         ****     
  60:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble */
 206               		.loc 1 60 0
 207 008a 8C2F      		mov r24,r28
 208 008c 807F      		andi r24,lo8(-16)
 209 008e 8860      		ori r24,lo8(8)
 210               	.LVL17:
 211 0090 0E94 0000 		call LCD_EnablePulse
 212               	.LVL18:
  61:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble */
 213               		.loc 1 61 0
 214 0094 20E1      		ldi r18,lo8(16)
 215 0096 C29F      		mul r28,r18
 216 0098 C001      		movw r24,r0
 217 009a 1124      		clr __zero_reg__
 218 009c 8860      		ori r24,lo8(8)
 219 009e 0E94 0000 		call LCD_EnablePulse
 220               	.LVL19:
 221               	/* epilogue start */
  62:i2c.h         ****     
  63:i2c.h         ****     I2C_Stop();
  64:i2c.h         **** }
 222               		.loc 1 64 0
 223 00a2 CF91      		pop r28
 224               	.LVL20:
  63:i2c.h         **** }
 225               		.loc 1 63 0
 226 00a4 0C94 0000 		jmp I2C_Stop
 227               	.LVL21:
 228               		.cfi_endproc
 229               	.LFE11:
 231               	.global	LCD_Char
 233               	LCD_Char:
 234               	.LFB12:
  65:i2c.h         **** 
  66:i2c.h         **** void LCD_Char(uint8_t data) {
 235               		.loc 1 66 0
 236               		.cfi_startproc
 237               	.LVL22:
 238 00a8 CF93      		push r28
 239               	.LCFI2:
 240               		.cfi_def_cfa_offset 3
 241               		.cfi_offset 28, -2
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 1 */
 245               	.L__stack_usage = 1
 246 00aa C82F      		mov r28,r24
 247               	.LVL23:
  67:i2c.h         ****     uint8_t highNibble = (data & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  68:i2c.h         ****     uint8_t lowNibble = ((data << 4) & 0xF0) | REGISTER_SELECT | LCD_BACKLIGHT;
  69:i2c.h         **** 
  70:i2c.h         ****     I2C_Start();
 248               		.loc 1 70 0
 249 00ac 0E94 0000 		call I2C_Start
 250               	.LVL24:
  71:i2c.h         ****     I2C_Write(LCD_I2C_ADDRESS << 1);  /* Send the I2C address with write mode */
 251               		.loc 1 71 0
 252 00b0 8EE4      		ldi r24,lo8(78)
 253 00b2 0E94 0000 		call I2C_Write
 254               	.LVL25:
  72:i2c.h         ****     
  73:i2c.h         ****     LCD_EnablePulse(highNibble);      /* Send the upper nibble with RS=1 for data */
 255               		.loc 1 73 0
 256 00b6 8C2F      		mov r24,r28
 257 00b8 807F      		andi r24,lo8(-16)
 258 00ba 8960      		ori r24,lo8(9)
 259               	.LVL26:
 260 00bc 0E94 0000 		call LCD_EnablePulse
 261               	.LVL27:
  74:i2c.h         ****     LCD_EnablePulse(lowNibble);       /* Send the lower nibble with RS=1 */
 262               		.loc 1 74 0
 263 00c0 20E1      		ldi r18,lo8(16)
 264 00c2 C29F      		mul r28,r18
 265 00c4 C001      		movw r24,r0
 266 00c6 1124      		clr __zero_reg__
 267 00c8 8960      		ori r24,lo8(9)
 268 00ca 0E94 0000 		call LCD_EnablePulse
 269               	.LVL28:
 270               	/* epilogue start */
  75:i2c.h         ****     
  76:i2c.h         ****     I2C_Stop();
  77:i2c.h         **** }
 271               		.loc 1 77 0
 272 00ce CF91      		pop r28
 273               	.LVL29:
  76:i2c.h         **** }
 274               		.loc 1 76 0
 275 00d0 0C94 0000 		jmp I2C_Stop
 276               	.LVL30:
 277               		.cfi_endproc
 278               	.LFE12:
 280               	.global	LCD_Init
 282               	LCD_Init:
 283               	.LFB13:
  78:i2c.h         **** 
  79:i2c.h         **** void LCD_Init(void) {
 284               		.loc 1 79 0
 285               		.cfi_startproc
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
  80:i2c.h         ****     I2C_Init();                /* Initialize I2C */
 290               		.loc 1 80 0
 291 00d4 0E94 0000 		call I2C_Init
 292               	.LVL31:
 293               	.LBB32:
 294               	.LBB33:
 187:/usr/lib/avr/include/util/delay.h **** 
 295               		.loc 2 187 0
 296 00d8 87E8      		ldi r24,lo8(4999)
 297 00da 93E1      		ldi r25,hi8(4999)
 298 00dc 0197      	1:	sbiw r24,1
 299 00de 01F4      		brne 1b
 300 00e0 00C0      		rjmp .
 301 00e2 0000      		nop
 302               	.LVL32:
 303               	.LBE33:
 304               	.LBE32:
  81:i2c.h         ****     _delay_ms(20);             /* LCD Power ON delay */
  82:i2c.h         ****     
  83:i2c.h         ****     LCD_Command(0x02);         /* Initialize for 4-bit mode */
 305               		.loc 1 83 0
 306 00e4 82E0      		ldi r24,lo8(2)
 307 00e6 0E94 0000 		call LCD_Command
 308               	.LVL33:
  84:i2c.h         ****     LCD_Command(0x28);         /* 2 lines, 5x7 matrix in 4-bit mode */
 309               		.loc 1 84 0
 310 00ea 88E2      		ldi r24,lo8(40)
 311 00ec 0E94 0000 		call LCD_Command
 312               	.LVL34:
  85:i2c.h         ****     LCD_Command(0x0C);         /* Display ON, Cursor OFF */
 313               		.loc 1 85 0
 314 00f0 8CE0      		ldi r24,lo8(12)
 315 00f2 0E94 0000 		call LCD_Command
 316               	.LVL35:
  86:i2c.h         ****     LCD_Command(0x06);         /* Auto increment cursor */
 317               		.loc 1 86 0
 318 00f6 86E0      		ldi r24,lo8(6)
 319 00f8 0E94 0000 		call LCD_Command
 320               	.LVL36:
  87:i2c.h         ****     LCD_Command(0x01);         /* Clear display */
 321               		.loc 1 87 0
 322 00fc 81E0      		ldi r24,lo8(1)
 323 00fe 0E94 0000 		call LCD_Command
 324               	.LVL37:
 325               	.LBB34:
 326               	.LBB35:
 187:/usr/lib/avr/include/util/delay.h **** 
 327               		.loc 2 187 0
 328 0102 83EF      		ldi r24,lo8(499)
 329 0104 91E0      		ldi r25,hi8(499)
 330 0106 0197      	1:	sbiw r24,1
 331 0108 01F4      		brne 1b
 332 010a 00C0      		rjmp .
 333 010c 0000      		nop
 334               	.LVL38:
 335 010e 0895      		ret
 336               	.LBE35:
 337               	.LBE34:
 338               		.cfi_endproc
 339               	.LFE13:
 341               	.global	LCD_String
 343               	LCD_String:
 344               	.LFB14:
  88:i2c.h         ****     _delay_ms(2);
  89:i2c.h         **** }
  90:i2c.h         **** 
  91:i2c.h         **** void LCD_String(char *str) {
 345               		.loc 1 91 0
 346               		.cfi_startproc
 347               	.LVL39:
 348 0110 CF93      		push r28
 349               	.LCFI3:
 350               		.cfi_def_cfa_offset 3
 351               		.cfi_offset 28, -2
 352 0112 DF93      		push r29
 353               	.LCFI4:
 354               		.cfi_def_cfa_offset 4
 355               		.cfi_offset 29, -3
 356               	/* prologue: function */
 357               	/* frame size = 0 */
 358               	/* stack size = 2 */
 359               	.L__stack_usage = 2
 360 0114 EC01      		movw r28,r24
 361               	.LVL40:
 362               	.L18:
  92:i2c.h         ****     while (*str) {
 363               		.loc 1 92 0
 364 0116 8991      		ld r24,Y+
 365               	.LVL41:
 366 0118 8823      		tst r24
 367 011a 01F0      		breq .L20
 368               	.LVL42:
  93:i2c.h         ****         LCD_Char(*str++);
 369               		.loc 1 93 0
 370 011c 0E94 0000 		call LCD_Char
 371               	.LVL43:
 372 0120 00C0      		rjmp .L18
 373               	.LVL44:
 374               	.L20:
 375               	/* epilogue start */
  94:i2c.h         ****     }
  95:i2c.h         **** }
 376               		.loc 1 95 0
 377 0122 DF91      		pop r29
 378 0124 CF91      		pop r28
 379               	.LVL45:
 380 0126 0895      		ret
 381               		.cfi_endproc
 382               	.LFE14:
 384               	.global	LCD_Clear
 386               	LCD_Clear:
 387               	.LFB15:
  96:i2c.h         **** 
  97:i2c.h         **** void LCD_Clear(void) {
 388               		.loc 1 97 0
 389               		.cfi_startproc
 390               	/* prologue: function */
 391               	/* frame size = 0 */
 392               	/* stack size = 0 */
 393               	.L__stack_usage = 0
  98:i2c.h         ****     LCD_Command(0x01);  // 0x01 is the command to clear the display
 394               		.loc 1 98 0
 395 0128 81E0      		ldi r24,lo8(1)
 396 012a 0E94 0000 		call LCD_Command
 397               	.LVL46:
 398               	.LBB36:
 399               	.LBB37:
 187:/usr/lib/avr/include/util/delay.h **** 
 400               		.loc 2 187 0
 401 012e 83EF      		ldi r24,lo8(499)
 402 0130 91E0      		ldi r25,hi8(499)
 403 0132 0197      	1:	sbiw r24,1
 404 0134 01F4      		brne 1b
 405 0136 00C0      		rjmp .
 406 0138 0000      		nop
 407               	.LVL47:
 408 013a 0895      		ret
 409               	.LBE37:
 410               	.LBE36:
 411               		.cfi_endproc
 412               	.LFE15:
 414               	.global	setup
 416               	setup:
 417               	.LFB17:
 418               		.file 3 "led.c"
   1:led.c         **** #define F_CPU 1000000
   2:led.c         **** #include <avr/io.h>
   3:led.c         **** #include <util/delay.h>
   4:led.c         **** #include "i2c.h"  // Include the I2C LCD header file
   5:led.c         **** 
   6:led.c         **** // Function prototypes
   7:led.c         **** void setup();
   8:led.c         **** uint8_t isSwitch1Pressed();
   9:led.c         **** uint8_t isSwitch2Pressed();
  10:led.c         **** uint8_t isEncoderPressed();
  11:led.c         **** void displayAutoManual();
  12:led.c         **** void displayProcessing();
  13:led.c         **** void displayChoosePercentages();
  14:led.c         **** void displayFruit(char *fruit, uint8_t percentage);
  15:led.c         **** void displayExceededMessage();
  16:led.c         **** void displayOrderComplete();
  17:led.c         **** int8_t readEncoder();
  18:led.c         **** 
  19:led.c         **** // Variables
  20:led.c         **** char *fruits[] = {"PINEAPPLE", "MANGO", "APPLE", "ORANGE"};
  21:led.c         **** uint8_t fruitIndex = 0;
  22:led.c         **** uint8_t percentages[4] = {0, 0, 0, 0};  // Array to store percentages for each fruit
  23:led.c         **** uint8_t percentage = 0;
  24:led.c         **** uint8_t selectingPercentage = 0;
  25:led.c         **** 
  26:led.c         **** int main(void) {
  27:led.c         ****     uint8_t switch1State = 0;
  28:led.c         ****     uint8_t lastSwitch1State = 0;
  29:led.c         ****     uint8_t encoderSwitchState = 0;
  30:led.c         ****     uint8_t lastEncoderSwitchState = 0;
  31:led.c         **** 
  32:led.c         ****     setup();  // Initialize pins
  33:led.c         ****     LCD_Init();  // Initialize LCD
  34:led.c         **** 
  35:led.c         ****     displayAutoManual();  // Initial display
  36:led.c         **** 
  37:led.c         ****     while (1) {
  38:led.c         ****         // Check if Switch 1 (PC0) is pressed
  39:led.c         ****         switch1State = isSwitch1Pressed();
  40:led.c         **** 
  41:led.c         ****         if (switch1State && !lastSwitch1State) {
  42:led.c         ****             // Start the auto mode sequence
  43:led.c         ****             displayProcessing();
  44:led.c         ****             _delay_ms(4000);
  45:led.c         **** 
  46:led.c         ****             displayChoosePercentages();
  47:led.c         ****             _delay_ms(4000);
  48:led.c         **** 
  49:led.c         ****             LCD_Clear();
  50:led.c         ****             LCD_String("Total should not");
  51:led.c         ****             LCD_Command(0xC0);  // Move to 2nd row
  52:led.c         ****             LCD_String("exceed 100%");
  53:led.c         ****             _delay_ms(4000);
  54:led.c         **** 
  55:led.c         ****             // Start selecting percentage for the first fruit
  56:led.c         ****             fruitIndex = 0;
  57:led.c         ****             percentage = 0;
  58:led.c         ****             selectingPercentage = 1;  // Enable encoder for percentage selection
  59:led.c         ****             displayFruit(fruits[fruitIndex], percentage);
  60:led.c         ****         }
  61:led.c         ****         lastSwitch1State = switch1State;
  62:led.c         **** 
  63:led.c         ****         // Check encoder only during the percentage selection phase
  64:led.c         ****         if (selectingPercentage) {
  65:led.c         ****             // Read the rotary encoder to adjust the percentage
  66:led.c         ****             int8_t rotation = readEncoder();
  67:led.c         ****             if (rotation > 0 && percentage < 100) {
  68:led.c         ****                 percentage += 20;
  69:led.c         ****                 displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percentage
  70:led.c         ****             }
  71:led.c         **** 
  72:led.c         ****             // Check if Switch 2 (PC1) is pressed to decrease the percentage
  73:led.c         ****             if (isSwitch2Pressed() && percentage > 0) {
  74:led.c         ****                 percentage -= 20;
  75:led.c         ****                 displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percentage
  76:led.c         ****             }
  77:led.c         **** 
  78:led.c         ****             // Check if the encoder button is pressed to confirm the percentage
  79:led.c         ****             encoderSwitchState = isEncoderPressed();
  80:led.c         ****             if (encoderSwitchState && !lastEncoderSwitchState) {
  81:led.c         ****                 percentages[fruitIndex] = percentage;  // Store the selected percentage
  82:led.c         ****                 fruitIndex++;  // Move to the next fruit
  83:led.c         **** 
  84:led.c         ****                 if (fruitIndex < 4) {
  85:led.c         ****                     percentage = 0;  // Reset percentage for the next fruit
  86:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Display next fruit
  87:led.c         ****                 } else {
  88:led.c         ****                     selectingPercentage = 0;  // Disable encoder
  89:led.c         **** 
  90:led.c         ****                     // Check if the total exceeds 100%
  91:led.c         ****                     uint8_t totalPercentage = percentages[0] + percentages[1] + percentages[2] + pe
  92:led.c         ****                     if (totalPercentage > 100) {
  93:led.c         ****                         displayExceededMessage();
  94:led.c         ****                         _delay_ms(3000);
  95:led.c         **** 
  96:led.c         ****                         // Restart the selection process
  97:led.c         ****                         fruitIndex = 0;
  98:led.c         ****                         percentage = 0;
  99:led.c         ****                         selectingPercentage = 1;
 100:led.c         ****                         displayFruit(fruits[fruitIndex], percentage);
 101:led.c         ****                     } else {
 102:led.c         ****                         displayOrderComplete();
 103:led.c         ****                         while (1);  // Stop the program
 104:led.c         ****                     }
 105:led.c         ****                 }
 106:led.c         ****             }
 107:led.c         ****             lastEncoderSwitchState = encoderSwitchState;
 108:led.c         ****         }
 109:led.c         **** 
 110:led.c         ****         // Small delay for debouncing
 111:led.c         ****         _delay_ms(50);
 112:led.c         ****     }
 113:led.c         **** 
 114:led.c         ****     return 0;
 115:led.c         **** }
 116:led.c         **** 
 117:led.c         **** // Function to set up the button and encoder pins
 118:led.c         **** void setup() {
 419               		.loc 3 118 0
 420               		.cfi_startproc
 421               	/* prologue: function */
 422               	/* frame size = 0 */
 423               	/* stack size = 0 */
 424               	.L__stack_usage = 0
 119:led.c         ****     DDRC &= ~(1 << PC0);  // Set PC0 (Switch 1) as input
 425               		.loc 3 119 0
 426 013c 3898      		cbi 0x7,0
 120:led.c         ****     PORTC |= (1 << PC0);  // Enable pull-up resistor on PC0
 427               		.loc 3 120 0
 428 013e 409A      		sbi 0x8,0
 121:led.c         **** 
 122:led.c         ****     DDRC &= ~(1 << PC1);  // Set PC1 (Switch 2) as input
 429               		.loc 3 122 0
 430 0140 3998      		cbi 0x7,1
 123:led.c         ****     PORTC |= (1 << PC1);  // Enable pull-up resistor on PC1
 431               		.loc 3 123 0
 432 0142 419A      		sbi 0x8,1
 124:led.c         **** 
 125:led.c         ****     DDRB &= ~(1 << PB1);  // Set PB1 (CLK) as input
 433               		.loc 3 125 0
 434 0144 2198      		cbi 0x4,1
 126:led.c         ****     DDRB &= ~(1 << PB2);  // Set PB2 (DT) as input
 435               		.loc 3 126 0
 436 0146 2298      		cbi 0x4,2
 127:led.c         ****     DDRB &= ~(1 << PB3);  // Set PB3 (SW) as input
 437               		.loc 3 127 0
 438 0148 2398      		cbi 0x4,3
 128:led.c         ****     PORTB |= (1 << PB1) | (1 << PB2) | (1 << PB3);  // Enable pull-up resistors for encoder
 439               		.loc 3 128 0
 440 014a 85B1      		in r24,0x5
 441 014c 8E60      		ori r24,lo8(14)
 442 014e 85B9      		out 0x5,r24
 443 0150 0895      		ret
 444               		.cfi_endproc
 445               	.LFE17:
 447               	.global	isSwitch1Pressed
 449               	isSwitch1Pressed:
 450               	.LFB18:
 129:led.c         **** }
 130:led.c         **** 
 131:led.c         **** // Function to check if Switch 1 is pressed
 132:led.c         **** uint8_t isSwitch1Pressed() {
 451               		.loc 3 132 0
 452               		.cfi_startproc
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 0 */
 456               	.L__stack_usage = 0
 133:led.c         ****     return !(PINC & (1 << PC0));
 457               		.loc 3 133 0
 458 0152 86B1      		in r24,0x6
 459 0154 8095      		com r24
 134:led.c         **** }
 460               		.loc 3 134 0
 461 0156 8170      		andi r24,lo8(1)
 462 0158 0895      		ret
 463               		.cfi_endproc
 464               	.LFE18:
 466               	.global	isSwitch2Pressed
 468               	isSwitch2Pressed:
 469               	.LFB19:
 135:led.c         **** 
 136:led.c         **** // Function to check if Switch 2 is pressed
 137:led.c         **** uint8_t isSwitch2Pressed() {
 470               		.loc 3 137 0
 471               		.cfi_startproc
 472               	/* prologue: function */
 473               	/* frame size = 0 */
 474               	/* stack size = 0 */
 475               	.L__stack_usage = 0
 138:led.c         ****     return !(PINC & (1 << PC1));
 476               		.loc 3 138 0
 477 015a 86B1      		in r24,0x6
 478 015c 8695      		lsr r24
 479 015e 8170      		andi r24,1
 139:led.c         **** }
 480               		.loc 3 139 0
 481 0160 91E0      		ldi r25,lo8(1)
 482 0162 8927      		eor r24,r25
 483 0164 0895      		ret
 484               		.cfi_endproc
 485               	.LFE19:
 487               	.global	isEncoderPressed
 489               	isEncoderPressed:
 490               	.LFB20:
 140:led.c         **** 
 141:led.c         **** // Function to check if rotary encoder switch is pressed
 142:led.c         **** uint8_t isEncoderPressed() {
 491               		.loc 3 142 0
 492               		.cfi_startproc
 493               	/* prologue: function */
 494               	/* frame size = 0 */
 495               	/* stack size = 0 */
 496               	.L__stack_usage = 0
 143:led.c         ****     return !(PINB & (1 << PB3));
 497               		.loc 3 143 0
 498 0166 83B1      		in r24,0x3
 499 0168 83FB      		bst r24,3
 500 016a 8827      		clr r24
 501 016c 80F9      		bld r24,0
 144:led.c         **** }
 502               		.loc 3 144 0
 503 016e 91E0      		ldi r25,lo8(1)
 504 0170 8927      		eor r24,r25
 505 0172 0895      		ret
 506               		.cfi_endproc
 507               	.LFE20:
 509               		.section	.rodata.str1.1,"aMS",@progbits,1
 510               	.LC0:
 511 0000 312E 2041 		.string	"1. Auto Mode"
 511      7574 6F20 
 511      4D6F 6465 
 511      00
 512               	.LC1:
 513 000d 322E 204D 		.string	"2. Manual Mode"
 513      616E 7561 
 513      6C20 4D6F 
 513      6465 00
 514               		.text
 515               	.global	displayAutoManual
 517               	displayAutoManual:
 518               	.LFB21:
 145:led.c         **** 
 146:led.c         **** // Function to display "1. Auto Mode" and "2. Manual Mode"
 147:led.c         **** void displayAutoManual() {
 519               		.loc 3 147 0
 520               		.cfi_startproc
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 0 */
 524               	.L__stack_usage = 0
 148:led.c         ****     LCD_Clear();
 525               		.loc 3 148 0
 526 0174 0E94 0000 		call LCD_Clear
 527               	.LVL48:
 149:led.c         ****     LCD_String("1. Auto Mode");
 528               		.loc 3 149 0
 529 0178 80E0      		ldi r24,lo8(.LC0)
 530 017a 90E0      		ldi r25,hi8(.LC0)
 531 017c 0E94 0000 		call LCD_String
 532               	.LVL49:
 150:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 533               		.loc 3 150 0
 534 0180 80EC      		ldi r24,lo8(-64)
 535 0182 0E94 0000 		call LCD_Command
 536               	.LVL50:
 151:led.c         ****     LCD_String("2. Manual Mode");
 537               		.loc 3 151 0
 538 0186 80E0      		ldi r24,lo8(.LC1)
 539 0188 90E0      		ldi r25,hi8(.LC1)
 540 018a 0C94 0000 		jmp LCD_String
 541               	.LVL51:
 542               		.cfi_endproc
 543               	.LFE21:
 545               		.section	.rodata.str1.1
 546               	.LC2:
 547 001c 5072 6F63 		.string	"Processing"
 547      6573 7369 
 547      6E67 00
 548               	.LC3:
 549 0027 4175 746F 		.string	"Auto Mode..."
 549      204D 6F64 
 549      652E 2E2E 
 549      00
 550               		.text
 551               	.global	displayProcessing
 553               	displayProcessing:
 554               	.LFB22:
 152:led.c         **** }
 153:led.c         **** 
 154:led.c         **** // Function to display "Processing" and "Auto Mode"
 155:led.c         **** void displayProcessing() {
 555               		.loc 3 155 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 156:led.c         ****     LCD_Clear();
 561               		.loc 3 156 0
 562 018e 0E94 0000 		call LCD_Clear
 563               	.LVL52:
 157:led.c         ****     LCD_String("Processing");
 564               		.loc 3 157 0
 565 0192 80E0      		ldi r24,lo8(.LC2)
 566 0194 90E0      		ldi r25,hi8(.LC2)
 567 0196 0E94 0000 		call LCD_String
 568               	.LVL53:
 158:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 569               		.loc 3 158 0
 570 019a 80EC      		ldi r24,lo8(-64)
 571 019c 0E94 0000 		call LCD_Command
 572               	.LVL54:
 159:led.c         ****     LCD_String("Auto Mode...");
 573               		.loc 3 159 0
 574 01a0 80E0      		ldi r24,lo8(.LC3)
 575 01a2 90E0      		ldi r25,hi8(.LC3)
 576 01a4 0C94 0000 		jmp LCD_String
 577               	.LVL55:
 578               		.cfi_endproc
 579               	.LFE22:
 581               		.section	.rodata.str1.1
 582               	.LC4:
 583 0034 5365 6C65 		.string	"Select the"
 583      6374 2074 
 583      6865 00
 584               	.LC5:
 585 003f 5065 7263 		.string	"Percentages..."
 585      656E 7461 
 585      6765 732E 
 585      2E2E 00
 586               		.text
 587               	.global	displayChoosePercentages
 589               	displayChoosePercentages:
 590               	.LFB23:
 160:led.c         **** }
 161:led.c         **** 
 162:led.c         **** // Function to display "Select the percentages"
 163:led.c         **** void displayChoosePercentages() {
 591               		.loc 3 163 0
 592               		.cfi_startproc
 593               	/* prologue: function */
 594               	/* frame size = 0 */
 595               	/* stack size = 0 */
 596               	.L__stack_usage = 0
 164:led.c         ****     LCD_Clear();
 597               		.loc 3 164 0
 598 01a8 0E94 0000 		call LCD_Clear
 599               	.LVL56:
 165:led.c         ****     LCD_String("Select the");
 600               		.loc 3 165 0
 601 01ac 80E0      		ldi r24,lo8(.LC4)
 602 01ae 90E0      		ldi r25,hi8(.LC4)
 603 01b0 0E94 0000 		call LCD_String
 604               	.LVL57:
 166:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 605               		.loc 3 166 0
 606 01b4 80EC      		ldi r24,lo8(-64)
 607 01b6 0E94 0000 		call LCD_Command
 608               	.LVL58:
 167:led.c         ****     LCD_String("Percentages...");
 609               		.loc 3 167 0
 610 01ba 80E0      		ldi r24,lo8(.LC5)
 611 01bc 90E0      		ldi r25,hi8(.LC5)
 612 01be 0C94 0000 		jmp LCD_String
 613               	.LVL59:
 614               		.cfi_endproc
 615               	.LFE23:
 617               		.section	.rodata.str1.1
 618               	.LC6:
 619 004e 2564 2525 		.string	"%d%%"
 619      00
 620               		.text
 621               	.global	displayFruit
 623               	displayFruit:
 624               	.LFB24:
 168:led.c         **** }
 169:led.c         **** 
 170:led.c         **** // Function to display a fruit and its percentage
 171:led.c         **** void displayFruit(char *fruit, uint8_t percentage) {
 625               		.loc 3 171 0
 626               		.cfi_startproc
 627               	.LVL60:
 628 01c2 EF92      		push r14
 629               	.LCFI5:
 630               		.cfi_def_cfa_offset 3
 631               		.cfi_offset 14, -2
 632 01c4 FF92      		push r15
 633               	.LCFI6:
 634               		.cfi_def_cfa_offset 4
 635               		.cfi_offset 15, -3
 636 01c6 0F93      		push r16
 637               	.LCFI7:
 638               		.cfi_def_cfa_offset 5
 639               		.cfi_offset 16, -4
 640 01c8 1F93      		push r17
 641               	.LCFI8:
 642               		.cfi_def_cfa_offset 6
 643               		.cfi_offset 17, -5
 644 01ca CF93      		push r28
 645               	.LCFI9:
 646               		.cfi_def_cfa_offset 7
 647               		.cfi_offset 28, -6
 648 01cc DF93      		push r29
 649               	.LCFI10:
 650               		.cfi_def_cfa_offset 8
 651               		.cfi_offset 29, -7
 652 01ce CDB7      		in r28,__SP_L__
 653 01d0 DEB7      		in r29,__SP_H__
 654               	.LCFI11:
 655               		.cfi_def_cfa_register 28
 656 01d2 6097      		sbiw r28,16
 657               	.LCFI12:
 658               		.cfi_def_cfa_offset 24
 659 01d4 0FB6      		in __tmp_reg__,__SREG__
 660 01d6 F894      		cli
 661 01d8 DEBF      		out __SP_H__,r29
 662 01da 0FBE      		out __SREG__,__tmp_reg__
 663 01dc CDBF      		out __SP_L__,r28
 664               	/* prologue: function */
 665               	/* frame size = 16 */
 666               	/* stack size = 22 */
 667               	.L__stack_usage = 22
 668 01de 7C01      		movw r14,r24
 669 01e0 162F      		mov r17,r22
 172:led.c         ****     char buffer[16];
 173:led.c         ****     LCD_Clear();
 670               		.loc 3 173 0
 671 01e2 0E94 0000 		call LCD_Clear
 672               	.LVL61:
 174:led.c         ****     LCD_String(fruit);
 673               		.loc 3 174 0
 674 01e6 C701      		movw r24,r14
 675 01e8 0E94 0000 		call LCD_String
 676               	.LVL62:
 175:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 677               		.loc 3 175 0
 678 01ec 80EC      		ldi r24,lo8(-64)
 679 01ee 0E94 0000 		call LCD_Command
 680               	.LVL63:
 176:led.c         ****     snprintf(buffer, 16, "%d%%", percentage);
 681               		.loc 3 176 0
 682 01f2 1F92      		push __zero_reg__
 683 01f4 1F93      		push r17
 684 01f6 80E0      		ldi r24,lo8(.LC6)
 685 01f8 90E0      		ldi r25,hi8(.LC6)
 686 01fa 9F93      		push r25
 687 01fc 8F93      		push r24
 688 01fe 1F92      		push __zero_reg__
 689 0200 80E1      		ldi r24,lo8(16)
 690 0202 8F93      		push r24
 691 0204 8E01      		movw r16,r28
 692 0206 0F5F      		subi r16,-1
 693 0208 1F4F      		sbci r17,-1
 694 020a 1F93      		push r17
 695 020c 0F93      		push r16
 696 020e 0E94 0000 		call snprintf
 697               	.LVL64:
 177:led.c         ****     LCD_String(buffer);
 698               		.loc 3 177 0
 699 0212 C801      		movw r24,r16
 700 0214 0E94 0000 		call LCD_String
 701               	.LVL65:
 178:led.c         **** }
 702               		.loc 3 178 0
 703 0218 0FB6      		in __tmp_reg__,__SREG__
 704 021a F894      		cli
 705 021c DEBF      		out __SP_H__,r29
 706 021e 0FBE      		out __SREG__,__tmp_reg__
 707 0220 CDBF      		out __SP_L__,r28
 708               	/* epilogue start */
 709 0222 6096      		adiw r28,16
 710 0224 0FB6      		in __tmp_reg__,__SREG__
 711 0226 F894      		cli
 712 0228 DEBF      		out __SP_H__,r29
 713 022a 0FBE      		out __SREG__,__tmp_reg__
 714 022c CDBF      		out __SP_L__,r28
 715 022e DF91      		pop r29
 716 0230 CF91      		pop r28
 717 0232 1F91      		pop r17
 718               	.LVL66:
 719 0234 0F91      		pop r16
 720 0236 FF90      		pop r15
 721 0238 EF90      		pop r14
 722               	.LVL67:
 723 023a 0895      		ret
 724               		.cfi_endproc
 725               	.LFE24:
 727               		.section	.rodata.str1.1
 728               	.LC7:
 729 0053 4578 6365 		.string	"Exceeded 100%"
 729      6564 6564 
 729      2031 3030 
 729      2500 
 730               	.LC8:
 731 0061 5365 6C65 		.string	"Select Again"
 731      6374 2041 
 731      6761 696E 
 731      00
 732               		.text
 733               	.global	displayExceededMessage
 735               	displayExceededMessage:
 736               	.LFB25:
 179:led.c         **** 
 180:led.c         **** // Function to display "Exceeded 100%" and "Select Again"
 181:led.c         **** void displayExceededMessage() {
 737               		.loc 3 181 0
 738               		.cfi_startproc
 739               	/* prologue: function */
 740               	/* frame size = 0 */
 741               	/* stack size = 0 */
 742               	.L__stack_usage = 0
 182:led.c         ****     LCD_Clear();
 743               		.loc 3 182 0
 744 023c 0E94 0000 		call LCD_Clear
 745               	.LVL68:
 183:led.c         ****     LCD_String("Exceeded 100%");
 746               		.loc 3 183 0
 747 0240 80E0      		ldi r24,lo8(.LC7)
 748 0242 90E0      		ldi r25,hi8(.LC7)
 749 0244 0E94 0000 		call LCD_String
 750               	.LVL69:
 184:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 751               		.loc 3 184 0
 752 0248 80EC      		ldi r24,lo8(-64)
 753 024a 0E94 0000 		call LCD_Command
 754               	.LVL70:
 185:led.c         ****     LCD_String("Select Again");
 755               		.loc 3 185 0
 756 024e 80E0      		ldi r24,lo8(.LC8)
 757 0250 90E0      		ldi r25,hi8(.LC8)
 758 0252 0C94 0000 		jmp LCD_String
 759               	.LVL71:
 760               		.cfi_endproc
 761               	.LFE25:
 763               		.section	.rodata.str1.1
 764               	.LC9:
 765 006e 596F 7572 		.string	"Your order is"
 765      206F 7264 
 765      6572 2069 
 765      7300 
 766               	.LC10:
 767 007c 6F6E 2074 		.string	"on the way"
 767      6865 2077 
 767      6179 00
 768               		.text
 769               	.global	displayOrderComplete
 771               	displayOrderComplete:
 772               	.LFB26:
 186:led.c         **** }
 187:led.c         **** 
 188:led.c         **** // Function to display "Your order is" and "on the way"
 189:led.c         **** void displayOrderComplete() {
 773               		.loc 3 189 0
 774               		.cfi_startproc
 775               	/* prologue: function */
 776               	/* frame size = 0 */
 777               	/* stack size = 0 */
 778               	.L__stack_usage = 0
 190:led.c         ****     LCD_Clear();
 779               		.loc 3 190 0
 780 0256 0E94 0000 		call LCD_Clear
 781               	.LVL72:
 191:led.c         ****     LCD_String("Your order is");
 782               		.loc 3 191 0
 783 025a 80E0      		ldi r24,lo8(.LC9)
 784 025c 90E0      		ldi r25,hi8(.LC9)
 785 025e 0E94 0000 		call LCD_String
 786               	.LVL73:
 192:led.c         ****     LCD_Command(0xC0);  // Move to the 2nd row
 787               		.loc 3 192 0
 788 0262 80EC      		ldi r24,lo8(-64)
 789 0264 0E94 0000 		call LCD_Command
 790               	.LVL74:
 193:led.c         ****     LCD_String("on the way");
 791               		.loc 3 193 0
 792 0268 80E0      		ldi r24,lo8(.LC10)
 793 026a 90E0      		ldi r25,hi8(.LC10)
 794 026c 0C94 0000 		jmp LCD_String
 795               	.LVL75:
 796               		.cfi_endproc
 797               	.LFE26:
 799               	.global	readEncoder
 801               	readEncoder:
 802               	.LFB27:
 194:led.c         **** }
 195:led.c         **** 
 196:led.c         **** // Function to read rotary encoder rotation
 197:led.c         **** int8_t readEncoder() {
 803               		.loc 3 197 0
 804               		.cfi_startproc
 805               	/* prologue: function */
 806               	/* frame size = 0 */
 807               	/* stack size = 0 */
 808               	.L__stack_usage = 0
 198:led.c         ****     static uint8_t lastStateCLK = 0;
 199:led.c         ****     uint8_t currentStateCLK = PINB & (1 << PB1);
 809               		.loc 3 199 0
 810 0270 83B1      		in r24,0x3
 811 0272 8270      		andi r24,lo8(2)
 812               	.LVL76:
 200:led.c         **** 
 201:led.c         ****     if (currentStateCLK != lastStateCLK) {
 813               		.loc 3 201 0
 814 0274 9091 0000 		lds r25,lastStateCLK.1827
 815 0278 8917      		cp r24,r25
 816 027a 01F0      		breq .L35
 202:led.c         ****         if (PINB & (1 << PB2)) {
 817               		.loc 3 202 0
 818 027c 1A9B      		sbis 0x3,2
 819 027e 00C0      		rjmp .L34
 203:led.c         ****             lastStateCLK = currentStateCLK;
 820               		.loc 3 203 0
 821 0280 8093 0000 		sts lastStateCLK.1827,r24
 204:led.c         ****             return 1;  // Clockwise rotation
 822               		.loc 3 204 0
 823 0284 81E0      		ldi r24,lo8(1)
 824               	.LVL77:
 825 0286 0895      		ret
 826               	.LVL78:
 827               	.L34:
 205:led.c         ****         } else {
 206:led.c         ****             lastStateCLK = currentStateCLK;
 828               		.loc 3 206 0
 829 0288 8093 0000 		sts lastStateCLK.1827,r24
 207:led.c         ****             return -1;  // Counterclockwise rotation
 830               		.loc 3 207 0
 831 028c 8FEF      		ldi r24,lo8(-1)
 832               	.LVL79:
 833 028e 0895      		ret
 834               	.LVL80:
 835               	.L35:
 208:led.c         ****         }
 209:led.c         ****     }
 210:led.c         ****     return 0;  // No rotation
 836               		.loc 3 210 0
 837 0290 80E0      		ldi r24,0
 838               	.LVL81:
 211:led.c         **** }
 839               		.loc 3 211 0
 840 0292 0895      		ret
 841               		.cfi_endproc
 842               	.LFE27:
 844               		.section	.rodata.str1.1
 845               	.LC11:
 846 0087 546F 7461 		.string	"Total should not"
 846      6C20 7368 
 846      6F75 6C64 
 846      206E 6F74 
 846      00
 847               	.LC12:
 848 0098 6578 6365 		.string	"exceed 100%"
 848      6564 2031 
 848      3030 2500 
 849               		.section	.text.startup,"ax",@progbits
 850               	.global	main
 852               	main:
 853               	.LFB16:
  26:led.c         ****     uint8_t switch1State = 0;
 854               		.loc 3 26 0
 855               		.cfi_startproc
 856               	/* prologue: function */
 857               	/* frame size = 0 */
 858               	/* stack size = 0 */
 859               	.L__stack_usage = 0
 860               	.LVL82:
  32:led.c         ****     LCD_Init();  // Initialize LCD
 861               		.loc 3 32 0
 862 0000 0E94 0000 		call setup
 863               	.LVL83:
  33:led.c         **** 
 864               		.loc 3 33 0
 865 0004 0E94 0000 		call LCD_Init
 866               	.LVL84:
  35:led.c         **** 
 867               		.loc 3 35 0
 868 0008 0E94 0000 		call displayAutoManual
 869               	.LVL85:
  30:led.c         **** 
 870               		.loc 3 30 0
 871 000c 10E0      		ldi r17,0
  28:led.c         ****     uint8_t encoderSwitchState = 0;
 872               		.loc 3 28 0
 873 000e 00E0      		ldi r16,0
  58:led.c         ****             displayFruit(fruits[fruitIndex], percentage);
 874               		.loc 3 58 0
 875 0010 D1E0      		ldi r29,lo8(1)
 876               	.LVL86:
 877               	.L44:
  39:led.c         **** 
 878               		.loc 3 39 0
 879 0012 0E94 0000 		call isSwitch1Pressed
 880               	.LVL87:
 881 0016 C82F      		mov r28,r24
 882               	.LVL88:
  41:led.c         ****             // Start the auto mode sequence
 883               		.loc 3 41 0
 884 0018 8823      		tst r24
 885 001a 01F0      		breq .L37
  41:led.c         ****             // Start the auto mode sequence
 886               		.loc 3 41 0 is_stmt 0 discriminator 1
 887 001c 0111      		cpse r16,__zero_reg__
 888 001e 00C0      		rjmp .L37
  43:led.c         ****             _delay_ms(4000);
 889               		.loc 3 43 0 is_stmt 1
 890 0020 0E94 0000 		call displayProcessing
 891               	.LVL89:
 892               	.LBB38:
 893               	.LBB39:
 187:/usr/lib/avr/include/util/delay.h **** 
 894               		.loc 2 187 0
 895 0024 2FEF      		ldi r18,lo8(799999)
 896 0026 84E3      		ldi r24,hi8(799999)
 897 0028 9CE0      		ldi r25,hlo8(799999)
 898 002a 2150      	1:	subi r18,1
 899 002c 8040      		sbci r24,0
 900 002e 9040      		sbci r25,0
 901 0030 01F4      		brne 1b
 902 0032 00C0      		rjmp .
 903 0034 0000      		nop
 904               	.LVL90:
 905               	.LBE39:
 906               	.LBE38:
  46:led.c         ****             _delay_ms(4000);
 907               		.loc 3 46 0
 908 0036 0E94 0000 		call displayChoosePercentages
 909               	.LVL91:
 910               	.LBB40:
 911               	.LBB41:
 187:/usr/lib/avr/include/util/delay.h **** 
 912               		.loc 2 187 0
 913 003a 2FEF      		ldi r18,lo8(799999)
 914 003c 84E3      		ldi r24,hi8(799999)
 915 003e 9CE0      		ldi r25,hlo8(799999)
 916 0040 2150      	1:	subi r18,1
 917 0042 8040      		sbci r24,0
 918 0044 9040      		sbci r25,0
 919 0046 01F4      		brne 1b
 920 0048 00C0      		rjmp .
 921 004a 0000      		nop
 922               	.LVL92:
 923               	.LBE41:
 924               	.LBE40:
  49:led.c         ****             LCD_String("Total should not");
 925               		.loc 3 49 0
 926 004c 0E94 0000 		call LCD_Clear
 927               	.LVL93:
  50:led.c         ****             LCD_Command(0xC0);  // Move to 2nd row
 928               		.loc 3 50 0
 929 0050 80E0      		ldi r24,lo8(.LC11)
 930 0052 90E0      		ldi r25,hi8(.LC11)
 931 0054 0E94 0000 		call LCD_String
 932               	.LVL94:
  51:led.c         ****             LCD_String("exceed 100%");
 933               		.loc 3 51 0
 934 0058 80EC      		ldi r24,lo8(-64)
 935 005a 0E94 0000 		call LCD_Command
 936               	.LVL95:
  52:led.c         ****             _delay_ms(4000);
 937               		.loc 3 52 0
 938 005e 80E0      		ldi r24,lo8(.LC12)
 939 0060 90E0      		ldi r25,hi8(.LC12)
 940 0062 0E94 0000 		call LCD_String
 941               	.LVL96:
 942               	.LBB42:
 943               	.LBB43:
 187:/usr/lib/avr/include/util/delay.h **** 
 944               		.loc 2 187 0
 945 0066 2FEF      		ldi r18,lo8(799999)
 946 0068 84E3      		ldi r24,hi8(799999)
 947 006a 9CE0      		ldi r25,hlo8(799999)
 948 006c 2150      	1:	subi r18,1
 949 006e 8040      		sbci r24,0
 950 0070 9040      		sbci r25,0
 951 0072 01F4      		brne 1b
 952 0074 00C0      		rjmp .
 953 0076 0000      		nop
 954               	.LVL97:
 955               	.LBE43:
 956               	.LBE42:
  56:led.c         ****             percentage = 0;
 957               		.loc 3 56 0
 958 0078 1092 0000 		sts fruitIndex,__zero_reg__
  57:led.c         ****             selectingPercentage = 1;  // Enable encoder for percentage selection
 959               		.loc 3 57 0
 960 007c 1092 0000 		sts percentage,__zero_reg__
  58:led.c         ****             displayFruit(fruits[fruitIndex], percentage);
 961               		.loc 3 58 0
 962 0080 D093 0000 		sts selectingPercentage,r29
  59:led.c         ****         }
 963               		.loc 3 59 0
 964 0084 60E0      		ldi r22,0
 965 0086 8091 0000 		lds r24,fruits
 966 008a 9091 0000 		lds r25,fruits+1
 967 008e 0E94 0000 		call displayFruit
 968               	.LVL98:
 969               	.L37:
  64:led.c         ****             // Read the rotary encoder to adjust the percentage
 970               		.loc 3 64 0
 971 0092 8091 0000 		lds r24,selectingPercentage
 972 0096 8823      		tst r24
 973 0098 01F4      		brne .+2
 974 009a 00C0      		rjmp .L45
 975               	.LBB44:
  66:led.c         ****             if (rotation > 0 && percentage < 100) {
 976               		.loc 3 66 0
 977 009c 0E94 0000 		call readEncoder
 978               	.LVL99:
  67:led.c         ****                 percentage += 20;
 979               		.loc 3 67 0
 980 00a0 1816      		cp __zero_reg__,r24
 981 00a2 04F4      		brge .L39
  67:led.c         ****                 percentage += 20;
 982               		.loc 3 67 0 is_stmt 0 discriminator 1
 983 00a4 6091 0000 		lds r22,percentage
 984 00a8 6436      		cpi r22,lo8(100)
 985 00aa 00F4      		brsh .L39
  68:led.c         ****                 displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percentage
 986               		.loc 3 68 0 is_stmt 1
 987 00ac 6C5E      		subi r22,lo8(-(20))
 988 00ae 6093 0000 		sts percentage,r22
  69:led.c         ****             }
 989               		.loc 3 69 0
 990 00b2 E091 0000 		lds r30,fruitIndex
 991 00b6 F0E0      		ldi r31,0
 992 00b8 EE0F      		lsl r30
 993 00ba FF1F      		rol r31
 994 00bc E050      		subi r30,lo8(-(fruits))
 995 00be F040      		sbci r31,hi8(-(fruits))
 996 00c0 8081      		ld r24,Z
 997 00c2 9181      		ldd r25,Z+1
 998               	.LVL100:
 999 00c4 0E94 0000 		call displayFruit
 1000               	.LVL101:
 1001               	.L39:
  73:led.c         ****                 percentage -= 20;
 1002               		.loc 3 73 0
 1003 00c8 0E94 0000 		call isSwitch2Pressed
 1004               	.LVL102:
 1005 00cc 8823      		tst r24
 1006 00ce 01F0      		breq .L40
  73:led.c         ****                 percentage -= 20;
 1007               		.loc 3 73 0 is_stmt 0 discriminator 1
 1008 00d0 6091 0000 		lds r22,percentage
 1009 00d4 6623      		tst r22
 1010 00d6 01F0      		breq .L40
  74:led.c         ****                 displayFruit(fruits[fruitIndex], percentage);  // Update the displayed percentage
 1011               		.loc 3 74 0 is_stmt 1
 1012 00d8 6451      		subi r22,lo8(-(-20))
 1013 00da 6093 0000 		sts percentage,r22
  75:led.c         ****             }
 1014               		.loc 3 75 0
 1015 00de E091 0000 		lds r30,fruitIndex
 1016 00e2 F0E0      		ldi r31,0
 1017 00e4 EE0F      		lsl r30
 1018 00e6 FF1F      		rol r31
 1019 00e8 E050      		subi r30,lo8(-(fruits))
 1020 00ea F040      		sbci r31,hi8(-(fruits))
 1021 00ec 8081      		ld r24,Z
 1022 00ee 9181      		ldd r25,Z+1
 1023 00f0 0E94 0000 		call displayFruit
 1024               	.LVL103:
 1025               	.L40:
  79:led.c         ****             if (encoderSwitchState && !lastEncoderSwitchState) {
 1026               		.loc 3 79 0
 1027 00f4 0E94 0000 		call isEncoderPressed
 1028               	.LVL104:
 1029 00f8 082F      		mov r16,r24
 1030               	.LVL105:
  80:led.c         ****                 percentages[fruitIndex] = percentage;  // Store the selected percentage
 1031               		.loc 3 80 0
 1032 00fa 8823      		tst r24
 1033 00fc 01F4      		brne .+2
 1034 00fe 00C0      		rjmp .L38
  80:led.c         ****                 percentages[fruitIndex] = percentage;  // Store the selected percentage
 1035               		.loc 3 80 0 is_stmt 0 discriminator 1
 1036 0100 1111      		cpse r17,__zero_reg__
 1037 0102 00C0      		rjmp .L38
  81:led.c         ****                 fruitIndex++;  // Move to the next fruit
 1038               		.loc 3 81 0 is_stmt 1
 1039 0104 E091 0000 		lds r30,fruitIndex
 1040 0108 AE2F      		mov r26,r30
 1041 010a B0E0      		ldi r27,0
 1042 010c A050      		subi r26,lo8(-(percentages))
 1043 010e B040      		sbci r27,hi8(-(percentages))
 1044 0110 8091 0000 		lds r24,percentage
 1045 0114 8C93      		st X,r24
  82:led.c         **** 
 1046               		.loc 3 82 0
 1047 0116 EF5F      		subi r30,lo8(-(1))
 1048 0118 E093 0000 		sts fruitIndex,r30
  84:led.c         ****                     percentage = 0;  // Reset percentage for the next fruit
 1049               		.loc 3 84 0
 1050 011c E430      		cpi r30,lo8(4)
 1051 011e 00F4      		brsh .L41
  85:led.c         ****                     displayFruit(fruits[fruitIndex], percentage);  // Display next fruit
 1052               		.loc 3 85 0
 1053 0120 1092 0000 		sts percentage,__zero_reg__
  86:led.c         ****                 } else {
 1054               		.loc 3 86 0
 1055 0124 F0E0      		ldi r31,0
 1056 0126 EE0F      		lsl r30
 1057 0128 FF1F      		rol r31
 1058 012a E050      		subi r30,lo8(-(fruits))
 1059 012c F040      		sbci r31,hi8(-(fruits))
 1060 012e 60E0      		ldi r22,0
 1061 0130 8081      		ld r24,Z
 1062 0132 9181      		ldd r25,Z+1
 1063 0134 00C0      		rjmp .L58
 1064               	.L41:
 1065               	.LBB45:
  88:led.c         **** 
 1066               		.loc 3 88 0
 1067 0136 1092 0000 		sts selectingPercentage,__zero_reg__
 1068               	.LVL106:
  92:led.c         ****                         displayExceededMessage();
 1069               		.loc 3 92 0
 1070 013a 9091 0000 		lds r25,percentages
 1071 013e 8091 0000 		lds r24,percentages+1
 1072 0142 890F      		add r24,r25
 1073 0144 9091 0000 		lds r25,percentages+2
 1074 0148 890F      		add r24,r25
 1075 014a 9091 0000 		lds r25,percentages+3
 1076 014e 890F      		add r24,r25
 1077 0150 8536      		cpi r24,lo8(101)
 1078 0152 00F0      		brlo .L42
  93:led.c         ****                         _delay_ms(3000);
 1079               		.loc 3 93 0
 1080 0154 0E94 0000 		call displayExceededMessage
 1081               	.LVL107:
 1082               	.LBB46:
 1083               	.LBB47:
 187:/usr/lib/avr/include/util/delay.h **** 
 1084               		.loc 2 187 0
 1085 0158 2FEB      		ldi r18,lo8(599999)
 1086 015a 87E2      		ldi r24,hi8(599999)
 1087 015c 99E0      		ldi r25,hlo8(599999)
 1088 015e 2150      	1:	subi r18,1
 1089 0160 8040      		sbci r24,0
 1090 0162 9040      		sbci r25,0
 1091 0164 01F4      		brne 1b
 1092 0166 00C0      		rjmp .
 1093 0168 0000      		nop
 1094               	.LVL108:
 1095               	.LBE47:
 1096               	.LBE46:
  97:led.c         ****                         percentage = 0;
 1097               		.loc 3 97 0
 1098 016a 1092 0000 		sts fruitIndex,__zero_reg__
  98:led.c         ****                         selectingPercentage = 1;
 1099               		.loc 3 98 0
 1100 016e 1092 0000 		sts percentage,__zero_reg__
  99:led.c         ****                         displayFruit(fruits[fruitIndex], percentage);
 1101               		.loc 3 99 0
 1102 0172 D093 0000 		sts selectingPercentage,r29
 100:led.c         ****                     } else {
 1103               		.loc 3 100 0
 1104 0176 60E0      		ldi r22,0
 1105 0178 8091 0000 		lds r24,fruits
 1106 017c 9091 0000 		lds r25,fruits+1
 1107               	.L58:
 1108 0180 0E94 0000 		call displayFruit
 1109               	.LVL109:
 1110 0184 00C0      		rjmp .L38
 1111               	.LVL110:
 1112               	.L42:
 102:led.c         ****                         while (1);  // Stop the program
 1113               		.loc 3 102 0
 1114 0186 0E94 0000 		call displayOrderComplete
 1115               	.LVL111:
 1116               	.L43:
 1117 018a 00C0      		rjmp .L43
 1118               	.LVL112:
 1119               	.L45:
 1120               	.LBE45:
 1121               	.LBE44:
 1122 018c 012F      		mov r16,r17
 1123               	.L38:
 1124               	.LVL113:
 1125               	.LBB48:
 1126               	.LBB49:
 187:/usr/lib/avr/include/util/delay.h **** 
 1127               		.loc 2 187 0
 1128 018e 83ED      		ldi r24,lo8(12499)
 1129 0190 90E3      		ldi r25,hi8(12499)
 1130 0192 0197      	1:	sbiw r24,1
 1131 0194 01F4      		brne 1b
 1132 0196 00C0      		rjmp .
 1133 0198 0000      		nop
 1134               	.LBE49:
 1135               	.LBE48:
  39:led.c         **** 
 1136               		.loc 3 39 0
 1137 019a 102F      		mov r17,r16
 1138 019c 0C2F      		mov r16,r28
 1139               	.LVL114:
 1140 019e 00C0      		rjmp .L44
 1141               		.cfi_endproc
 1142               	.LFE16:
 1144               		.local	lastStateCLK.1827
 1145               		.comm	lastStateCLK.1827,1,1
 1146               	.global	selectingPercentage
 1147               		.section .bss
 1150               	selectingPercentage:
 1151 0000 00        		.zero	1
 1152               	.global	percentage
 1155               	percentage:
 1156 0001 00        		.zero	1
 1157               	.global	percentages
 1160               	percentages:
 1161 0002 0000 0000 		.zero	4
 1162               	.global	fruitIndex
 1165               	fruitIndex:
 1166 0006 00        		.zero	1
 1167               	.global	fruits
 1168               		.section	.rodata.str1.1
 1169               	.LC13:
 1170 00a4 5049 4E45 		.string	"PINEAPPLE"
 1170      4150 504C 
 1170      4500 
 1171               	.LC14:
 1172 00ae 4D41 4E47 		.string	"MANGO"
 1172      4F00 
 1173               	.LC15:
 1174 00b4 4150 504C 		.string	"APPLE"
 1174      4500 
 1175               	.LC16:
 1176 00ba 4F52 414E 		.string	"ORANGE"
 1176      4745 00
 1177               		.data
 1180               	fruits:
 1181 0000 0000      		.word	.LC13
 1182 0002 0000      		.word	.LC14
 1183 0004 0000      		.word	.LC15
 1184 0006 0000      		.word	.LC16
 1185               		.text
 1186               	.Letext0:
 1187               		.file 4 "/usr/lib/avr/include/stdint.h"
 1188               		.file 5 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 led.c
     /tmp/ccHXT0d0.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccHXT0d0.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccHXT0d0.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccHXT0d0.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccHXT0d0.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccHXT0d0.s:12     .text:0000000000000000 I2C_Init
     /tmp/ccHXT0d0.s:35     .text:0000000000000012 I2C_Start
     /tmp/ccHXT0d0.s:59     .text:0000000000000022 I2C_Stop
     /tmp/ccHXT0d0.s:88     .text:0000000000000032 I2C_Write
     /tmp/ccHXT0d0.s:131    .text:0000000000000058 LCD_EnablePulse
     /tmp/ccHXT0d0.s:184    .text:000000000000007c LCD_Command
     /tmp/ccHXT0d0.s:233    .text:00000000000000a8 LCD_Char
     /tmp/ccHXT0d0.s:282    .text:00000000000000d4 LCD_Init
     /tmp/ccHXT0d0.s:343    .text:0000000000000110 LCD_String
     /tmp/ccHXT0d0.s:386    .text:0000000000000128 LCD_Clear
     /tmp/ccHXT0d0.s:416    .text:000000000000013c setup
     /tmp/ccHXT0d0.s:449    .text:0000000000000152 isSwitch1Pressed
     /tmp/ccHXT0d0.s:468    .text:000000000000015a isSwitch2Pressed
     /tmp/ccHXT0d0.s:489    .text:0000000000000166 isEncoderPressed
     /tmp/ccHXT0d0.s:517    .text:0000000000000174 displayAutoManual
     /tmp/ccHXT0d0.s:553    .text:000000000000018e displayProcessing
     /tmp/ccHXT0d0.s:589    .text:00000000000001a8 displayChoosePercentages
     /tmp/ccHXT0d0.s:623    .text:00000000000001c2 displayFruit
     /tmp/ccHXT0d0.s:735    .text:000000000000023c displayExceededMessage
     /tmp/ccHXT0d0.s:771    .text:0000000000000256 displayOrderComplete
     /tmp/ccHXT0d0.s:801    .text:0000000000000270 readEncoder
                             .bss:0000000000000007 lastStateCLK.1827
     /tmp/ccHXT0d0.s:852    .text.startup:0000000000000000 main
     /tmp/ccHXT0d0.s:1165   .bss:0000000000000006 fruitIndex
     /tmp/ccHXT0d0.s:1155   .bss:0000000000000001 percentage
     /tmp/ccHXT0d0.s:1150   .bss:0000000000000000 selectingPercentage
     /tmp/ccHXT0d0.s:1180   .data:0000000000000000 fruits
     /tmp/ccHXT0d0.s:1160   .bss:0000000000000002 percentages

UNDEFINED SYMBOLS
snprintf
__do_copy_data
__do_clear_bss
